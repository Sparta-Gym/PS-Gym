# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/2230" rel="nofollow">2230 - 수 고르기</a>](#2230---수-고르기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 풀이](#2-풀이)
  - [<a href="https://www.acmicpc.net/problem/1806" rel="nofollow">1806 - 부분합</a>](#1806---부분합)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 풀이](#2-풀이-1)
  - [<a href="https://www.acmicpc.net/problem/1644" rel="nofollow">1644 - 소수의 연속합</a>](#1644---소수의-연속합)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 풀이](#2-풀이-2)
  - [<a href="https://www.acmicpc.net/problem/2003" rel="nofollow">2003 - 수들의 합 2</a>](#2003---수들의-합-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 풀이](#2-풀이-3)
  - [<a href="https://www.acmicpc.net/problem/13144" rel="nofollow">13144 - List of Unique Numbers</a>](#13144---list-of-unique-numbers)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 풀이](#2-풀이-4)
  - [<a href="https://www.acmicpc.net/problem/22862" rel="nofollow">22862 - 가장 긴 짝수 연속한 부분 수열 (large)</a>](#22862---가장-긴-짝수-연속한-부분-수열-large)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 풀이](#2-풀이-5)
  - [<a href="https://www.acmicpc.net/problem/2531" rel="nofollow">2531 - 회전 초밥</a>](#2531---회전-초밥)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 풀이](#2-풀이-6)
  - [<a href="https://www.acmicpc.net/problem/20922" rel="nofollow">20922 - 겹치는 건 싫어</a>](#20922---겹치는-건-싫어)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 풀이](#2-풀이-7)
  - [<a href="https://www.acmicpc.net/problem/2461" rel="nofollow">2461 - 대표 선수</a>](#2461---대표-선수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
    - [2. 풀이](#2-풀이-8)
  - [<a href="https://www.acmicpc.net/problem/2283" rel="nofollow">2283 - 구간 자르기</a>](#2283---구간-자르기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-9)
    - [2. 풀이](#2-풀이-9)
  - [<a href="https://www.acmicpc.net/problem/20366" rel="nofollow">20366 - 같이 눈사람 만들래?</a>](#20366---같이-눈사람-만들래)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-10)
    - [2. 풀이](#2-풀이-10)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 10월 29일 토요일 21시 04분 43초 KST -->

<!--te-->

## [2230 - 수 고르기](https://www.acmicpc.net/problem/2230)

### 1. 해결 핵심 아이디어

- 가장 단순하게 떠올릴 수 있는 이중 반복문을 통한 풀이를 생각해보자

  ```cpp

  for(int i=0; i<n; ++i){
   for(int j=i j<n; ++j){
    if(a[j] - a[i] >= m) ans = min(ans, a[j] - a[i]);
   }
  }

  ```

- 이 풀이에서 불필요한 작업이 무엇인지 생각해보자
- a를 정렬했다고 가정하자
- i가 증가함에 따라 a[j] - a[i] ≥ m을 만족하는 최초의 지점 j 또한 증가하는데, 무조건 i부터 검사함
- 각 i에 대해 a[j] - a[i] ≥ m을 만족하는 최초의 지점 j를 찾은 이후에는 a[j+1], a[j+2], …를 확인할 필요가 없음에도 n-1까지 확인함
- 각각의 원소에 대하여 두 개의 포인터 st(i의 역할)와 en(j의 역할)을 두고 en - st >= m을 만족하는 en을 찾는다, 만약 min이 갱신될 수 있으면 갱신한다
- 정렬과 투 포인터를 통해 굳이 확인안해도 되는 원소의 쌍을 확인하지 않게되었다

### 2. 풀이

- 투 포인터 문제들은 인덱스 에러를 내기 쉽다, out of index
- 포인터가 배열 내에서만 동작하도록 꼼꼼히 구현해야한다
- 이분탐색으로도 풀 수 있음, 자세한 풀이는 [2230_Another.cpp](./2230_Another.cpp)참조

## [1806 - 부분합](https://www.acmicpc.net/problem/1806)

### 1. 해결 핵심 아이디어

- 가장 단순하게 풀 수 있는 이중 반복문 풀이

  ```cpp
    for(int i=0; i<n; ++i)
      int sum = i;
      for(int j = i+1; j<n; ++j)
        if(sum + a[j] > s) break;
        sum += a[j];
  ```

- 이 풀이에서 불필요한 작업이 무엇인지 생각해보자
- 부분합을 구하는 구간이 겹치는 부분이 많다 예를 들어 [1,5]와 [2,6]이 각각 S이상을 만족한다고 할 때 [2,5]의 합이 지속적으로 구해지고 있다
- 하지만 한 번만 구해놓고 다음 후보를 찾을 때 쓸 수 있다
- [1,5]의 부분합에서 a[1]을 빼면 [2,5]의 부분합이 나오기 때문에 [2,6]의 부분합을 구할 때 여기다 a[6]만 더해주면 되기 때문이다
- 위 방법으로 문제를 풀면 O(N)에 해결가능하고, N의 상한이 십만이고, 시간 제한은 0.5초 이기때문에 최대 5천만번의 연산이 가능하므로 통과가능하다
- st가 i의 역할을 en이 j의 역할을 하는 투포인터를 이용한 풀이로 변경하면, en이 n을 넘지않을 때까지 하나씩 이동시켜가면서 합이 s를 넘는지 확인한다
- st를 1증기시키고 구해놓은 부분합에서 a[st]를 빼고 a[st+1]부터 시작하는 연속된 부분합 중에 S가 넘는게 있을 때까지 en을 이동시키면서 반복한다

### 2. 풀이

- 이분탐색으로도 문제 풀 수 있다 자세한 풀이는 [1806_Another.cpp](./1806_Another.cpp) 참조

## [1644 - 소수의 연속합](https://www.acmicpc.net/problem/1644)

### 1. 해결 핵심 아이디어

- 1806 부분합 문제와 동일한 아이디어

### 2. 풀이

- 소수 구할 때 에라토스테네스의 체를 활용했음

## [2003 - 수들의 합 2](https://www.acmicpc.net/problem/2003)

### 1. 해결 핵심 아이디어

- 2230번 수 고르기 문제와 동일한 아이디어로 해결가능

### 2. 풀이

- 인덱스 실수 안하게 주의하자

## [13144 - List of Unique Numbers](https://www.acmicpc.net/problem/13144)

### 1. 해결 핵심 아이디어

- 이 문제를 못 푼 것에 대해서는 반성해야한다
- 단순히 등장했는지 안 했는지만 체크하면되는데 이 간단한 것을 생각해내지 못하다니 진짜 분하다
- 두 개의 포인터를 두는데, st와 en은 각각 살펴보고 있는 구간의 시작과 끝이다
- 어떤 수를 추가할 때 이 수가 나왔었는지 확인하기 위해 is_used배열을 활용하여 flag로 표시해준다
  - 백트래킹이나 다른데서 많이 썼던 아이디어인데 왜 왜 왜 응용을 못하니...
- 어떤 구간에서 가능한 경우의 수는 구간의 길이와 같다 예시로 1 2 3 4 5에서 생기는 경우는 15인데 st가 1을 가리키고 en이 5를 가리킬 때 가능한 경우는 5가지인데 이것은 구간의 길이와 같다

### 2. 풀이

- 빈도수배열까지 생각했는데 이걸 왜 생각못했지? 머리가 나쁜건 진짜 힘드네

## [22862 - 가장 긴 짝수 연속한 부분 수열 (large)](https://www.acmicpc.net/problem/22862)

### 1. 해결 핵심 아이디어

- st와 en으로 구간을 만들고 만들어진 구간에 홀수가 등장할 때마다 카운트를 1씩 증가시켜서 cnt > k가 되는 순간이나 en이 n-1보다 커지는 경우 탈출하여 연속되는 짝수의 개수를 세줬음
- 만들어진 구간에서 최장 연속 짝수의 개수는 en - st - cnt임

### 2. 풀이

- 삭제시킬 수 있다고해서 곧이곧대로 삭제했으면 매우 어려워졌을 것임

## [2531 - 회전 초밥](https://www.acmicpc.net/problem/2531)

### 1. 해결 핵심 아이디어

- 연속하여 k개가 될 때까지 en을 이동시킨다
- uniq는 연속된 k개로 이뤄진 초밥들 중 유일한 초밥 종류의 수이다
- 만약 이전에 나왔던 거라면 uniq를 증가시키지 않고, 처음나오면 것이면 uniq를 증가시킨다
- 이전에 구간에서 구했던 uniq의 개수를 활용한다
- 다 구하고나서 쿠폰이 안 쓰인 경우, 추가해준다
- st를 1 이동시킬 때, 이전 st가 유일한 번호였다면 uniq를 1 감소시킨다

### 2. 풀이

- 구현이 까다로웠던 문제

## [20922 - 겹치는 건 싫어](https://www.acmicpc.net/problem/20922)

### 1. 해결 핵심 아이디어

- st와 en을 연속 수열의 시작과 끝으로 두고 원소를 추가해나가는데, 빈도수 배열을 활용해서 추가할 원소가 k번 이상쓰였는지 확인한다
- 만약 k번 미만으로 사용되었다면 추가하고 사용된 횟수가 k번 이상일 때는 추가할 수 없으므로 en의 이동을 멈춘다

### 2. 풀이

- while문에 is_used[s[en]] + 1 <= k를 하면되는 간단한 문제였는데, +1을 할 생각을 좀 늦게했음, 구현력이 너무 안좋다 진짜

## [2461 - 대표 선수](https://www.acmicpc.net/problem/2461)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [2283 - 구간 자르기](https://www.acmicpc.net/problem/2283)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [20366 - 같이 눈사람 만들래?](https://www.acmicpc.net/problem/20366)

### 1. 해결 핵심 아이디어

### 2. 풀이
