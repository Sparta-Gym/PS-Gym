# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/1920" rel="nofollow">1920 - 수 찾기</a>](#1920---수-찾기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 풀이](#2-풀이)
  - [<a href="https://www.acmicpc.net/problem/10816" rel="nofollow">10816 - 숫자 카드 2</a>](#10816---숫자-카드-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 풀이](#2-풀이-1)
  - [<a href="https://www.acmicpc.net/problem/18870" rel="nofollow">18870 - 좌표 압축</a>](#18870---좌표-압축)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 풀이](#2-풀이-2)
  - [<a href="https://www.acmicpc.net/problem/2295" rel="nofollow">2295 - 세 수의 합</a>](#2295---세-수의-합)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 풀이](#2-풀이-3)
  - [<a href="https://www.acmicpc.net/problem/1654" rel="nofollow">1654 - 랜선 자르기</a>](#1654---랜선-자르기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 풀이](#2-풀이-4)
  - [<a href="https://www.acmicpc.net/problem/10815" rel="nofollow">10815 - 숫자 카드</a>](#10815---숫자-카드)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 풀이](#2-풀이-5)
  - [<a href="https://www.acmicpc.net/problem/1822" rel="nofollow">1822 - 차집합</a>](#1822---차집합)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 풀이](#2-풀이-6)
  - [<a href="https://www.acmicpc.net/problem/16401" rel="nofollow">16401 - 과자 나눠주기</a>](#16401---과자-나눠주기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 풀이](#2-풀이-7)
  - [<a href="https://www.acmicpc.net/problem/2805" rel="nofollow">2805 - 나무 자르기</a>](#2805---나무-자르기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
    - [2. 풀이](#2-풀이-8)
  - [<a href="https://www.acmicpc.net/problem/18869" rel="nofollow">18869 - 멀티버스 Ⅱ</a>](#18869---멀티버스-ⅱ)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-9)
    - [2. 풀이](#2-풀이-9)
  - [<a href="https://www.acmicpc.net/problem/2467" rel="nofollow">2467 - 용액</a>](#2467---용액)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-10)
    - [2. 풀이](#2-풀이-10)
  - [<a href="https://www.acmicpc.net/problem/3151" rel="nofollow">3151 - 합이 0</a>](#3151---합이-0)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-11)
    - [2. 풀이](#2-풀이-11)
  - [<a href="https://www.acmicpc.net/problem/14921" rel="nofollow">14921 - 용액 합성하기</a>](#14921---용액-합성하기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-12)
    - [2. 풀이](#2-풀이-12)
  - [<a href="https://www.acmicpc.net/problem/1253" rel="nofollow">1253 - 좋다</a>](#1253---좋다)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-13)
    - [2. 풀이](#2-풀이-13)
  - [<a href="https://www.acmicpc.net/problem/2143" rel="nofollow">2143 - 두 배열의 합</a>](#2143---두-배열의-합)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-14)
    - [2. 풀이](#2-풀이-14)
  - [<a href="https://www.acmicpc.net/problem/2473" rel="nofollow">2473 - 세 용액</a>](#2473---세-용액)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-15)
    - [2. 풀이](#2-풀이-15)
  - [<a href="https://www.acmicpc.net/problem/2110" rel="nofollow">2110 - 공유기 설치</a>](#2110---공유기-설치)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-16)
    - [2. 풀이](#2-풀이-16)
  - [<a href="https://www.acmicpc.net/problem/7453" rel="nofollow">7453 - 합이 0인 네 정수</a>](#7453---합이-0인-네-정수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-17)
    - [2. 풀이](#2-풀이-17)
  - [<a href="https://www.acmicpc.net/problem/12015" rel="nofollow">12015 - 가장 긴 증가하는 부분 수열 2</a>](#12015---가장-긴-증가하는-부분-수열-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-18)
    - [2. 풀이](#2-풀이-18)
  - [<a href="https://www.acmicpc.net/problem/2512" rel="nofollow">2512 - 예산</a>](#2512---예산)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-19)
    - [2. 풀이](#2-풀이-19)
  - [<a href="https://www.acmicpc.net/problem/1477" rel="nofollow">1477 - 휴게소 세우기</a>](#1477---휴게소-세우기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-20)
    - [2. 풀이](#2-풀이-20)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 10월 21일 금요일 16시 39분 28초 KST -->

<!--te-->

## [1920 - 수 찾기](https://www.acmicpc.net/problem/1920)

### 1. 해결 핵심 아이디어

- 전체 원소를 둘러보는 O(N)의 탐색방법을 이용하면 N과 M의 상한이 모두 십만이기때문에 시간초과를 받는다
- 정렬과 이분탐색을 이용하면 O(NlogN)에 해결 가능하다

### 2. 풀이

- 정렬하고 이분탐색해주고 있으면 1 없으면 0을 출력한다

## [10816 - 숫자 카드 2](https://www.acmicpc.net/problem/10816)

### 1. 해결 핵심 아이디어

- 배열 내에서 빈도수를 확인할 때 이분탐색이 활용될 수 있는데, 찾고자 하는 원소의 시작 인덱스와 끝 인덱스만 알면 그 차로 몇 개가 있는지 알 수 있는 원리이다
- mid를 시작인덱스라고 두고 a[mid] >= target일 때는 en을 mid로 변경, 반대의 경우는 st = mid + 1로 변경하여 st = en이 될 때까지 수행한다
  - a[mid] >= target일 때 en을 mid로 변경하는 이유는 mid가 오름차순을 유지하고 target을 삽입 가능한 가장 오른쪽 인덱스일 수도 있기 때문이다
  - a[mid] < target일 때 st로 mid + 1로 변경하는 이유는 mid가 오름차순을 유지하고 target을 삽입가능한 가장 왼쪽 인덱스일 수도 있기 때문이다
  - 오름차순을 유지하면서 삽입 가능한 가장 왼쪽 인덱스에 위치한 원소는 target과 같거나 커야한다 target이 연속되고 있는 구간의 아무데나 삽입해도 순서를 유지할 수 있기때문임
  - st가 target의 연속 구간 중간에 있으면 어쩌냐고 생각할 수 있는데 애초에 그런 상황이 발생하지 않는게 a[mid] < target일 때만 1씩 이동시키기때문에 st가 연속 구간의 중간에 있을 일은 없다
  - 시작 인덱스를 구한 방법과 마찬가지로 끝 인덱스로 구할 수 있음, 이번에는 mid가 끝 인덱스로 두고 st = en 전까지 a[mid] <= target일 때는 st = mid + 1로 두고, 반대의 경우는 en = mid로 두면서 st와 en을 갱신해주면된다 마찬가지로 en이 연속 구간 중간에 올 일은 발생하지 않는다

### 2. 풀이

- 위에서 설명한 방식 곧이 곧대로 시작 인덱스를 구하는 함수와 마지막 인덱스를 구하는 함수를 각각 구현한 다음 그 차이를 계산해주면 된다
- STL에도 lower_bound(target이 등장하는 최초 위치), upper_bound(target이 등장하는 마지막 위치)라는 함수가 있어서 이것들을 활용해도 된다
  - 이것들의 원리가 이분탐색이라는 것만 알고있자
- 빈도수 배열로 풀리기는 한데, only 이분 탐색으로만 빈도수를 구해야하는 상황은 메모리 제한이 넉넉치 못한 문제일 때임

## [18870 - 좌표 압축](https://www.acmicpc.net/problem/18870)

### 1. 해결 핵심 아이디어

- 이 문제는 어떤 원소보다 작은 원소의 갯수를 알아내는 문제임
- 출력을 위해 원래 순서를 기억할 필요가 있음
- 10816번 숫자 카드 2에서 사용했던 아이디어를 활용할 수 있는데, 어떤 원소 target보다 작은 원소의 수는 배열의 크기에서 최초 등장 위치로 알 수 있다 만약 최초 등장 위치가 4였으면 target보다 작은 원소의 수는 3개이다

### 2. 풀이

- 배열의 중복 원소를 제거한 다음 이분 탐색 코드에서 mid를 반환하게 하는 방법도 있음

## [2295 - 세 수의 합](https://www.acmicpc.net/problem/2295)

### 1. 해결 핵심 아이디어

- 이 문제를 가장 간단하게 해결할 수 있는 솔루션은 4중 반복문으로 세 수를 선택하고, 그 합이 배열 내에 있는지 탐색하는 방법이다
  - 이 방법은 N의 상한이 1,000이므로 시간 제한을 통과하지 못한다
- 시간 제한을 통과하려면 적어도 O($N^{2}logN$)의 시간복잡도를 갖는 알고리즘을 설계해야한다
- 내가 생각했던 방법은 반복문을 최소 2번만 허용하니까 두 수의 합을 미리 구해놓고, 원소 u[i] - u[j]를 했을 때 이 합 배열 내에 그 결과가 있으면 되는 거니까 최대 O($N^{2}logN$)의 시간복잡도를 갖기때문에 통과 가능한 것이었다
- 이 문제와 같이 세 쌍 이상의 조합을 묶고 어느 한 값을 이분탐색으로 찾아 시간복잡도를 낮추는 아이디어는 이분탐색 유형의 핵심 아이디어이다, 뭔가 묶어서 있는지 검사하는 문제 유형의 경우 이분탐색을 고려해볼 수 있다

### 2. 풀이

- 같은 원소가 여러번 뽑힐 수 있음에 유의하자
- 정렬이 된 상태이므로 i는 n-1부터 시작하여 줄이고, j는 0부터 시작하게 하여 더 빨리 찾을 수 있도록 하는 소소한 최적화도 적용했음

## [1654 - 랜선 자르기](https://www.acmicpc.net/problem/1654)

### 1. 해결 핵심 아이디어

- 이 문제를 관찰하다보면 다음과 같은 통찰을 얻을 수 있음
  - 랜선의 길이와 개수는 반비례 관계임(개수가 많아질수록 분할이 많아지기에 길이가 짧아짐)
  - 탐색 범위가 굉장히 크다 N의 상한은 백만이고, 랜선의 길이는 $2^{31} - 1$ 가 상한이다
  - 랜선의 길이가 x이 되도록 분할했을 때 N개 이상을 만들 수 있는가 결정하는 문제로 환원가능하다
- 만약 n개 미만의 랜선을 만들 수 있다면, en을 mid-1로 갱신하고, n개 이상을 만들 수 있다면, 정답 후보이지만 더 긴 것이 존재하나 살펴봐야하기에 st를 mid로 갱신한다

### 2. 풀이

- 주의할 것이 있는데 기존의 이분탐색처럼 mid를 st + en / 2로 두면 무한루프에 빠질 수 있는데, 이유는 st가 en-1이 됬을 때 갱신이 더 이상 안 되기 때문인데, 이를 회피하기 위해 mid를 st + en + 1 / 2로 두어 탈출이 가능하게 만들어준다

## [10815 - 숫자 카드](https://www.acmicpc.net/problem/10815)

### 1. 해결 핵심 아이디어

- 배열 내의 원소의 존재를 확인하는 문제
- 이분탐색으로 찾아주자

### 2. 풀이

- 간단해서 스킵

## [1822 - 차집합](https://www.acmicpc.net/problem/1822)

### 1. 해결 핵심 아이디어

- a의 원소가 b에도 있난 존재를 탐색하는 문제
- 이분탐색으로 간단히 해결할 수 있음

### 2. 풀이

- 간단해서 스킵

## [16401 - 과자 나눠주기](https://www.acmicpc.net/problem/16401)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [2805 - 나무 자르기](https://www.acmicpc.net/problem/2805)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [18869 - 멀티버스 Ⅱ](https://www.acmicpc.net/problem/18869)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [2467 - 용액](https://www.acmicpc.net/problem/2467)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [3151 - 합이 0](https://www.acmicpc.net/problem/3151)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [14921 - 용액 합성하기](https://www.acmicpc.net/problem/14921)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [1253 - 좋다](https://www.acmicpc.net/problem/1253)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [2143 - 두 배열의 합](https://www.acmicpc.net/problem/2143)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [2473 - 세 용액](https://www.acmicpc.net/problem/2473)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [2110 - 공유기 설치](https://www.acmicpc.net/problem/2110)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [7453 - 합이 0인 네 정수](https://www.acmicpc.net/problem/7453)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [12015 - 가장 긴 증가하는 부분 수열 2](https://www.acmicpc.net/problem/12015)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [2512 - 예산](https://www.acmicpc.net/problem/2512)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [1477 - 휴게소 세우기](https://www.acmicpc.net/problem/1477)

### 1. 해결 핵심 아이디어

### 2. 풀이
