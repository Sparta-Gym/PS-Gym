# 0x0B 재귀

<!--ts-->

- [0x0B 재귀](#0x0b-재귀)
  - [0x00 알고리즘 설명](#0x00-알고리즘-설명)
  - [0x01 연습 문제 1 - 거듭제곱](#0x01-연습-문제-1---거듭제곱)
  - [0x02 연습 문제 2 - 하노이 탑](#0x02-연습-문제-2---하노이-탑)
  - [0x03 연습 문제 3 - Z](#0x03-연습-문제-3---z)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 6월 28일 화요일 12시 57분 17초 KST -->

<!--te-->

## 0x00 알고리즘 설명

- 하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘
- 귀납적인 방식으로 문제를 해결할 때 사용(vs 절차 지향)

  - 재귀 함수에 대한 절차 지향적 사고 - n의 증감에 따라 base condition에서 종료되는 시점까지 함수의 호출 순서를 쭉 따라가보는 것
  - 재귀 함수에 대한 귀납적 사고 - 수학적 귀납법으로 증명하는 것과 같음
    - 1일 때 참임을 보인다.
    - k가 어떤 결과를 낸다고 가정했을 때, k+1이 어떤 결과를 낸다는 것을 보이면 된다.
  - 예시

    ```cpp
    void print_recursive(int n){
     if(n == 0) return;
     cout << n << '\n';
     print_recursive(n-1);
    }
    ```

  - 절차지향적 사고(과정을 따라가보는 사고 흐름) 1. n=3인 경우, 3이 출력된다. 2. print_recursive(2)가 호출된다. 3. 2가 출력된다. 4. print_recursive(1)가 호출된다. 5. 1이 출력된다. 6. print_recursive(0)가 호출된다. 7. base condition을 만나 함수 호출이 종료된다.

  - 귀납적 사고 1. print_recursive(1)이 1을 출력한다. 2. print_recursive(k)가 k, k-1, k-2, ..., 1을 출력한다고 가정하면, print_recursive(k+1)은 k+1, k, k-1, k-2, ..., 1을 출력함을 보인다. print_recursive(k+1)이 호출되는 상황을 본다. print_recursive(k+1)가 호출되면, k+1이 출력된 이후, print_recursive(k)가 호출되고 print_recursive(k)는 k, k-1, k-2, ..., 1까지 차례대로 출력한다. 가정이 참이므로, print_recursive(n)은 n, n-1, ..., 1까지 차례대로 출력함을 알 수 있다.

  - 재귀함수가 왜 올바른 결과를 내는지 귀납적 사고로 이해하는 연습을 하자 왜냐하면 절차지향적으로 재귀함수를 따라가다보면, 어려운 문제의 경우 복잡해지는 경우가 다수 생기기 때문에, 귀납적 사고로 이것으로 풀어도 되겠다와 k번째의 경우의 수에서 문제를 올바르게 풀고있는지 보고 증명함을 통해서 확인하면 효율적으로 문제를 해결할 수 있다
  - 재귀 함수의 조건
    - 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함(base condition) 모든 입력은 base condition으로 수렴해야 함
  - 재귀에 대한 정보
    - 함수의 인자로 어떤 것을 받고 어디까지 계산한 후 자기 자신에게 넘겨줄지 명확하게 정해야 함
    - 모든 재귀 함수는 반복문만으로 동일한 동작을 하는 함수를 만들 수 있음
    - 재귀는 반복문으로 구현했을 때에 비해 코드가 간결하지만 메모리/시간에서 손해를 봄(함수 호출 오버헤드)
      - 어떨 때 재귀를 사용하면 유리하고 어떨 때 반복문 사용이 유리한지 경험적으로 파악할 수 있어야함
    - 한 함수가 자기 자신을 여러 번 호출하게 되면 비효율적일 수 있음
      - 피보나치가 예시인데, 이미 계산한 것을 또 계산하는 일이 빈번하여 시간 복잡도가 말도 안되게 커진다.
    - 재귀 함수가 자기 자신을 부를 때 스택 영역 계속 누적됨, 지역 변수도 마찬가지로 스택 영역에 누적됨, 일부 컴파일 환경에서는 메모리 제한과 별개로 스택 영역의 크기가 작게 잡혀있는 경우가 있어 런타임 에러가 발생할 수 있다.
  - 재귀는 스택과 연결지어 생각하면 쉽게 이해할 수 있음(주관적 생각)
    - 프로세스가 실행될 때 함수 호출이 스택 영역에 쌓이는 이유가 무엇일까? func(func(func())) 같은 호출형태를 볼 때 가장 안의 함수가 먼저 실행되고 껍질을 까면서 호출되는데, 이것은 만난 순서의 역순이다, 즉 LIFO임
    - 재귀함수를 뜯어보면 스택에 쌓기 전 작업 + 스택에 쌓는 작업(다음 스텝의 함수 호출) + 스택에 쌓은 후 작업으로 볼 수 있음

## 0x01 연습 문제 1629 - 곱셉

- $a^b\ mod\ n$ 을 구하는 문제로 이런 문제에서 주의할 점은 각 타입의 허용 숫자 범위인데 int의 경우 $2^{31} - 1$까지 이고, long long의 경우 $2^{63} - 1$이다.
- 특히 큰 숫자의 곱셈의 경우 나머지 연산과 자주 묶어서 출제되는데, 이 때 알아두면 좋은 수학적 지식들이 있다.
  - (A _B) mod C = (A mod C_ B mod C) mod C
  - $a^{2n} = a^n * a^n$

## 0x02 연습 문제 11729 - 하노이 탑

![hanoi.gif](https://user-images.githubusercontent.com/48282185/160282171-6ac2b913-7026-4478-a511-fc7852e2a1af.gif)

- 중간에서 n-1개의 탑이 완성돼있어야 함
- 맨 밑의 n번 원판부터 어떻게 기둥 3으로 옮길지 부터 생각해보자
  - 1 ~ n-1번 원판이 기둥 2에 있어야 n번 원판이 기둥 1에서 3으로 옮겨질 수 있다.
  - 1 ~ n-1번 원판을 기둥 1에서 2로 옮긴다.
  - n번 원판을 기둥 1에서 3으로 옮긴다.
  - 그 후 기둥 2에 있던 1 ~ n-1번을 차례대로 기둥 3으로 옮긴다.
  - n-1개의 원판을 옮길 수 있다면 n개의 원판도 옮길 수 있다. ⇒ 재귀
  - 원판을 옮기는 총 회수는 k개의 원판을 옮기는 수가 a라 하면, 출발 ⇒ 중간 a + 마지막 원판 옮김 1 + 중간 ⇒ 끝 a 해서 총 2\*a + 1이 필요하다. 일반항으로 나타내면, $2^n -1$ 이다.
  - 참고로 $2^n$의 경우 비트연산자를 이용하여 1 << n으로 구할 수 있다.
- 귀납적 사고
  - 원판이 1개일 때 원판을 옮길 수 있다.
  - 원판이 k개일 때 옮길 수 있다면, 원판이 k+1개일 때도 옮길 수 있다.
- 구현
  1. 함수의 정의 - 역할과 인자를 정한다.
     1. void func(int n) ⇒ 원판 n개를 기둥 1에서 3으로 옮기는 함수, 이 함수의 형태로는 func(n-1)을 활용할 수가 없는데, n-1일 때도 1에서 3으로 옮기는 경우의 수만 나오기 때문이다. 문제를 해결하려면, func(n-1)은 기둥 1에서 2로 옮겨져야 한다.
     2. void func(int start, int end, int n) ⇒ 시작점과 도착점을 주어주면 시작과 끝점을 활용할 수 있기에 함수를 이러한 형태를 띄어야 맞다.
  2. base condition
     1. n이 1일 때 start와 end출력
  3. 재귀식
     1. n-1개의 원판을 기둥 start에서 기둥 6-start-end로 옮긴다.(6은 기둥의 번호의 총합, 즉 시작점과 도착점을 제외한 나머지 기둥의 번호) ⇒ func(start, 6-start-end, n-1)
     2. n번 원판을 기둥 start에서 기둥 end로 옮긴다. cout << start << ‘ ‘ << end
     3. n-1개의 원판을 기둥 6-start-end에서 end로 옮긴다. ⇒ func(6-start-end, end, n-1)

## 0x03 연습 문제 1074 - Z

- 4등분을 하고 나서 2, 3, 4 사각형의 방문순서는 직접 계산할 필요 없이 1의 계산 결과를 가지고 구할 수 있다.
- 1의 결과를 이용하기 위해 2, 3, 4의 좌표를 1로 평행이동 시킨다
- 재귀 구현

  1. 함수 정의(인자와 기능)
  2. base condition 설정
  3. 재귀 식 수립

  ```cpp
  int z_traversal(int r, int c, int n) {
    if (n == 0) return 0;
    int half = 1 << (n - 1);
    int width = half * half;
    // 1, 2, 3, 4는 4등분 후의 사각형 중 방문 순서를 나타냄
    // 2, 3, 4의 경우, 1의 계산 값으로 방문 순서를 알 수 있음
    // 따라서 2, 3, 4의 경우 1을 이용해야하기 때문에 각 좌표에서 1로 좌표를 각
    // 재귀호출의 r과 c의 값이 된다.
    if (r < half && c < half) return z_traversal(r, c, n - 1);  // 1
    if (r < half && c >= half)
      return width + z_traversal(r, c - half, n - 1);  // 2
    if (r >= half && c < half)
      return 2 * width + z_traversal(r - half, c, n - 1);       // 3
    return 3 * width + z_traversal(r - half, c - half, n - 1);  // 4
  }
  ```

  ![z](https://user-images.githubusercontent.com/48282185/160282214-6044a020-5190-4dbf-8f57-bd8f9db49348.png)

> 바킹독님 유튜브 강의를 참고하여 제작하였습니다.
>
> [BaaarkingDog](https://www.youtube.com/c/BaaarkingDog)
>
> [[실전 알고리즘] 0x0B강 - 재귀](https://blog.encrypted.gg/943)
