# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/1629" rel="nofollow">1629 - 곱셈</a>](#1629---곱셈)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 풀이](#2-풀이)
  - [<a href="https://www.acmicpc.net/problem/11729" rel="nofollow">11729 - 하노이 탑 이동 순서</a>](#11729---하노이-탑-이동-순서)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 풀이](#2-풀이-1)
  - [<a href="https://www.acmicpc.net/problem/1074" rel="nofollow">1074 - Z</a>](#1074---z)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 풀이](#2-풀이-2)
  - [<a href="https://www.acmicpc.net/problem/17478" rel="nofollow">17478 - 재귀함수가 뭔가요?</a>](#17478---재귀함수가-뭔가요)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 풀이](#2-풀이-3)
  - [<a href="https://www.acmicpc.net/problem/1780" rel="nofollow">1780 - 종이의 개수</a>](#1780---종이의-개수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 풀이](#2-풀이-4)
  - [<a href="https://www.acmicpc.net/problem/2630" rel="nofollow">2630 - 색종이 만들기</a>](#2630---색종이-만들기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 풀이](#2-풀이-5)
  - [<a href="https://www.acmicpc.net/problem/1992" rel="nofollow">1992 - 쿼드트리</a>](#1992---쿼드트리)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 풀이](#2-풀이-6)
  - [<a href="https://www.acmicpc.net/problem/2447" rel="nofollow">2447 - 별 찍기 - 10</a>](#2447---별-찍기---10)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 풀이](#2-풀이-7)
  - [<a href="https://www.acmicpc.net/problem/2448" rel="nofollow">2448 - 별 찍기 - 11</a>](#2448---별-찍기---11)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
    - [2. 풀이](#2-풀이-8)
  - [<a href="https://www.acmicpc.net/problem/14956" rel="nofollow">14956 - Philosopher’s Walk</a>](#14956---philosophers-walk)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-9)
    - [2. 풀이](#2-풀이-9)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 9월  6일 화요일 17시 16분 56초 KST -->

<!--te-->

## [1629 - 곱셈](https://www.acmicpc.net/problem/1629)

### 1. 해결 핵심 아이디어

- $A^B$ % C 을 구하는 문제인데, 시간 제한이 0.5초이고, 입력 값의 범위를 보면, A와 B가 모두 int형의 최대값이다, C의 최대값또한 int형의 최대값인데, 나누면 이 값보다 작은 값이 나오기 때문, 다만 곱하기가 나머지연산보다는 우선순위가 높으므로 오버플로를 고려해야함
- 간단하게 A를 B번 곱하는 반복문을 생각해볼 수 있지만 시간 제한과 B의 최대값을 따져봤을 때 무식한 반복은 정답이 아니고 최대 소요 시간이 O(logN) 또는 O(1)이어야 함을 알 수 있다
- 이 문제를 풀기 위한 사전 수학 지식
  1. $a^n$ \* $a^n$ = $a^2n$
  2. ab mod c = ((a mod c) \* (b mod c)) mod c
- 지수법칙을 가지고 O(logN)에 거듭제곱을 구할 수 있는 아이디어를 떠올릴 수 있다
- 모듈로 연산 법칙을 가지고 $A^B$ 를 구해놓고 C로 나눈 나머지를 구하는 것이 아니라 계산 과정에서 나머지를 이용해서 거듭제곱을 구해도 결과는 같으므로 이 사실을 바탕으로 오버플로를 걱정할 필요가 없어졌다
- 이 문제는 단순 반복으로 풀어도되고, 반복에 스택을 이용해도되고, 재귀로 풀어도되고 정답은 없지만, 재귀를 이해하는 차원에서 재귀로 풂
- 그럼 이 문제가 반복 or 재귀라는 깨달음을 어떻게 얻었는지 되돌아보자 => $A^B$ 를 나눠서 생각해야한다
- $A^{B/2}$ 를 나눠보면 일단 B가 홀수이거나 짝수인 두 가지 경우로 나눠지고, 이에 따라서 스텝을 쪼개는 방법도 차이가 생긴다
- B가 짝수일 경우에는 $A^{B}$ = $A^{B/2}$ \* $A^{B/2}$ = $A^{B/4}$ \* $A^{B/4}$ \* $A^{B/4}$ \* $A^{B/4}$ = ... 로 생각해본다
- B가 홀수일 경우에는 B를 2n + 1로 치환하여 생각해보면, $A^{2n + 1}$ = $A^{2n}$ \* $A$ = ...(짝수일 때의 과정과 동일하므로 중간 생략)
- 반복되는 작업을 정의해보면 지수를 2로 나누고 서로 곱한다 => 함수의 내용
- 지수를 2로 나누다가 1이 되면, A % C를 리턴해주면 된다 => base condition

### 2. 풀이

- 다 풀고 정답코드를 보니 소소한 최적화를 적용해볼 수 있었다

  ```cpp
  long long power_of_n(long long base, long long power, long long r) {
    if (power == 1) return base % r;
    long long acc = power_of_n(base, power / 2, r);
    acc = acc * acc % r;
    // 짝수 제곱 처리
    if (power % 2 == 0) return acc;
    // 홀수 제곱 처리
    return (acc * (base % r)) % r;
  }
  ```

  - 홀수 제곱처리 부분에서 (acc \* base) % r을 리턴함으로서 연산회수를 줄일 수 있는데 미미한 최적화에 불과하다
  - acc \* (base % r) % r과 acc \* base % r의 결과는 똑같은데, 10으로 나눈 나머지에서 끝자리만 생각하는 비유를 들었는데 비슷하게 생각해서 3 \* 1616을 계산한 후 10으로 나눈 나머지를 구하는거랑 3 \* 6을 계산한 후 10으로 나눈 나머지를 구하는거랑 똑같다는 관점에서 생각해보면 이해할 수 있다

## [11729 - 하노이 탑 이동 순서](https://www.acmicpc.net/problem/11729)

### 1. 해결 핵심 아이디어

- 재귀를 대표하는 문제로 탑이 어떻게 옮겨지는지 이해하는게 핵심이다
- n개의 원판이 있을 때 어떻게 옮겨지는지 살펴보자
  - 제일 밑에 있는 원판이 어떻게 기둥 3으로 옮겨지는지를 살펴봐야한다, 왜냐하면 이 원판 밑으로는 어떤 원판도 올 수 없기 때문임
  - 1 ~ n-1번 원판이 기둥 2에 있어야 n번 원판이 기둥 1에서 3으로 옮겨질 수 있다.
  - 1 ~ n-1번 원판을 기둥 1에서 2로 옮긴다.
  - n번 원판을 기둥 1에서 3으로 옮긴다.
  - 그 후 기둥 2에 있던 1 ~ n-1번을 차례대로 기둥 3으로 옮긴다.
  - 이렇게 차례대로 기둥3에 n번 원판 -> n-1번 원판 -> n-2번 원판 -> ... 쌓는 과정을 반복하면 해결할 수 있음
- 높이에 상관없이 반복되는 작업
  - 중간 기둥에 높이 n-1인 탑이 쌓인다
  - n번 원판이 시작 기둥에서 마지막 기둥으로 옮겨진다
  - 중간 기둥에 있던 높이 n-1인 탑이 마지막 기둥으로 이동한다
- 중간 기둥에 높이 n-1인 탑이 쌓이는 과정과 중간 기둥이 있던 높이 n-1인 탑이 마지막 기둥으로 옮겨지는 과정은 높이가 몇인지에 따라 차이가 생기게 되며, 높이에 상관없이 반복되는 과정이라고 보기 보다는 반복되면서 수반되는 중간 과정이라고 생각해야한다
- 높이가 1이되었을 때, 현재 시작 기둥과 마지막 기둥을 출력해주고 리턴 => base condition
- 원판이 n개인 문제와 n-1개인 문제 사이에는 중간 탑에 n-1개 쌓기, n번 원판 마지막 기둥으로 옮기기, 중간 탑에있는 n-1개 마지막 기둥으로 옮기기가 있다

### 2. 풀이

- 역할과 인자를 정해야하는데 원판을 A에서 B로 옮기는 작업(원판), 원판을 옮기는데는 필요한 A와 B가 필요하다(인자)
- 하노이 탑의 옮긴 횟수는 $2^n$ - 1이다
  - 원판 n개를 옮기는 횟수를 T(n)이라 할 때, T(n+1) = 2T(n) + 1로 정의할 수 있다
  - 중간 기둥으로 n개 옮기는거 1번, n번 원판 1번, 중간기둥에서 마지막 기둥으로 옮기는 것 1번
  - 방정식을 풀면 일반항이 나옴

## [1074 - Z](https://www.acmicpc.net/problem/1074)

### 1. 해결 핵심 아이디어

- 2 X 2에서 (1, 1), (1, 2), (2, 1), (2, 2) 순으로 방문하는데, 이를 4 X 4로 확장해보면, 2사분면은 1사분면의 방문순서 + 4, 3사분면은 1사분면의 방문순서 + 8, 4사분면은 1사분면의 방문순서 + 12가 된다, 8 X 8까지 확장해서 4등분 후 가장 왼쪽 위 칸의 방문순서가 어떻게 되는지 보면 규칙이 나온다
- 1사분면의 방문순서를 o라 하면, 2사분면은 o + 1 \* $2^{2N-2}$, 3사분면은 o + 2 \* $2^{2N-2}$, 4사분면은 o + 3 \* $2^{2N-2}$ 가 됨을 알 수 있음 => (r, c)에 도달하기 위해 등분한 사각형 $2^{N-1}$ X $2^{N-1}$ 을 몇 번 지나왔는가? 와 등분한 사각형 각각은 이전 스텝에서 구해진 값을 이용할 수 있음
- 더이상 등분이 불가능한 n=0일 때를 base condition으로 두고, (r, c)가 어느 사분면에 위치하느냐에 따라 1사분면으로 평행이동시키면서 step by step으로 사분면에 맞는 방문순서를 계산해주면 된다

### 2. 풀이

- 함수의 인자는 (r, c)좌표와 n을, 기능은 등분과 평행이동이다
- base condition은 n = 0일 때, 0을 리턴
- 재귀 식 수립은 사분면에 맞게 구현하면 됨

## [17478 - 재귀함수가 뭔가요?](https://www.acmicpc.net/problem/17478)

### 1. 해결 핵심 아이디어

- 호출 전에 반복되는 내용, 호출이 반복되는 내용 그리고, 호출 후에 반복되는 내용을 나눠서 출력해주면 됨

### 2. 풀이

- 함수의 인자는 n만 있으면 됨, 기능은 출력
- base condition은 n이 0일 때 "재귀함수는 자기 자신을 호출하는 함수라네"를 출력
- 재귀 식이랄 건 딱히 없음

## [1780 - 종이의 개수](https://www.acmicpc.net/problem/1780)

### 1. 해결 핵심 아이디어

- 이 문제는 굉장히 단순한데, 다른 재귀와 큰 차이가 있음
- 차이라고 하면 이 때까지 푼 재귀문제는 모든 경우의 수가 base condition으로 수렴했다면, n의 크기에 관계 없이 분할한 종이가 모두 같은 숫자로 되어있으면 카운트 후 리턴한다는 점이다
- 1과 -1의 개수가 같은 경우가 있을 수 있어서 분할한 정사각형이 종이라고 판단하는 로직은 모든 원소를 더하는 것 대신, 원소를 일일이 보는 방법 또는 중복을 허용하지 않는 곳에 담아서 크기가 1인지 보면되는데, 후자의 경우 메모리를 더쓰고 복사하는 오버헤드를 생각해보면 오버 구현임
- 잘리는 정사각형의 크기가 같기 때문에 같은 크기의 작은 문제들로 분해될 때 써먹을 수 있는 알고리즘인 분할 정복 문제임을 알 수 있음

### 2. 풀이

- 분할할 수 있는 제일 작은 단위는 1 X 1임
- n을 3으로 나누면서 종이를 9 분할해주고, 분할된 9개의 정사각형 각각의 시작점이 종이가 될 수 있는지 판단하는 함수의 인자로 넘어가게 구현했음

## [2630 - 색종이 만들기](https://www.acmicpc.net/problem/2630)

### 1. 해결 핵심 아이디어

- 1780 - 종이의 개수 문제와 동일

### 2. 풀이

- 분할할 수 있는 제일 작은 단위는 1 X 1임
- n을 2로 나누면서 종이를 4 분할해주고, 분할된 4개의 정사각형 각각의 시작점이 색종이가 될 수 있는지 판단하는 함수의 인자로 넘어가게 구현했음

## [1992 - 쿼드트리](https://www.acmicpc.net/problem/1992)

### 1. 해결 핵심 아이디어

- 1780 - 종이의 개수 문제와 동일
- 각 재귀의 결과를 괄호로 감싸줘야하므로, 재귀 호출 전에 "("를 붙이고 시작하여 사분할에 각각 재귀호출을 하고, 호출이 끝나면 ")"를 붙여준다
- 압축문자열의 순서는 1, 2, 3, 4분면 순으로 이뤄져야하는데, 반복문에서 어차피 저 순서대로 재귀호출하기 때문에 지켜지는 순서임

### 2. 풀이

- 분할할 수 있는 제일 작은 단위는 1 X 1임
- n을 2로 나누면서 영상을 4 분할해주고, 분할된 4개의 영상 각각의 시작점이 압축이 가능한지 판단하는 함수의 인자로 넘어가게 구현했음

## [2447 - 별 찍기 - 10](https://www.acmicpc.net/problem/2447)

### 1. 해결 핵심 아이디어

- fractal을 그리는 문제 유형의 경우 시작점을 기준으로 같은 모양이 반복되기 때문에 n에 따라 시작점이 어떻게 되는지 살펴봐야한다
- n의 크기를 줄이면서 base condition에 도달하면 `*`을 그려주면된다
- base condition은 n이 1일 때이고, 이 프랙탈은 중앙을 제외하고 테두리를 `*`로 둘러싸고 있는 형태이므로, 모든 테두리에 대해 별을 찍어주면된다
- n = 27일 때는 n = 9 크기의 도형이 테두리가 되고, n = 9일 때는 n = 3 크기의 도형이 테두리가 되고, n = 3일 때는 n = 1크기의 도형이 테두리가 되는 전 단계에서 그려놓은 도형이 테두리가 됨

### 2. 풀이

- 1780 - 종이의 문제와 같이 이전 단계 도형의 시작점에 대해 전부 재귀호출을 불러주고, 가운데는 비었으므로 r = c일 때는 호출을 하지 않는다

## [2448 - 별 찍기 - 11](https://www.acmicpc.net/problem/2448)

### 1. 해결 핵심 아이디어

- fractal을 그리는 문제 유형인데, 재귀를 어떻게 호출하는지에 대한 아이디어는 2447 - 별찍기 - 10과 같음
- 이 문제의 경우 base condition을 n = 3일 때로 잡았는데, n=1로 할 수도 있지만 그러면 엄청 복잡해진다
- n과 n-1사이의 관계를 살펴보면, n-1크기의 도형 3개가 크기 n인 도형을 이룬다
- n이 작은 케이스 3, 6에서 시작점이 어떻게 확장되는지 보면 됨

### 2. 풀이

- 제일 작은 케이스인 n=3에 대해 그려주고, 각 스텝마다 시작점이 3개가 추가되므로 이에 대해 각각 호출해주면 된다
- 가운데 도형 기준으로 왼쪽 밑 도형과 오른쪽 밑 도형의 시작점이 어떻게 되는지 관계를 구해서 재귀식 구할 수 있었음

## [14956 - Philosopher’s Walk](https://www.acmicpc.net/problem/14956)

### 1. 해결 핵심 아이디어

- 사분면을 아래와 같이 지정(base condition)

```plane text
  2 3
  1 4
```

- 규칙을 살펴보자

  - 2사분면과 3사분면은 전 단계의 도형에서 평행이동
  - 1사분면은 전 단계 도형에서 시계방향 90도 회전(y = x 직선 대칭),
  - 4사분면은 전 단계 도형에서 반시계방향 90도 회전(y = -x + pn 직선에 의한 대칭이동 후 x축으로 pn 만큼 평행이동)

- 1074 - z 처럼 전단계에서 정한 방문순서를 활용해야하는 아이디어를 응용하여 전 단계에서 계산한 방문순서를 이용하자는 생각을 했음
- 크기가 2인 도형만날때 까지 단계를 계속 줄이는데, 현재 걸어온 걸음(walk)을 전 단계에 맞게 줄여준다 전 단계에서의 방문 순서 = 현재 방문 순서 - 지나온 크기이기에 1인 사각형 개수 전 단계에서 계산한 걸음를 평행이동과 대칭으로 현재 단계의 걸음 수로 변환 n-1 문제 4개가 합쳐서 n인 문제를 이루는데, n-1문제가 어느사분면에 위치하느냐에 따라 대칭 혹은 이동이 필요하다

### 2. 풀이

- 배열을 회전시키거나 이동시키는 것은 좌표평면에서 이뤄지는 점이나 도형의 이동으로 생각하면 구현이 쉬워진다
- 현재 단계에서 전 단계를 호출할 때 문제 사이즈가 어떻게 바뀌는지, 호출과 함께 이뤄져야되는 작업은 없는지 확인해보자
- 쪽팔리게 재귀 마스터한 줄 알고 싱글벙글 덤볐다가 호되게 혼났다 골빠게지는 줄 알았다, 항상 겸손하자
