# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/1463" rel="nofollow">1463 - 1로 만들기</a>](#1463---1로-만들기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 풀이](#2-풀이)
  - [<a href="https://www.acmicpc.net/problem/9095" rel="nofollow">9095 - 1, 2, 3 더하기</a>](#9095---1-2-3-더하기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 풀이](#2-풀이-1)
  - [<a href="https://www.acmicpc.net/problem/2579" rel="nofollow">2579 - 계단 오르기</a>](#2579---계단-오르기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 풀이](#2-풀이-2)
  - [<a href="https://www.acmicpc.net/problem/1149" rel="nofollow">1149 - RGB거리</a>](#1149---rgb거리)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 풀이](#2-풀이-3)
  - [<a href="https://www.acmicpc.net/problem/11726" rel="nofollow">11726 - 2×n 타일링</a>](#11726---2n-타일링)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 풀이](#2-풀이-4)
  - [<a href="https://www.acmicpc.net/problem/11659" rel="nofollow">11659 - 구간 합 구하기 4</a>](#11659---구간-합-구하기-4)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 풀이](#2-풀이-5)
  - [<a href="https://www.acmicpc.net/problem/12852" rel="nofollow">12852 - 1로 만들기 2</a>](#12852---1로-만들기-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 풀이](#2-풀이-6)
  - [<a href="https://www.acmicpc.net/problem/1003" rel="nofollow">1003 - 피보나치 함수</a>](#1003---피보나치-함수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 풀이](#2-풀이-7)
  - [<a href="https://www.acmicpc.net/problem/1932" rel="nofollow">1932 - 정수 삼각형</a>](#1932---정수-삼각형)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
    - [2. 풀이](#2-풀이-8)
  - [<a href="https://www.acmicpc.net/problem/11727" rel="nofollow">11727 - 2×n 타일링 2</a>](#11727---2n-타일링-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-9)
    - [2. 풀이](#2-풀이-9)
  - [<a href="https://www.acmicpc.net/problem/2193" rel="nofollow">2193 - 이친수</a>](#2193---이친수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-10)
    - [2. 풀이](#2-풀이-10)
  - [<a href="https://www.acmicpc.net/problem/1912" rel="nofollow">1912 - 연속합</a>](#1912---연속합)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-11)
    - [2. 풀이](#2-풀이-11)
  - [<a href="https://www.acmicpc.net/problem/11055" rel="nofollow">11055 - 가장 큰 증가 부분 수열</a>](#11055---가장-큰-증가-부분-수열)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-12)
    - [2. 풀이](#2-풀이-12)
  - [<a href="https://www.acmicpc.net/problem/11053" rel="nofollow">11053 - 가장 긴 증가하는 부분 수열</a>](#11053---가장-긴-증가하는-부분-수열)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-13)
    - [2. 풀이](#2-풀이-13)
  - [<a href="https://www.acmicpc.net/problem/9461" rel="nofollow">9461 - 파도반 수열</a>](#9461---파도반-수열)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-14)
    - [2. 풀이](#2-풀이-14)
  - [<a href="https://www.acmicpc.net/problem/14501" rel="nofollow">14501 - 퇴사</a>](#14501---퇴사)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-15)
    - [2. 풀이](#2-풀이-15)
  - [<a href="https://www.acmicpc.net/problem/15486" rel="nofollow">15486 - 퇴사 2</a>](#15486---퇴사-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-16)
    - [2. 풀이](#2-풀이-16)
  - [<a href="https://www.acmicpc.net/problem/10844" rel="nofollow">10844 - 쉬운 계단 수</a>](#10844---쉬운-계단-수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-17)
    - [2. 풀이](#2-풀이-17)
  - [<a href="https://www.acmicpc.net/problem/2748" rel="nofollow">2748 - 피보나치 수 2</a>](#2748---피보나치-수-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-18)
    - [2. 풀이](#2-풀이-18)
  - [<a href="https://www.acmicpc.net/problem/2240" rel="nofollow">2240 - 자두나무</a>](#2240---자두나무)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-19)
    - [2. 풀이](#2-풀이-19)
  - [<a href="https://www.acmicpc.net/problem/14002" rel="nofollow">14002 - 가장 긴 증가하는 부분 수열 4</a>](#14002---가장-긴-증가하는-부분-수열-4)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-20)
    - [2. 풀이](#2-풀이-20)
  - [<a href="https://www.acmicpc.net/problem/2156" rel="nofollow">2156 - 포도주 시식</a>](#2156---포도주-시식)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-21)
    - [2. 풀이](#2-풀이-21)
  - [<a href="https://www.acmicpc.net/problem/15988" rel="nofollow">15988 - 1, 2, 3 더하기 3</a>](#15988---1-2-3-더하기-3)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-22)
    - [2. 풀이](#2-풀이-22)
  - [<a href="https://www.acmicpc.net/problem/2302" rel="nofollow">2302 - 극장 좌석</a>](#2302---극장-좌석)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-23)
    - [2. 풀이](#2-풀이-23)
  - [<a href="https://www.acmicpc.net/problem/11052" rel="nofollow">11052 - 카드 구매하기</a>](#11052---카드-구매하기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-24)
    - [2. 풀이](#2-풀이-24)
  - [<a href="https://www.acmicpc.net/problem/9465" rel="nofollow">9465 - 스티커</a>](#9465---스티커)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-25)
    - [2. 풀이](#2-풀이-25)
  - [<a href="https://www.acmicpc.net/problem/11057" rel="nofollow">11057 - 오르막 수</a>](#11057---오르막-수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-26)
    - [2. 풀이](#2-풀이-26)
  - [<a href="https://www.acmicpc.net/problem/2293" rel="nofollow">2293 - 동전 1</a>](#2293---동전-1)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-27)
    - [2. 풀이](#2-풀이-27)
  - [<a href="https://www.acmicpc.net/problem/1904" rel="nofollow">1904 - 01타일</a>](#1904---01타일)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-28)
    - [2. 풀이](#2-풀이-28)
  - [<a href="https://www.acmicpc.net/problem/1788" rel="nofollow">1788 - 피보나치 수의 확장</a>](#1788---피보나치-수의-확장)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-29)
    - [2. 풀이](#2-풀이-29)
  - [<a href="https://www.acmicpc.net/problem/4883" rel="nofollow">4883 - 삼각 그래프</a>](#4883---삼각-그래프)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-30)
    - [2. 풀이](#2-풀이-30)
  - [<a href="https://www.acmicpc.net/problem/9251" rel="nofollow">9251 - LCS</a>](#9251---lcs)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-31)
    - [2. 풀이](#2-풀이-31)
  - [<a href="https://www.acmicpc.net/problem/1699" rel="nofollow">1699 - 제곱수의 합</a>](#1699---제곱수의-합)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-32)
    - [2. 풀이](#2-풀이-32)
  - [<a href="https://www.acmicpc.net/problem/9084" rel="nofollow">9084 - 동전</a>](#9084---동전)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-33)
    - [2. 풀이](#2-풀이-33)
  - [<a href="https://www.acmicpc.net/problem/1915" rel="nofollow">1915 - 가장 큰 정사각형</a>](#1915---가장-큰-정사각형)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-34)
    - [2. 풀이](#2-풀이-34)
  - [<a href="https://www.acmicpc.net/problem/10942" rel="nofollow">10942 - 팰린드롬?</a>](#10942---팰린드롬)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-35)
    - [2. 풀이](#2-풀이-35)
  - [<a href="https://www.acmicpc.net/problem/9655" rel="nofollow">9655 - 돌 게임</a>](#9655---돌-게임)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-36)
    - [2. 풀이](#2-풀이-36)
  - [<a href="https://www.acmicpc.net/problem/2011" rel="nofollow">2011 - 암호코드</a>](#2011---암호코드)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-37)
    - [2. 풀이](#2-풀이-37)
  - [<a href="https://www.acmicpc.net/problem/2294" rel="nofollow">2294 - 동전 2</a>](#2294---동전-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-38)
    - [2. 풀이](#2-풀이-38)
  - [<a href="https://www.acmicpc.net/problem/2133" rel="nofollow">2133 - 타일 채우기</a>](#2133---타일-채우기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-39)
    - [2. 풀이](#2-풀이-39)
  - [<a href="https://www.acmicpc.net/problem/1520" rel="nofollow">1520 - 내리막 길</a>](#1520---내리막-길)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-40)
    - [2. 풀이](#2-풀이-40)
  - [<a href="https://www.acmicpc.net/problem/9657" rel="nofollow">9657 - 돌 게임 3</a>](#9657---돌-게임-3)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-41)
    - [2. 풀이](#2-풀이-41)
  - [<a href="https://www.acmicpc.net/problem/11660" rel="nofollow">11660 - 구간 합 구하기 5</a>](#11660---구간-합-구하기-5)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-42)
    - [2. 풀이](#2-풀이-42)
  - [<a href="https://www.acmicpc.net/problem/2482" rel="nofollow">2482 - 색상환</a>](#2482---색상환)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-43)
    - [2. 풀이](#2-풀이-43)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 9월 20일 화요일 21시 56분 47초 KST -->

<!--te-->

## [1463 - 1로 만들기](https://www.acmicpc.net/problem/1463)

### 1. 해결 핵심 아이디어

- 다이나믹 프로그래밍을 이용하여 문제를 푸는 과정은 1. 테이블 정의하기, 2. 점화식 세우기, 3. 초기값 정하기 세 단계로 나눠진다
- 1. 테이블 정의하기
  - 작은 문제를 저장해놓는 공간
  - 무엇을 저장해놔야 다음 문제를 풀 수 있을지 생각해보자
  - 이 문제에서는 어떤 수 x를 3으로 나누거나 2로 나누거나 1을 빼서 1을 만들어야한다
  - 즉 i번째에서 1을 만드는 방법을 알기위해서는 1. i/2번째에서 1을 만드는 방법, 2. i/3번째에서 1을 만드는 방법, 3. i-1번째에서 1을 만드는 방법 세 가지를 알고 있어야한다
  - dp[i] = i를 1로 만들기 위한 최소 연산 수
- 2. 점화식 세우기
  - 앞서 봤듯이 i가 1이 되기위해서는 3가지 방법을 이용할 수 있는데, 이 중 최소만을 골라서 1까지 가면된다
  - 최소인지 어떻게 확신하느냐고 물으면, i/2, i/3, i-1에서 이미 최소의 연산 수를 구해놨기 때문에 귀류법으로 증명해보면 최소임을 알 수 있음
- 3. 초기값 정하기
  - dp[1] = 0
  - 1은 1로 만들기위해서 아무것도 안해도되기 때문임
  - 더이상 쪼갤 수 없는 제일 작은 사이즈가 1이므로 1이외에 다른 초기값은 없지만 관념적으로 dp[0] = 0으로 설정하는게 좋다 2 / 3 같은게 있기 때문임

### 2. 풀이

- 구한 점화식을 n까지 점화시킨 후 dp[n]을 출력해주면 정답

## [9095 - 1, 2, 3 더하기](https://www.acmicpc.net/problem/9095)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - 1+1+1+`1` , 3+`1`, 2+1+`1`, 1+2+`1` ⇒ 3을 1, 2, 3으로 만드는 방법 + `1`, dp[3]
  - 1+1+`2`, 2+`2` ⇒ 2를 1, 2, 3으로 만드는 방법 + `2`, dp[2]
  - 1+`3` ⇒ 1을 1, 2, 3으로 만드는 방법 + `3`, dp[1]
  - dp[i] = 1, 2, 3의 합으로 i를 구하는 경우의 수
- 2. 점화식 새우기
  - dp[i] = dp[i-3] + dp[i-2] + dp[i-1]
  - i를 만들기 위한 작은 문제들로 i-3, i-2 그리고 i-1을 알고 있어야함
- 3. 초기값 정하기
  - dp[1] = 1, dp[2] = 2, dp[3] = 4
  - 1을 만드는 경우는 1 하나
  - 2를 만드는 경우는 1+1, 2 둘
  - 3을 만드는 경우는 1+1+1, 2+1, 1+2, 3 넷

### 2. 풀이

- 4부터 점화시켜서 dp[n] 출력해주면 정답

## [2579 - 계단 오르기](https://www.acmicpc.net/problem/2579)

### 1. 해결 핵심 아이디어

- 처음에는 세 계단을 연속으로 밟을 수 없다는 조건때문에 max(dp[i-3] + dp[i-1], dp[i-2]) + score[i]으로 점화식을 세웠는데, 여기는 치명적인 문제가 있다 dp[i-1]에는 dp[i-2]를 밟고오는 경우의 수도 포함되어있기 때문이다
- 앞서 봤던 두 문제와는 달리 작은문제를 조합할 때 제약이 걸리는 유형이다, 세 가지관점으로 문제를 해결해볼 수 있음
- 1. 테이블에 변수를 추가하여 제약을 구현하는 방법
  - 제약을 구현하기위해서 조합할 때 이 제약을 지킬 수 있게 연속되는지 아닌지 알 필요가 있고, 이를 점화식에 포함시켜줘야한다
  - 연속으로 몇 번이나 밟았는지 기록함으로서 i번에 오를 수 있는 경우의 수를 필터링시킬 수 있음
  - 1. 테이블 정의하기
    - dp[i][j] = i번 계단을 밟으면 연속해서 j개가 되는 경우에서 점수의 최댓값
  - 2. 점화식 세우기
    - dp[i][1] = max(dp[i-2][1], dp[i-1][2]) + score[i]
    - dp[i][2] = dp[i-1] + score[i]
    - i-2번 계단을 밟고 2칸을 올라서 i번 밟으면 연속이 초기화됨
    - i-1번 계단을 밟고 1칸을 올라서 i번 밟으면 연속해서 2번을 밟고있음
  - 3. 초기값 정하기
    - 한 번에 1칸이나 2칸 뛸 수 있으므로 dp[1][j]와 dp[2][j]가 정의돼야함(j = 1, 2)
    - dp[1][1] = score[1], dp[1][2] = 0(두 칸 뛰어서 1번을 밟는 경우는 없음)
    - dp[2][1] = score[2], dp[2][2] = score[1] + score[2]
- 2. 테이블에 변수를 추가하지않고 구하고자 하는 값의 대우를 구해본다
  - 구하고자 하는 값: i번 계단을 밟았을 때 점수의 최대값
  - 값의 대우: i번 계단을 밟을 계단으로 선택했을때 밟지 않은 계단들의 점수의 최소합
  - 1. 테이블 정의하기
    - dp[i] = i번 계단을 밟지 않을 계단으로 선택했을 때 밟지 않은 계단들의 점수의 최소합
  - 2. 점화식 세우기
    - 밟지 않을 계단들로 선택
    - i를 건너뛰려면 i-1이나 i-2를 반드시 밟아야함
    - i-2가 밟히지 않은 경우는 i-3과 i-1이 밟힌 경우이므로 dp[i-2] + score[i]가 i-2와 i번째 계단을 밟지 않을 계단으로 선택했을 때의 최소합이고, i-3 계단이 밟지 않을 계단으로 선택된 경우는 i-2와 i-1이 밟힌 경우이므로 dp[i-3] + score[i]가 된다. → min(dp[i-3], dp[i-2]) + score[i]
  - 3. 초기값 정하기
    - dp[1] = score[1]
    - dp[2] = score[2]
    - dp[3] = score[3]
  - n번 계단은 반드시 밟아야하므로 n-1이나 n-2를 밟지 않은 경우를 구하면 n은 반드시 밟아야하므로 정답은 점수의 총합 - min(dp[n-1], dp[n-2])가 된다
  - 총합이 제약때문에 밟지 않은 계단의 최소 + 밟은 계단의 최대로 이루어지기 때문에 가능한 방법이다
- 3. 테이블에 변수를 추가히자않고 구하고자 하는 값을 구해보자
  - 처음에 한 실수와 비슷한 방법
  - 1. 테이블 정의하기
    - dp[i] = i번째 계단까지 올라섰을 때 점수 합의 최댓값, 단 i번째 계단을 반드시 밟아야 함
  - 2. 점화식 찾기
    - i번 계단을 반드시 밟기 위해서는 i-2에서 2칸을 오르거나 i-1에서 1칸을 오르는 경우의 수가 있는데, i-1에서 주의해야할 점이 i-3과 i-2, i-1을 밟은 경우 i를 밟으면 조건에 어긋나므로 i-1의 경우의 수에서 이 경우를 제외해줘야하는데, 연속성 조건을 확인할 수 없어서 불가능하기 때문에 i-3에서 i-1로 온 경우만 고려해줘야한다 i-2에서 i-1에서 온 경우를 고려 안 하는 이유는 i-2에 i-3에서 온 경우가 포함되기 때문임
    - dp[i] = max(dp[i-2], score[i-1] + dp[i-3]) + score[i]
  - 3. 초기값 정하기
    - dp[1] = score[1]
    - dp[2] = score[1] + score[2], 2칸 뛰어서 온거보다 1을 거쳐온 값이 무조건 큼
    - dp[3] = score[3] + max(score[2], score[1])

### 2. 풀이

- 대우 조건으로 최대를 구하는 문제에서 최소를 구할 수도 그 반대도 가능한 아이디어 배워간다
- 이런 작은 문제를 선택하는 과정에서 연속하면 안되는 유형은 어떻게 연속이 제한되는지 그 구간내에서 가능한 경우는 어떻게 구성해야하는지 생각해보자

## [1149 - RGB거리](https://www.acmicpc.net/problem/1149)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - 2579 - 계단오르기문제와 같이 인접에 관한 제약이 있음
  - dp[i][j] = i번 집을 j색으로 칠하는 최소 비용
- 2. 점화식 세우기
  - dp[i][1] = min(dp[i-1][2], dp[i-1][3]) + cost[i][1]
  - dp[i][2] = min(dp[i-1][1], dp[i-1][3]) + cost[i][2]
  - dp[i][3] = min(dp[i-1][1], dp[i-1][2]) + cost[i][3]
  - 인접끼리 색이 다름을 보장할 수 있음
- 3. 초기값 정하기
  - dp[1][1] = color[1][1]
  - dp[1][2] = color[1][2]
  - dp[1][3] = color[1][3]

### 2. 풀이

- 2부터 점화시켜서 dp[n][1], dp[n][2], dp[n][3] 셋 중 최소값이 정답

## [11726 - 2×n 타일링](https://www.acmicpc.net/problem/11726)

### 1. 해결 핵심 아이디어

- 이런 문제 유형은 직사각형을 1 x 1크기의 정사각형으로 나눠서 이것을 채울 수 있는 사각형의 경우의 수를 본다
- 1. 테이블 정의하기
  - dp[i] = 2 x i 크기의 직사각형을 채우는 방법의 수
- 2. 점화식 세우기
  - 제일 왼쪽 위 1 x 1을 덮을 수 있는 제일 작은 단위는 2x1 또는 1x2 두 가지 뿐이다
  - 2 x (i-1) 직사각형과 2 x 1 직사각형을 합치면 2 x i가 될 수 있음
  - 2 x (i-2) 직사각형과 1 x 2 직사각형을 합치면 2 x i가 될 수 있음
  - dp[i] = dp[i-1] + dp[i-2]
- 3. 초기값 정하기
  - dp[1] = 1
  - dp[2] = 2

### 2. 풀이

- 방법의 수를 10,007로 나눈 나머지를 출력해야하는데 `(a + b) mod n = a mod n + b mod n`라는 수학적 사실에 의해 매번 방법의 수를 더해서 10,007로 나눈 나머지를 계속 더해도 방법의 수를 다구하고나서 10,007로 나눈 나머지와 동일하다
- 직관적으로 위의 방법이 이해가 안간다면 전개해보면 이해가 갈 것

## [11659 - 구간 합 구하기 4](https://www.acmicpc.net/problem/11659)

### 1. 해결 핵심 아이디어

- 이 문제는 간단함
- 1. 테이블 정의하기
  - dp[i] = [1, i] 구간의 합
- 2. 점화식 세우기
  - dp[i] = dp[i-1] + seq[i]
- 3. 초기값 정하기
  - dp[1] = seq[1]

### 2. 풀이

- 2부터 점화시켜서 dp[n] 출력

## [12852 - 1로 만들기 2](https://www.acmicpc.net/problem/12852)

### 1. 해결 핵심 아이디어

- i번 문제를 풀 때 쓰인 작은 문제들을 기록했다가 역추적해주는 경로 복원 유형
- 1463 - 1로 만들기문제와 점화식과 테이블은 동일
- i번 문제를 풀 때 쓰인 작은 문제의 인덱스를 pre[i]로 기록해놓는다

### 2. 풀이

- pre테이블을 n부터 시작해서 역추적 하면서 출력한다

## [1003 - 피보나치 함수](https://www.acmicpc.net/problem/1003)

### 1. 해결 핵심 아이디어

- fibo(i)를 피보나치 수열의 i번 항이라고 정의
- fibo(n) = fibo(n-1) + fibo(n-2)이므로 n-1이 출력하는 0과 1의 개수, n-2가 출력하는 0과 1의 개수가 합쳐지면 fibo(n)이 출력하는 0과 1의 개수가 나온다
- 1. 테이블 정의하기
  - dp[i][j] = fibo(i)가 j를 출력하는 횟수
- 2. 점화식 세우기
  - dp[i][j] = dp[i-1][j] + dp[i-2][j]
- 3. 초기값 정하기
  - dp[0][0] = dp[1][1] = 1
  - dp[0][1] = dp[1][0] = 0

### 2. 풀이

- 2부터 점화시켜서 구해놓고 tc를 입력받고 그 개수만큼 n을 입력 받고 구해놓은 dp[n][0], dp[n][1] 출력해주면 끝

## [1932 - 정수 삼각형](https://www.acmicpc.net/problem/1932)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i][j] = i행 j열에서 합의 최대값
- 2. 점화식 세우기
  - 삼각형의 양변은 각각 좌대각과 우대각이 없기때문에 이 두 케이스를 고려해줘야함
  - j가 0이면 dp[i][j] = dp[i-1][j] + tri[i][j]
  - j가 i이면 dp[i][j] = dp[i-1][j-1] + tri[i][j]
  - 이외에는 좌대각에서 내려온 것과 우대각에서 내려온 것 중 더 큰 것을 더해준다 dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + tri[i][j]
- 3. 초기값 정하기
  - 초기값이 따로 필요없음

### 2. 풀이

- n행의 모든 열을 검사해보고 이 중 제일 큰 수가 답

## [11727 - 2×n 타일링 2](https://www.acmicpc.net/problem/11727)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i] = 2 x i 크기의 직사각형을 채우는 방법의 수
- 2. 점화식 세우기
  - 제일 작은 1 x 1 크기의 사각형을 덮는 방법의 수는 3가지임 1 x 2, 2 x 1, 2 x 2
  - [i-2][2]과 [i-1][1] 크기의 사각형으로 크기 2 x i 사각형을 만들 수 있음
  - [i-2][2]에서 2를 채울\* 수 있는 방법은 두 가지이므로 \*2를 해줘야한다
  - dp[i] = dp[i-1] + 2 \* dp[i-2]
- 3. 초기값 정하기
  - dp[1] = 1
  - dp[2] = 3

### 2. 풀이

- 3부터 점화시켜서 dp[n] 출력해주면 됨

## [2193 - 이친수](https://www.acmicpc.net/problem/2193)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i][j] = 길이 i의 이친수에서 i번째 숫자가 j인 경우의 수
- 2. 점화식 세우기
  - dp[i][0] = dp[i-1][0] + dp[i-1][1]
  - dp[i][1] = dp[i-1][0]
  - 1이 두개 연속하면 안되므로 위와 같이 2개의 점화식이 성립한다
- 3. 초기값 정하기
  - dp[1][0] = 0(0으로 시작하면 안됨)
  - dp[1][1] = 1

### 2. 풀이

- 2부터 점화시켜서 n까지 구하고, dp[n][0] + dp[n][1]을 출력해주면 정답
- 이 문제에서 범위에대한 주의사항이 딱히 없어서 int형으로 했는데 자꾸 틀려서 질문 검색봤더니 타입이 문제임을 인지했고, 보니까 n이 90일 때 200경이상이다
- [방법의 수를 가늠하는 가이드를 질문 탭에서 찾았다](https://www.acmicpc.net/board/view/91686)

## [1912 - 연속합](https://www.acmicpc.net/problem/1912)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i] = 수열의 i번 원소까지의 최대 연속합
- 2. 점화식 세우기
  - dp[i] = max(dp[i-1] + seq[i], seq[i])
  - 이전의 누적합이 현재 원소와 더했을 때 그 값이 더 작아지면 연속할 필요가 없는 것임
- 3. 초기값 정하기
  - dp[0] = seq[0]

### 2. 풀이

- 1부터 점화시킨 후 n-1까지 구하고, dp배열에서 0 ~ n-1 원소 중 최대값이 정답

## [11055 - 가장 큰 증가 부분 수열](https://www.acmicpc.net/problem/11055)

### 1. 해결 핵심 아이디어

- 처음에는 `1 8 2 3 9` 같은 케이스를 고려하지 못해서 증가 부분 수열의 연속이 끊길 때는 dp[i] = max(dp[j] + seq[i], dp[i])(j= i-1 ~ 0)로 증가가 유지되고 있으니 제일 처음 작은 수를 발견하면 break하고 연속이 끊기지 않을 때는 dp[i] = dp[i-1] + seq[i]로 처리해줘서 오답이났는데 질문탭을 보고 이 반례를 찾고 논리를 수정했음 잘못된 부분은 인접이 안되도 부분 증가 수열일 수 있는데 그 케이스를 고려못했던 점임
- 1. 테이블 정의하기
  - dp[i] = 수열 i번까지 봤을 때 부분 증가 수열의 최대합
- 2. 점화식 세우기
  - if(seq[i] > seq[j]) dp[i] = max(dp[j] + seq[i], dp[i]), j는 0~i 사이의 정수
- 3. 초기값 정하기
  - dp[i] = seq[i] (i = 1 ~ N)

### 2. 풀이

- dp 테이블 원소 중 가장 큰 값이 정답
- 테스트케이스에 매몰되어 잘못된 논리 짠 점 반성하자

## [11053 - 가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)

### 1. 해결 핵심 아이디어

- 11055 - 가장 큰 증가 부분 수열 문제와 아이디어 거의 동일
- 1. 테이블 정의하기
  - dp[i] = 수열 i번까지 봤을 때 부분 증가 수열의 최대 길이
- 2. 점화식 세우기
  - if(seq[i] > seq[j]) dp[i] = max(dp[j] + 1, dp[i]), j는 0~i 사이의 정수
- 3. 초기값 정하기
  - dp[i] = 1 (i = 0 ~ N-1)

### 2. 풀이

- dp 테이블 원소 중 가장 큰 값이 정답

## [9461 - 파도반 수열](https://www.acmicpc.net/problem/9461)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i] = 나선을 그리면서 생성되는 i번째 정삼각형의 변의 길이
- 2. 점화식 세우기

  - dp[i] = dp[i-1] + dp[i-5] (i >= 6)
  - 나선이 반바퀴 도는데 5개의 변이 필요하고 이 작업이 계속 반복되면서 나선을 만들어감(아래 그림 참고)
  - 반바퀴돌고나서 i번 정삼각형을 만들 때 i-1번 정삼각형의 변의 길이 + i-5번 정삼각형의 변의 길이가 된다는 사실을 캐치했음

    ```text

        4
        __
    3 /    \ 5
    2 \___  \
        1

    ```

- 3. 초기값 정하기
  - dp[1] = dp[2] = dp[3] = 1
  - dp[4] = dp[5] = 2

### 2. 풀이

- 6부터 점화시켜서 dp[n] 출력해주면 끝
- 정답코드보니 점화식을 dp[i] = dp[i-2] + dp[i-3] 으로 세우던데 수열을 계속 나열해보면서 규칙을 찾은 것 같다, 그림만으로는 유추하기 어려울 것 같음

## [14501 - 퇴사](https://www.acmicpc.net/problem/14501)

### 1. 해결 핵심 아이디어

- 모든 작은 문제들이 합쳐져서 N보다 작거야 같아야한다는 생각에 N부터 1까지 거꾸로 접근해야한다는 점을 생각해보긴 했으나 거기서 더 발전을 못시켜서 정답을 봤음
- 1. 테이블 설계하기
  - dp[i] = i일의 상담을 선택했을 때 얻을 수 있는 최대 수익
- 2. 점화식 정의하기
  - if(i + t[i] <= n+1) dp[i] = max(dp[i + t[i]] + p[i], dp[i+1]), else dp[i] = dp[i+1]
  - 문제의 테스트케이스를 대입해보면 dp[5] = max(dp[7]+p[5], dp[6])가 나오는데 역인덱스로 나가는게 익숙하지 않아서 어떻게 할 지 몰랐던 것 같음 보통은 bottom-up으로 키우면서 하는데 약간 고정관념인듯
- 3. 초기값 정하기
  - dp 테이블 다 0으로 채워서 i가 선택되지 않은 경우를 고려해주자

### 2. 풀이

- dp 테이블의 최대값이 정답

## [15486 - 퇴사 2](https://www.acmicpc.net/problem/15486)

### 1. 해결 핵심 아이디어

- 14501 - 퇴사 문제는 N이 최대 20이라 완전탐색으로도 해결가능했지만 이 문제는 N이 최대 150만이라 시간제한을 통과하기 위해서는 dp로 풀어야함
- 14501 - 퇴사 문제를 풀 수 있는 다른 점화식도 있음
- 앞서 풀어봤던 문제들은 i에서 dp[i]의 값을 결정하는 것으로 끝나지만, 이 아이디어의 경우는 i를 결정할 뿐 아니라 dp[i + t[i]]도 갱신해줌
- 1. 테이블 정의하기
  - dp[i] = i-1일까지 상담을 했을 때 최대 수익
- 2. 점화식 세우기
  - dp[i] = max(dp[i], dp[i-1])으로 i일까지 상담했을 때 최대 수익 결정
  - if(i + t[i] <= n+1) dp[i+t[i]] = max(dp[i+t[i]], dp[i] + p[i])로 dp[i+t[i]]를 갱신한다
- 3. 초기값 정하기
  - dp 테이블 다 0으로 채워서 i가 선택되지 않은 경우를 고려해주자

### 2. 풀이

- 최대값은 dp[n] = n-1일까지 상담했을 때 최대 수익, dp[n+1] = n일까지 상담 했을 때 최대 수익 중 큰 값

## [10844 - 쉬운 계단 수](https://www.acmicpc.net/problem/10844)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i][j] = 길이 i를 갖는 계단수 중 끝자리가 j인 경우의 수
- 2. 점화식 정의하기
  - dp[i][0] = dp[i-1][j+1] (시작이 0인 계단수는 없음)
  - dp[i][9] = dp[i-1][j-1] (9와 인접인 수는 8밖에 없음)
  - dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1] (어떤 수 j의 인접은 j-1과 j+1)
- 3. 초기값 정하기
  - dp[1][j] = 1 (j = 0 ~ 9)

### 2. 풀이

- dp[n][j]를 모두 더해주면 정답

## [2748 - 피보나치 수 2](https://www.acmicpc.net/problem/2748)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i] = 피보나치 수열의 i항
- 2. 점화식 정의하기
  - dp[i] = dp[i-1] + dp[i-2] (i >= 2)
- 3. 초기값 정의하기
  - dp[0] = 0
  - dp[1] = 1

### 2. 풀이

- n이 90일 때 피보니치 수는 100경을 넘어가므로 long long형을 써야한다는 점 이외에는 주의할 점 없음

## [2240 - 자두나무](https://www.acmicpc.net/problem/2240)

### 1. 해결 핵심 아이디어

- 테이블 정의까지는 세울 수 있었는데, 점화식을 찾아보려했는데 실패했음, 움직임이 제한되야한다고 생각해서 너무 복잡하게 생각했다
- 나무 번호까지 변수로해서 3차원 테이블 저장해놓는 방법도 있음
- 1. 테이블 정의
  - dp[i][j] = i초에 j번 움직여서 얻을 수 있는 자두의 개수
- 2. 점화식 찾기
  - dp[i][0] = (s[i] == 1), 1번 나무에서 움직이지 않는 경우
  - dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + (1 + j % 2 == s[i]), 반대 나무로 움직여서 넘어오거나 그대로 있을 때 중 최대 값 + 현재 자두가 떨어지는지 아닌지
- 3. 초기값 정하기
  - 딱히 정해줄게 없음 0으로 초기화만 잘해주면 됨

### 2. 풀이

- 문제를 너무 어렵게 생각하는 경향이 있음, 단순하게 생각해서 테이블 정의대로 문제가 어떻게 풀려나가는지 살펴보도록 하자
- 조건이 너무 복잡하다싶으면 내가 어렵게 생각하고 있는게 아닌지 생각해 볼 필요가 있겠다

## [14002 - 가장 긴 증가하는 부분 수열 4](https://www.acmicpc.net/problem/14002)

### 1. 해결 핵심 아이디어

- 11053 - 가장 긴 증가하는 부분 수열과 아이디어는 동일
- 역추적이 필요한 문제라 테이블 갱신될 때마다 pre테이블도 같이 갱신

### 2. 풀이

- pre테이블은 역추적인데 출력은 순서대로 해줘야돼서 나는 stack을 이용했는데, 정답코드를 보니 deque을 이용해도 됨을 알게됬음

## [2156 - 포도주 시식](https://www.acmicpc.net/problem/2156)

### 1. 해결 핵심 아이디어

- 문제 설명때문에 그런가 2579 - 쉬운 계단수문제와 동일하게 했다가 틀려서 반례를 살펴보다가 연속 두 칸 건너뛰는게 가능해서(1에서 2와 3 거르고 4로 점프가능) 가능해서 점화식을 약간 수정했음
- 1. 테이블 정의하기
  - dp[i][j] = j번 연속해서 i번 포도주를 마실 때 현재까지 마신 포도주의 총합
- 2. 점화식 세우기
  - dp[i][1] = max({dp[i-3][1], dp[i-3][2], dp[i-2][1], dp[i-2][2]}) + wine[i]
  - dp[i][2] = dp[i-1][1] + wine[i]
- 3. 초기값 정하기
  - dp[1][1] = wine[1]
  - dp[1][2] = 0
  - dp[2][1] = wine[2]
  - dp[2][2] = wine[1] + wine[2]

### 2. 풀이

- [참고한 반례를 모아놓은 블로그](https://raejoonee.tistory.com/15)
- 정답코드보니 1차원으로 `d[i] = max({d[i-1], d[i-2] + a[i], d[i-3] + a[i-1] + a[i]})` 점화식을 세워서 푸는 방법도 있었음, 이 방법이 어떻게 연속 세 개가 안됨을 보장할 수 있을지 생각해봤는데, 1. i번 포도주 시식 안하는 경우, 2. i-2번까지 총합 마시고 i번 포도주 마시는 경우, 3.i-3번 까지의 최대량 마시고 i번과 i-1번 포도주 마시는 경우로 연속해서 3개를 마시는 경우가 없는데, 이해하기 좀 어려운 듯

## [15988 - 1, 2, 3 더하기 3](https://www.acmicpc.net/problem/15988)

### 1. 해결 핵심 아이디어

- 9095 - 1, 2, 3 더하기 문제와 같은데 입력 크기의 최대가 백만으로 변했음

### 2. 풀이

- 경우의 수 문제는 매우 커질 수 있으니 맘 편하게 long long형 쓰기

## [2302 - 극장 좌석](https://www.acmicpc.net/problem/2302)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [11052 - 카드 구매하기](https://www.acmicpc.net/problem/11052)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [9465 - 스티커](https://www.acmicpc.net/problem/9465)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [11057 - 오르막 수](https://www.acmicpc.net/problem/11057)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [2293 - 동전 1](https://www.acmicpc.net/problem/2293)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [1904 - 01타일](https://www.acmicpc.net/problem/1904)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [1788 - 피보나치 수의 확장](https://www.acmicpc.net/problem/1788)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [4883 - 삼각 그래프](https://www.acmicpc.net/problem/4883)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [9251 - LCS](https://www.acmicpc.net/problem/9251)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [1699 - 제곱수의 합](https://www.acmicpc.net/problem/1699)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [9084 - 동전](https://www.acmicpc.net/problem/9084)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [1915 - 가장 큰 정사각형](https://www.acmicpc.net/problem/1915)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [10942 - 팰린드롬?](https://www.acmicpc.net/problem/10942)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [9655 - 돌 게임](https://www.acmicpc.net/problem/9655)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [2011 - 암호코드](https://www.acmicpc.net/problem/2011)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [2294 - 동전 2](https://www.acmicpc.net/problem/2294)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [2133 - 타일 채우기](https://www.acmicpc.net/problem/2133)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [1520 - 내리막 길](https://www.acmicpc.net/problem/1520)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [9657 - 돌 게임 3](https://www.acmicpc.net/problem/9657)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [11660 - 구간 합 구하기 5](https://www.acmicpc.net/problem/11660)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [2482 - 색상환](https://www.acmicpc.net/problem/2482)

### 1. 해결 핵심 아이디어

### 2. 풀이
