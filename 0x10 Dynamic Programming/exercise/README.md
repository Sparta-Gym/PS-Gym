# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/1463" rel="nofollow">1463 - 1로 만들기</a>](#1463---1로-만들기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 풀이](#2-풀이)
  - [<a href="https://www.acmicpc.net/problem/9095" rel="nofollow">9095 - 1, 2, 3 더하기</a>](#9095---1-2-3-더하기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 풀이](#2-풀이-1)
  - [<a href="https://www.acmicpc.net/problem/2579" rel="nofollow">2579 - 계단 오르기</a>](#2579---계단-오르기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 풀이](#2-풀이-2)
  - [<a href="https://www.acmicpc.net/problem/1149" rel="nofollow">1149 - RGB거리</a>](#1149---rgb거리)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 풀이](#2-풀이-3)
  - [<a href="https://www.acmicpc.net/problem/11726" rel="nofollow">11726 - 2×n 타일링</a>](#11726---2n-타일링)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 풀이](#2-풀이-4)
  - [<a href="https://www.acmicpc.net/problem/11659" rel="nofollow">11659 - 구간 합 구하기 4</a>](#11659---구간-합-구하기-4)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 풀이](#2-풀이-5)
  - [<a href="https://www.acmicpc.net/problem/12852" rel="nofollow">12852 - 1로 만들기 2</a>](#12852---1로-만들기-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 풀이](#2-풀이-6)
  - [<a href="https://www.acmicpc.net/problem/1003" rel="nofollow">1003 - 피보나치 함수</a>](#1003---피보나치-함수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 풀이](#2-풀이-7)
  - [<a href="https://www.acmicpc.net/problem/1932" rel="nofollow">1932 - 정수 삼각형</a>](#1932---정수-삼각형)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
    - [2. 풀이](#2-풀이-8)
  - [<a href="https://www.acmicpc.net/problem/11727" rel="nofollow">11727 - 2×n 타일링 2</a>](#11727---2n-타일링-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-9)
    - [2. 풀이](#2-풀이-9)
  - [<a href="https://www.acmicpc.net/problem/2193" rel="nofollow">2193 - 이친수</a>](#2193---이친수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-10)
    - [2. 풀이](#2-풀이-10)
  - [<a href="https://www.acmicpc.net/problem/1912" rel="nofollow">1912 - 연속합</a>](#1912---연속합)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-11)
    - [2. 풀이](#2-풀이-11)
  - [<a href="https://www.acmicpc.net/problem/11055" rel="nofollow">11055 - 가장 큰 증가 부분 수열</a>](#11055---가장-큰-증가-부분-수열)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-12)
    - [2. 풀이](#2-풀이-12)
  - [<a href="https://www.acmicpc.net/problem/11053" rel="nofollow">11053 - 가장 긴 증가하는 부분 수열</a>](#11053---가장-긴-증가하는-부분-수열)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-13)
    - [2. 풀이](#2-풀이-13)
  - [<a href="https://www.acmicpc.net/problem/9461" rel="nofollow">9461 - 파도반 수열</a>](#9461---파도반-수열)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-14)
    - [2. 풀이](#2-풀이-14)
  - [<a href="https://www.acmicpc.net/problem/14501" rel="nofollow">14501 - 퇴사</a>](#14501---퇴사)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-15)
    - [2. 풀이](#2-풀이-15)
  - [<a href="https://www.acmicpc.net/problem/15486" rel="nofollow">15486 - 퇴사 2</a>](#15486---퇴사-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-16)
    - [2. 풀이](#2-풀이-16)
  - [<a href="https://www.acmicpc.net/problem/10844" rel="nofollow">10844 - 쉬운 계단 수</a>](#10844---쉬운-계단-수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-17)
    - [2. 풀이](#2-풀이-17)
  - [<a href="https://www.acmicpc.net/problem/2748" rel="nofollow">2748 - 피보나치 수 2</a>](#2748---피보나치-수-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-18)
    - [2. 풀이](#2-풀이-18)
  - [<a href="https://www.acmicpc.net/problem/2240" rel="nofollow">2240 - 자두나무</a>](#2240---자두나무)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-19)
    - [2. 풀이](#2-풀이-19)
  - [<a href="https://www.acmicpc.net/problem/14002" rel="nofollow">14002 - 가장 긴 증가하는 부분 수열 4</a>](#14002---가장-긴-증가하는-부분-수열-4)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-20)
    - [2. 풀이](#2-풀이-20)
  - [<a href="https://www.acmicpc.net/problem/2156" rel="nofollow">2156 - 포도주 시식</a>](#2156---포도주-시식)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-21)
    - [2. 풀이](#2-풀이-21)
  - [<a href="https://www.acmicpc.net/problem/15988" rel="nofollow">15988 - 1, 2, 3 더하기 3</a>](#15988---1-2-3-더하기-3)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-22)
    - [2. 풀이](#2-풀이-22)
  - [<a href="https://www.acmicpc.net/problem/2302" rel="nofollow">2302 - 극장 좌석</a>](#2302---극장-좌석)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-23)
    - [2. 풀이](#2-풀이-23)
  - [<a href="https://www.acmicpc.net/problem/11052" rel="nofollow">11052 - 카드 구매하기</a>](#11052---카드-구매하기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-24)
    - [2. 풀이](#2-풀이-24)
  - [<a href="https://www.acmicpc.net/problem/9465" rel="nofollow">9465 - 스티커</a>](#9465---스티커)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-25)
    - [2. 풀이](#2-풀이-25)
  - [<a href="https://www.acmicpc.net/problem/11057" rel="nofollow">11057 - 오르막 수</a>](#11057---오르막-수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-26)
    - [2. 풀이](#2-풀이-26)
  - [<a href="https://www.acmicpc.net/problem/2293" rel="nofollow">2293 - 동전 1</a>](#2293---동전-1)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-27)
    - [2. 풀이](#2-풀이-27)
  - [<a href="https://www.acmicpc.net/problem/1904" rel="nofollow">1904 - 01타일</a>](#1904---01타일)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-28)
    - [2. 풀이](#2-풀이-28)
  - [<a href="https://www.acmicpc.net/problem/1788" rel="nofollow">1788 - 피보나치 수의 확장</a>](#1788---피보나치-수의-확장)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-29)
    - [2. 풀이](#2-풀이-29)
  - [<a href="https://www.acmicpc.net/problem/4883" rel="nofollow">4883 - 삼각 그래프</a>](#4883---삼각-그래프)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-30)
    - [2. 풀이](#2-풀이-30)
  - [<a href="https://www.acmicpc.net/problem/9251" rel="nofollow">9251 - LCS</a>](#9251---lcs)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-31)
    - [2. 풀이](#2-풀이-31)
  - [<a href="https://www.acmicpc.net/problem/1699" rel="nofollow">1699 - 제곱수의 합</a>](#1699---제곱수의-합)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-32)
    - [2. 풀이](#2-풀이-32)
  - [<a href="https://www.acmicpc.net/problem/9084" rel="nofollow">9084 - 동전</a>](#9084---동전)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-33)
    - [2. 풀이](#2-풀이-33)
  - [<a href="https://www.acmicpc.net/problem/1915" rel="nofollow">1915 - 가장 큰 정사각형</a>](#1915---가장-큰-정사각형)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-34)
    - [2. 풀이](#2-풀이-34)
  - [<a href="https://www.acmicpc.net/problem/10942" rel="nofollow">10942 - 팰린드롬?</a>](#10942---팰린드롬)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-35)
    - [2. 풀이](#2-풀이-35)
  - [<a href="https://www.acmicpc.net/problem/9655" rel="nofollow">9655 - 돌 게임</a>](#9655---돌-게임)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-36)
    - [2. 풀이](#2-풀이-36)
  - [<a href="https://www.acmicpc.net/problem/2011" rel="nofollow">2011 - 암호코드</a>](#2011---암호코드)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-37)
    - [2. 풀이](#2-풀이-37)
  - [<a href="https://www.acmicpc.net/problem/2294" rel="nofollow">2294 - 동전 2</a>](#2294---동전-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-38)
    - [2. 풀이](#2-풀이-38)
  - [<a href="https://www.acmicpc.net/problem/2133" rel="nofollow">2133 - 타일 채우기</a>](#2133---타일-채우기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-39)
    - [2. 풀이](#2-풀이-39)
  - [<a href="https://www.acmicpc.net/problem/1520" rel="nofollow">1520 - 내리막 길</a>](#1520---내리막-길)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-40)
    - [2. 풀이](#2-풀이-40)
  - [<a href="https://www.acmicpc.net/problem/9657" rel="nofollow">9657 - 돌 게임 3</a>](#9657---돌-게임-3)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-41)
    - [2. 풀이](#2-풀이-41)
  - [<a href="https://www.acmicpc.net/problem/11660" rel="nofollow">11660 - 구간 합 구하기 5</a>](#11660---구간-합-구하기-5)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-42)
    - [2. 풀이](#2-풀이-42)
  - [<a href="https://www.acmicpc.net/problem/2482" rel="nofollow">2482 - 색상환</a>](#2482---색상환)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-43)
    - [2. 풀이](#2-풀이-43)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 9월 20일 화요일 21시 56분 47초 KST -->

<!--te-->

## [1463 - 1로 만들기](https://www.acmicpc.net/problem/1463)

### 1. 해결 핵심 아이디어

- 다이나믹 프로그래밍을 이용하여 문제를 푸는 과정은 1. 테이블 정의하기, 2. 점화식 세우기, 3. 초기값 정하기 세 단계로 나눠진다
- 1. 테이블 정의하기
  - 작은 문제를 저장해놓는 공간
  - 무엇을 저장해놔야 다음 문제를 풀 수 있을지 생각해보자
  - 이 문제에서는 어떤 수 x를 3으로 나누거나 2로 나누거나 1을 빼서 1을 만들어야한다
  - 즉 i번째에서 1을 만드는 방법을 알기위해서는 1. i/2번째에서 1을 만드는 방법, 2. i/3번째에서 1을 만드는 방법, 3. i-1번째에서 1을 만드는 방법 세 가지를 알고 있어야한다
  - dp[i] = i를 1로 만들기 위한 최소 연산 수
- 2. 점화식 세우기
  - 앞서 봤듯이 i가 1이 되기위해서는 3가지 방법을 이용할 수 있는데, 이 중 최소만을 골라서 1까지 가면된다
  - 최소인지 어떻게 확신하느냐고 물으면, i/2, i/3, i-1에서 이미 최소의 연산 수를 구해놨기 때문에 귀류법으로 증명해보면 최소임을 알 수 있음
- 3. 초기값 정하기
  - dp[1] = 0
  - 1은 1로 만들기위해서 아무것도 안해도되기 때문임
  - 더이상 쪼갤 수 없는 제일 작은 사이즈가 1이므로 1이외에 다른 초기값은 없지만 관념적으로 dp[0] = 0으로 설정하는게 좋다 2 / 3 같은게 있기 때문임

### 2. 풀이

- 구한 점화식을 n까지 점화시킨 후 dp[n]을 출력해주면 정답

## [9095 - 1, 2, 3 더하기](https://www.acmicpc.net/problem/9095)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - 1+1+1+`1` , 3+`1`, 2+1+`1`, 1+2+`1` ⇒ 3을 1, 2, 3으로 만드는 방법 + `1`, dp[3]
  - 1+1+`2`, 2+`2` ⇒ 2를 1, 2, 3으로 만드는 방법 + `2`, dp[2]
  - 1+`3` ⇒ 1을 1, 2, 3으로 만드는 방법 + `3`, dp[1]
  - dp[i] = 1, 2, 3의 합으로 i를 구하는 경우의 수
- 2. 점화식 새우기
  - dp[i] = dp[i-3] + dp[i-2] + dp[i-1]
  - i를 만들기 위한 작은 문제들로 i-3, i-2 그리고 i-1을 알고 있어야함
- 3. 초기값 정하기
  - dp[1] = 1, dp[2] = 2, dp[3] = 4
  - 1을 만드는 경우는 1 하나
  - 2를 만드는 경우는 1+1, 2 둘
  - 3을 만드는 경우는 1+1+1, 2+1, 1+2, 3 넷

### 2. 풀이

- 4부터 점화시켜서 dp[n] 출력해주면 정답

## [2579 - 계단 오르기](https://www.acmicpc.net/problem/2579)

### 1. 해결 핵심 아이디어

- 처음에는 세 계단을 연속으로 밟을 수 없다는 조건때문에 max(dp[i-3] + dp[i-1], dp[i-2]) + score[i]으로 점화식을 세웠는데, 여기는 치명적인 문제가 있다 dp[i-1]에는 dp[i-2]를 밟고오는 경우의 수도 포함되어있기 때문이다
- 앞서 봤던 두 문제와는 달리 작은문제를 조합할 때 제약이 걸리는 유형이다, 세 가지관점으로 문제를 해결해볼 수 있음
- 1. 테이블에 변수를 추가하여 제약을 구현하는 방법
  - 제약을 구현하기위해서 조합할 때 이 제약을 지킬 수 있게 연속되는지 아닌지 알 필요가 있고, 이를 점화식에 포함시켜줘야한다
  - 연속으로 몇 번이나 밟았는지 기록함으로서 i번에 오를 수 있는 경우의 수를 필터링시킬 수 있음
  - 1. 테이블 정의하기
    - dp[i][j] = i번 계단을 밟으면 연속해서 j개가 되는 경우에서 점수의 최댓값
  - 2. 점화식 세우기
    - dp[i][1] = max(dp[i-2][1], dp[i-1][2]) + score[i]
    - dp[i][2] = dp[i-1] + score[i]
    - i-2번 계단을 밟고 2칸을 올라서 i번 밟으면 연속이 초기화됨
    - i-1번 계단을 밟고 1칸을 올라서 i번 밟으면 연속해서 2번을 밟고있음
  - 3. 초기값 정하기
    - 한 번에 1칸이나 2칸 뛸 수 있으므로 dp[1][j]와 dp[2][j]가 정의돼야함(j = 1, 2)
    - dp[1][1] = score[1], dp[1][2] = 0(두 칸 뛰어서 1번을 밟는 경우는 없음)
    - dp[2][1] = score[2], dp[2][2] = score[1] + score[2]
- 2. 테이블에 변수를 추가하지않고 구하고자 하는 값의 대우를 구해본다
  - 구하고자 하는 값: i번 계단을 밟았을 때 점수의 최대값
  - 값의 대우: i번 계단을 밟을 계단으로 선택했을때 밟지 않은 계단들의 점수의 최소합
  - 1. 테이블 정의하기
    - dp[i] = i번 계단을 밟지 않을 계단으로 선택했을 때 밟지 않은 계단들의 점수의 최소합
  - 2. 점화식 세우기
    - 밟지 않을 계단들로 선택
    - i를 건너뛰려면 i-1이나 i-2를 반드시 밟아야함
    - i-2가 밟히지 않은 경우는 i-3과 i-1이 밟힌 경우이므로 dp[i-2] + score[i]가 i-2와 i번째 계단을 밟지 않을 계단으로 선택했을 때의 최소합이고, i-3 계단이 밟지 않을 계단으로 선택된 경우는 i-2와 i-1이 밟힌 경우이므로 dp[i-3] + score[i]가 된다. → min(dp[i-3], dp[i-2]) + score[i]
  - 3. 초기값 정하기
    - dp[1] = score[1]
    - dp[2] = score[2]
    - dp[3] = score[3]
  - n번 계단은 반드시 밟아야하므로 n-1이나 n-2를 밟지 않은 경우를 구하면 n은 반드시 밟아야하므로 정답은 점수의 총합 - min(dp[n-1], dp[n-2])가 된다
  - 총합이 제약때문에 밟지 않은 계단의 최소 + 밟은 계단의 최대로 이루어지기 때문에 가능한 방법이다
- 3. 테이블에 변수를 추가히자않고 구하고자 하는 값을 구해보자
  - 처음에 한 실수와 비슷한 방법
  - 1. 테이블 정의하기
    - dp[i] = i번째 계단까지 올라섰을 때 점수 합의 최댓값, 단 i번째 계단을 반드시 밟아야 함
  - 2. 점화식 찾기
    - i번 계단을 반드시 밟기 위해서는 i-2에서 2칸을 오르거나 i-1에서 1칸을 오르는 경우의 수가 있는데, i-1에서 주의해야할 점이 i-3과 i-2, i-1을 밟은 경우 i를 밟으면 조건에 어긋나므로 i-1의 경우의 수에서 이 경우를 제외해줘야하는데, 연속성 조건을 확인할 수 없어서 불가능하기 때문에 i-3에서 i-1로 온 경우만 고려해줘야한다 i-2에서 i-1에서 온 경우를 고려 안 하는 이유는 i-2에 i-3에서 온 경우가 포함되기 때문임
    - dp[i] = max(dp[i-2], score[i-1] + dp[i-3]) + score[i]
  - 3. 초기값 정하기
    - dp[1] = score[1]
    - dp[2] = score[1] + score[2], 2칸 뛰어서 온거보다 1을 거쳐온 값이 무조건 큼
    - dp[3] = score[3] + max(score[2], score[1])

### 2. 풀이

- 대우 조건으로 최대를 구하는 문제에서 최소를 구할 수도 그 반대도 가능한 아이디어 배워간다
- 이런 작은 문제를 선택하는 과정에서 연속하면 안되는 유형은 어떻게 연속이 제한되는지 그 구간내에서 가능한 경우는 어떻게 구성해야하는지 생각해보자

## [1149 - RGB거리](https://www.acmicpc.net/problem/1149)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - 2579 - 계단오르기문제와 같이 인접에 관한 제약이 있음
  - dp[i][j] = i번 집을 j색으로 칠하는 최소 비용
- 2. 점화식 세우기
  - dp[i][1] = min(dp[i-1][2], dp[i-1][3]) + cost[i][1]
  - dp[i][2] = min(dp[i-1][1], dp[i-1][3]) + cost[i][2]
  - dp[i][3] = min(dp[i-1][1], dp[i-1][2]) + cost[i][3]
  - 인접끼리 색이 다름을 보장할 수 있음
- 3. 초기값 정하기
  - dp[1][1] = color[1][1]
  - dp[1][2] = color[1][2]
  - dp[1][3] = color[1][3]

### 2. 풀이

- 2부터 점화시켜서 dp[n][1], dp[n][2], dp[n][3] 셋 중 최소값이 정답

## [11726 - 2×n 타일링](https://www.acmicpc.net/problem/11726)

### 1. 해결 핵심 아이디어

- 이런 문제 유형은 직사각형을 1 x 1크기의 정사각형으로 나눠서 이것을 채울 수 있는 사각형의 경우의 수를 본다
- 1. 테이블 정의하기
  - dp[i] = 2 x i 크기의 직사각형을 채우는 방법의 수
- 2. 점화식 세우기
  - 제일 왼쪽 위 1 x 1을 덮을 수 있는 제일 작은 단위는 2x1 또는 1x2 두 가지 뿐이다
  - 2 x (i-1) 직사각형과 2 x 1 직사각형을 합치면 2 x i가 될 수 있음
  - 2 x (i-2) 직사각형과 1 x 2 직사각형을 합치면 2 x i가 될 수 있음
  - dp[i] = dp[i-1] + dp[i-2]
- 3. 초기값 정하기
  - dp[1] = 1
  - dp[2] = 2

### 2. 풀이

- 방법의 수를 10,007로 나눈 나머지를 출력해야하는데 `(a + b) mod n = a mod n + b mod n`라는 수학적 사실에 의해 매번 방법의 수를 더해서 10,007로 나눈 나머지를 계속 더해도 방법의 수를 다구하고나서 10,007로 나눈 나머지와 동일하다
- 직관적으로 위의 방법이 이해가 안간다면 전개해보면 이해가 갈 것

## [11659 - 구간 합 구하기 4](https://www.acmicpc.net/problem/11659)

### 1. 해결 핵심 아이디어

- 이 문제는 간단함
- 1. 테이블 정의하기
  - dp[i] = [1, i] 구간의 합
- 2. 점화식 세우기
  - dp[i] = dp[i-1] + seq[i]
- 3. 초기값 정하기
  - dp[1] = seq[1]

### 2. 풀이

- 2부터 점화시켜서 dp[n] 출력

## [12852 - 1로 만들기 2](https://www.acmicpc.net/problem/12852)

### 1. 해결 핵심 아이디어

- i번 문제를 풀 때 쓰인 작은 문제들을 기록했다가 역추적해주는 경로 복원 유형
- 1463 - 1로 만들기문제와 점화식과 테이블은 동일
- i번 문제를 풀 때 쓰인 작은 문제의 인덱스를 pre[i]로 기록해놓는다

### 2. 풀이

- pre테이블을 n부터 시작해서 역추적 하면서 출력한다

## [1003 - 피보나치 함수](https://www.acmicpc.net/problem/1003)

### 1. 해결 핵심 아이디어

- fibo(i)를 피보나치 수열의 i번 항이라고 정의
- fibo(n) = fibo(n-1) + fibo(n-2)이므로 n-1이 출력하는 0과 1의 개수, n-2가 출력하는 0과 1의 개수가 합쳐지면 fibo(n)이 출력하는 0과 1의 개수가 나온다
- 1. 테이블 정의하기
  - dp[i][j] = fibo(i)가 j를 출력하는 횟수
- 2. 점화식 세우기
  - dp[i][j] = dp[i-1][j] + dp[i-2][j]
- 3. 초기값 정하기
  - dp[0][0] = dp[1][1] = 1
  - dp[0][1] = dp[1][0] = 0

### 2. 풀이

- 2부터 점화시켜서 구해놓고 tc를 입력받고 그 개수만큼 n을 입력 받고 구해놓은 dp[n][0], dp[n][1] 출력해주면 끝

## [1932 - 정수 삼각형](https://www.acmicpc.net/problem/1932)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i][j] = i행 j열에서 합의 최대값
- 2. 점화식 세우기
  - 삼각형의 양변은 각각 좌대각과 우대각이 없기때문에 이 두 케이스를 고려해줘야함
  - j가 0이면 dp[i][j] = dp[i-1][j] + tri[i][j]
  - j가 i이면 dp[i][j] = dp[i-1][j-1] + tri[i][j]
  - 이외에는 좌대각에서 내려온 것과 우대각에서 내려온 것 중 더 큰 것을 더해준다 dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + tri[i][j]
- 3. 초기값 정하기
  - 초기값이 따로 필요없음

### 2. 풀이

- n행의 모든 열을 검사해보고 이 중 제일 큰 수가 답

## [11727 - 2×n 타일링 2](https://www.acmicpc.net/problem/11727)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i] = 2 x i 크기의 직사각형을 채우는 방법의 수
- 2. 점화식 세우기
  - 제일 작은 1 x 1 크기의 사각형을 덮는 방법의 수는 3가지임 1 x 2, 2 x 1, 2 x 2
  - [i-2][2]과 [i-1][1] 크기의 사각형으로 크기 2 x i 사각형을 만들 수 있음
  - [i-2][2]에서 2를 채울\* 수 있는 방법은 두 가지이므로 \*2를 해줘야한다
  - dp[i] = dp[i-1] + 2 \* dp[i-2]
- 3. 초기값 정하기
  - dp[1] = 1
  - dp[2] = 3

### 2. 풀이

- 3부터 점화시켜서 dp[n] 출력해주면 됨

## [2193 - 이친수](https://www.acmicpc.net/problem/2193)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i][j] = 길이 i의 이친수에서 i번째 숫자가 j인 경우의 수
- 2. 점화식 세우기
  - dp[i][0] = dp[i-1][0] + dp[i-1][1]
  - dp[i][1] = dp[i-1][0]
  - 1이 두개 연속하면 안되므로 위와 같이 2개의 점화식이 성립한다
- 3. 초기값 정하기
  - dp[1][0] = 0(0으로 시작하면 안됨)
  - dp[1][1] = 1

### 2. 풀이

- 2부터 점화시켜서 n까지 구하고, dp[n][0] + dp[n][1]을 출력해주면 정답
- 이 문제에서 범위에대한 주의사항이 딱히 없어서 int형으로 했는데 자꾸 틀려서 질문 검색봤더니 타입이 문제임을 인지했고, 보니까 n이 90일 때 200경이상이다
- [방법의 수를 가늠하는 가이드를 질문 탭에서 찾았다](https://www.acmicpc.net/board/view/91686)

## [1912 - 연속합](https://www.acmicpc.net/problem/1912)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i] = 수열의 i번 원소까지의 최대 연속합
- 2. 점화식 세우기
  - dp[i] = max(dp[i-1] + seq[i], seq[i])
  - 이전의 누적합이 현재 원소와 더했을 때 그 값이 더 작아지면 연속할 필요가 없는 것임
- 3. 초기값 정하기
  - dp[0] = seq[0]

### 2. 풀이

- 1부터 점화시킨 후 n-1까지 구하고, dp배열에서 0 ~ n-1 원소 중 최대값이 정답

## [11055 - 가장 큰 증가 부분 수열](https://www.acmicpc.net/problem/11055)

### 1. 해결 핵심 아이디어

- 처음에는 `1 8 2 3 9` 같은 케이스를 고려하지 못해서 증가 부분 수열의 연속이 끊길 때는 dp[i] = max(dp[j] + seq[i], dp[i])(j= i-1 ~ 0)로 증가가 유지되고 있으니 제일 처음 작은 수를 발견하면 break하고 연속이 끊기지 않을 때는 dp[i] = dp[i-1] + seq[i]로 처리해줘서 오답이났는데 질문탭을 보고 이 반례를 찾고 논리를 수정했음 잘못된 부분은 인접이 안되도 부분 증가 수열일 수 있는데 그 케이스를 고려못했던 점임
- 1. 테이블 정의하기
  - dp[i] = 수열 i번까지 봤을 때 부분 증가 수열의 최대합
- 2. 점화식 세우기
  - if(seq[i] > seq[j]) dp[i] = max(dp[j] + seq[i], dp[i]), j는 0~i 사이의 정수
- 3. 초기값 정하기
  - dp[i] = seq[i] (i = 1 ~ N)

### 2. 풀이

- dp 테이블 원소 중 가장 큰 값이 정답
- 테스트케이스에 매몰되어 잘못된 논리 짠 점 반성하자

## [11053 - 가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)

### 1. 해결 핵심 아이디어

- 11055 - 가장 큰 증가 부분 수열 문제와 아이디어 거의 동일
- 1. 테이블 정의하기
  - dp[i] = 수열 i번까지 봤을 때 부분 증가 수열의 최대 길이
- 2. 점화식 세우기
  - if(seq[i] > seq[j]) dp[i] = max(dp[j] + 1, dp[i]), j는 0~i 사이의 정수
- 3. 초기값 정하기
  - dp[i] = 1 (i = 0 ~ N-1)

### 2. 풀이

- dp 테이블 원소 중 가장 큰 값이 정답

## [9461 - 파도반 수열](https://www.acmicpc.net/problem/9461)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i] = 나선을 그리면서 생성되는 i번째 정삼각형의 변의 길이
- 2. 점화식 세우기

  - dp[i] = dp[i-1] + dp[i-5] (i >= 6)
  - 나선이 반바퀴 도는데 5개의 변이 필요하고 이 작업이 계속 반복되면서 나선을 만들어감(아래 그림 참고)
  - 반바퀴돌고나서 i번 정삼각형을 만들 때 i-1번 정삼각형의 변의 길이 + i-5번 정삼각형의 변의 길이가 된다는 사실을 캐치했음

    ```text

        4
        __
    3 /    \ 5
    2 \___  \
        1

    ```

- 3. 초기값 정하기
  - dp[1] = dp[2] = dp[3] = 1
  - dp[4] = dp[5] = 2

### 2. 풀이

- 6부터 점화시켜서 dp[n] 출력해주면 끝
- 정답코드보니 점화식을 dp[i] = dp[i-2] + dp[i-3] 으로 세우던데 수열을 계속 나열해보면서 규칙을 찾은 것 같다, 그림만으로는 유추하기 어려울 것 같음

## [14501 - 퇴사](https://www.acmicpc.net/problem/14501)

### 1. 해결 핵심 아이디어

- 모든 작은 문제들이 합쳐져서 N보다 작거야 같아야한다는 생각에 N부터 1까지 거꾸로 접근해야한다는 점을 생각해보긴 했으나 거기서 더 발전을 못시켜서 정답을 봤음
- 1. 테이블 설계하기
  - dp[i] = i일의 상담을 선택했을 때 얻을 수 있는 최대 수익
- 2. 점화식 정의하기
  - if(i + t[i] <= n+1) dp[i] = max(dp[i + t[i]] + p[i], dp[i+1]), else dp[i] = dp[i+1]
  - 문제의 테스트케이스를 대입해보면 dp[5] = max(dp[7]+p[5], dp[6])가 나오는데 역인덱스로 나가는게 익숙하지 않아서 어떻게 할 지 몰랐던 것 같음 보통은 bottom-up으로 키우면서 하는데 약간 고정관념인듯
- 3. 초기값 정하기
  - dp 테이블 다 0으로 채워서 i가 선택되지 않은 경우를 고려해주자

### 2. 풀이

- dp 테이블의 최대값이 정답

## [15486 - 퇴사 2](https://www.acmicpc.net/problem/15486)

### 1. 해결 핵심 아이디어

- 14501 - 퇴사 문제는 N이 최대 20이라 완전탐색으로도 해결가능했지만 이 문제는 N이 최대 150만이라 시간제한을 통과하기 위해서는 dp로 풀어야함
- 14501 - 퇴사 문제를 풀 수 있는 다른 점화식도 있음
- 앞서 풀어봤던 문제들은 i에서 dp[i]의 값을 결정하는 것으로 끝나지만, 이 아이디어의 경우는 i를 결정할 뿐 아니라 dp[i + t[i]]도 갱신해줌
- 1. 테이블 정의하기
  - dp[i] = i-1일까지 상담을 했을 때 최대 수익
- 2. 점화식 세우기
  - dp[i] = max(dp[i], dp[i-1])으로 i일까지 상담했을 때 최대 수익 결정
  - if(i + t[i] <= n+1) dp[i+t[i]] = max(dp[i+t[i]], dp[i] + p[i])로 dp[i+t[i]]를 갱신한다
- 3. 초기값 정하기
  - dp 테이블 다 0으로 채워서 i가 선택되지 않은 경우를 고려해주자

### 2. 풀이

- 최대값은 dp[n] = n-1일까지 상담했을 때 최대 수익, dp[n+1] = n일까지 상담 했을 때 최대 수익 중 큰 값

## [10844 - 쉬운 계단 수](https://www.acmicpc.net/problem/10844)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i][j] = 길이 i를 갖는 계단수 중 끝자리가 j인 경우의 수
- 2. 점화식 정의하기
  - dp[i][0] = dp[i-1][j+1] (시작이 0인 계단수는 없음)
  - dp[i][9] = dp[i-1][j-1] (9와 인접인 수는 8밖에 없음)
  - dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1] (어떤 수 j의 인접은 j-1과 j+1)
- 3. 초기값 정하기
  - dp[1][j] = 1 (j = 0 ~ 9)

### 2. 풀이

- dp[n][j]를 모두 더해주면 정답

## [2748 - 피보나치 수 2](https://www.acmicpc.net/problem/2748)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i] = 피보나치 수열의 i항
- 2. 점화식 정의하기
  - dp[i] = dp[i-1] + dp[i-2] (i >= 2)
- 3. 초기값 정의하기
  - dp[0] = 0
  - dp[1] = 1

### 2. 풀이

- n이 90일 때 피보니치 수는 100경을 넘어가므로 long long형을 써야한다는 점 이외에는 주의할 점 없음

## [2240 - 자두나무](https://www.acmicpc.net/problem/2240)

### 1. 해결 핵심 아이디어

- 테이블 정의까지는 세울 수 있었는데, 점화식을 찾아보려했는데 실패했음, 움직임이 제한되야한다고 생각해서 너무 복잡하게 생각했다
- 나무 번호까지 변수로해서 3차원 테이블 저장해놓는 방법도 있음
- 1. 테이블 정의
  - dp[i][j] = i초에 j번 움직여서 얻을 수 있는 자두의 개수
- 2. 점화식 찾기
  - dp[i][0] = (s[i] == 1), 1번 나무에서 움직이지 않는 경우
  - dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + (1 + j % 2 == s[i]), 반대 나무로 움직여서 넘어오거나 그대로 있을 때 중 최대 값 + 현재 자두가 떨어지는지 아닌지
- 3. 초기값 정하기
  - 딱히 정해줄게 없음 0으로 초기화만 잘해주면 됨

### 2. 풀이

- 문제를 너무 어렵게 생각하는 경향이 있음, 단순하게 생각해서 테이블 정의대로 문제가 어떻게 풀려나가는지 살펴보도록 하자
- 조건이 너무 복잡하다싶으면 내가 어렵게 생각하고 있는게 아닌지 생각해 볼 필요가 있겠다

## [14002 - 가장 긴 증가하는 부분 수열 4](https://www.acmicpc.net/problem/14002)

### 1. 해결 핵심 아이디어

- 11053 - 가장 긴 증가하는 부분 수열과 아이디어는 동일
- 역추적이 필요한 문제라 테이블 갱신될 때마다 pre테이블도 같이 갱신

### 2. 풀이

- pre테이블은 역추적인데 출력은 순서대로 해줘야돼서 나는 stack을 이용했는데, 정답코드를 보니 deque을 이용해도 됨을 알게됬음

## [2156 - 포도주 시식](https://www.acmicpc.net/problem/2156)

### 1. 해결 핵심 아이디어

- 문제 설명때문에 그런가 2579 - 쉬운 계단수문제와 동일하게 했다가 틀려서 반례를 살펴보다가 연속 두 칸 건너뛰는게 가능해서(1에서 2와 3 거르고 4로 점프가능) 가능해서 점화식을 약간 수정했음
- 1. 테이블 정의하기
  - dp[i][j] = j번 연속해서 i번 포도주를 마실 때 현재까지 마신 포도주의 총합
- 2. 점화식 세우기
  - dp[i][1] = max({dp[i-3][1], dp[i-3][2], dp[i-2][1], dp[i-2][2]}) + wine[i]
  - dp[i][2] = dp[i-1][1] + wine[i]
- 3. 초기값 정하기
  - dp[1][1] = wine[1]
  - dp[1][2] = 0
  - dp[2][1] = wine[2]
  - dp[2][2] = wine[1] + wine[2]

### 2. 풀이

- [참고한 반례를 모아놓은 블로그](https://raejoonee.tistory.com/15)
- 정답코드보니 1차원으로 `d[i] = max({d[i-1], d[i-2] + a[i], d[i-3] + a[i-1] + a[i]})` 점화식을 세워서 푸는 방법도 있었음, 이 방법이 어떻게 연속 세 개가 안됨을 보장할 수 있을지 생각해봤는데, 1. i번 포도주 시식 안하는 경우, 2. i-2번까지 총합 마시고 i번 포도주 마시는 경우, 3.i-3번 까지의 최대량 마시고 i번과 i-1번 포도주 마시는 경우로 연속해서 3개를 마시는 경우가 없는데, 이해하기 좀 어려운 듯

## [15988 - 1, 2, 3 더하기 3](https://www.acmicpc.net/problem/15988)

### 1. 해결 핵심 아이디어

- 9095 - 1, 2, 3 더하기 문제와 같은데 입력 크기의 최대가 백만으로 변했음

### 2. 풀이

- 경우의 수 문제는 매우 커질 수 있으니 맘 편하게 long long형 쓰기

## [2302 - 극장 좌석](https://www.acmicpc.net/problem/2302)

### 1. 해결 핵심 아이디어

- 처음에는 i번 자리에 j가 오는 경우를 생각해서 vip배치까지 고려했는데 너무 복잡해서 점화식을 못 세웠다
- vip가 없다고 생각했을 때 경우의 수를 계산해보면 피보나치 수열이 나온다
- 1. 테이블 정의하기
  - dp[i] = 연속된 자리의 개수가 i개일 때 앉을 수 있는 경우의 수
- 2. 점화식 세우기
  - dp[i] = dp[i-1] + dp[i-2]
- 3. 초기값 정하기
     dp[0] = 1
     dp[1] = 1
     dp[2] = 2
- 피보나치를 다 구했으면 vip가 있는 경우로 확장시켜본다
  - vip는 고정이므로 vip들 사이에서만 서로 자리를 바꿀 수 있다
  - 3번과 7번이 vip라고하면, 4와 5, 5와 6끼리는 서로 자리교체가 가능
  - 결론적으로 vip들 사이에 몇 개가 있는지보고 그것들의 곱사건을 구해주면된다

### 2. 풀이

- vip[i] - vip[i-1] - 1은 i번 vip와 i-1번 vip 사이에 사람 수를 의미하고 ans \*= dp[vip[i] - vip[i-1] - 1]를 해주면 정답
- 점화시킬 때 제약을 고려할 수도 있지만 이 문제는 다 구해놓고 그 이후에 제약을 고려할 수도 있겠구나

## [11052 - 카드 구매하기](https://www.acmicpc.net/problem/11052)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i] = 카드를 i장 샀을 때, 최대합
- 2. 점화식 세우기
  - dp[i] = max(dp[i-j], dp[i]) (1 <= j <= i)
- 3. 초기값 정하기
  - dp[0] = 0
  - dp[1] = p[1]

### 2. 풀이

- 처음에는 1,2,3 더하기와 유사한 문제인 줄 알았는데 가만 생각해보면 뽑힐 수 있으면(아직 N장까지 3장 남았는데, 4장의 카드팩은 뽑힐 수 없음) 계속 뽑힐 수 있음 1,2,3 더하기는 1+2+1 이런 경우도 있으니 같은 문제가 아님

## [9465 - 스티커](https://www.acmicpc.net/problem/9465)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i][j] = i행 j열까지 스티커를 선택했을 때 최대 점수합
- 2. 점화식 세우기
  - dp[i][j] = max({dp[i - 1][3 - j], dp[i - 2][1], dp[i - 2][2]}) + sticker[i][j]
  - 현재의 칸을 선택하기 위해 하나의 열에서 선택없이 건너뛸 수 있음(문제의 설명같은 경우)
  - 두 칸 이상은 건너뛸 수 없는게 현재 칸 선택하기 위해 두 칸을 건너뛸 필요없고, 선택할 수 있으면 무조건선택하는게 더 최적이다(귀류법으로 증명가능)
- 3. 초기값
  - dp[1][1] = sticker[1][1]
  - dp[1][2] = sticker[1][2]

### 2. 풀이

- 처음에 문제를 제대로 읽지않아서 한 칸 건너뛰는 경우없이 무조건 지그재그로만 되는 줄 알아서 삽펐음 문제를 잘 읽자

## [11057 - 오르막 수](https://www.acmicpc.net/problem/11057)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i][j] = 길이가 i이고 끝자리가 j인 오르막수가 될 수 있는 경우의 수
- 2. 점화식 세우기
  - dp[i][j] += dp[i-1][k] (0 <= k <= j)
- 3. 초기값 정하기
  - dp[1][j] = 1 (0 <= j <= 9)
  - 0으로 시작할 수 있음

### 2. 풀이

- 처음 정답을 내는 과정에서 ans += (dp[n][j] % mod) (0 <= j <= 9)을 해줬는데 자꾸 틀리길래 봤더니 원인은 모듈로 덧셈이었다 경우의 수가 아닌 경우의 수를 10007로 나머지를 더했으면 모듈로 덧셈 공식에 의해 ans %= mod 했어야했는데 그냥 ans를 반환해서 틀렸었음

  ![모듈로 덧셈](https://user-images.githubusercontent.com/48282185/192248977-b043e573-fd6a-46f3-8454-611cbb4d6a8d.png)

## [2293 - 동전 1](https://www.acmicpc.net/problem/2293)

### 1. 해결 핵심 아이디어

- 처음 접근한 방식은 dp[i]를 i원을 만드는 경우의 수로 두고 i가 1부터 k까지 돌면서 i-coin[j]에서 구해놓은 경우의 수를 계속 더해줬는데 값이 크게나오는 것으로 보아 중복이 발생한다고 판단했음
- 내가 처음했던 방식으로하면 i를 만드는 경우의 수가 중복으로 세진다
- 3 10 1 2 3 예시를 위의 방법으로 풀면 dp[3]을 만드는데 +=dp[2]을 더하는 경우와 +=dp[1]을 하는 경우에서 각각 (1,2),(2,1)이 두 번 세진다 순서가 달라지면 중복이 카운트됨
- 중복처리가 잘 안돼서 정답코드를 참고하였는데 기존의 방식에서 i와 j의 루프를 바꿔주면 됬는데 동전 각각에 대해 i를 만드는 경우의 수를 세주는 방법이다
- 1. 테이블 정의
  - dp[i] = i원을 만드는 경우의 수
- 2. 점화식 정의
  - dp[j] += dp[i - coin[j]]
  - dp[j] += dp[j - coin[i]]에서 coin[i]는 j가 변해도 고정이므로 중복이 발생하지 않는다 (coin[i], j-coin[i])만 카운트됨, 중복이 사라짐
- 3. 초기값
     dp[0] = 1 (동전 자기 자신으로 k원을 만족하는 경우)

### 2. 풀이

- 점화식을 세웠으면 그게 제약조건을 만족하는지 보자, 왜 다와놓고도 틀리냐?

## [1904 - 01타일](https://www.acmicpc.net/problem/1904)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의
  - dp[i] = 길이 i인 이진 수열의 개수
- 2. 점화식 세우기
  - dp[i] = dp[i-1] + dp[i-2]
  - 길이 i-1인 이진 수열 + 1, 길이 i-2인 이진 수열 + 00
- 3. 초기값 정하기
  - dp[1] = 1
  - dp[2] = 2

### 2. 풀이

- 이런 간단한 문제는 자다가 누가깨워도 바로 풀 수 있어야함

## [1788 - 피보나치 수의 확장](https://www.acmicpc.net/problem/1788)

### 1. 해결 핵심 아이디어

- 수열을 나열해보니 짝수일 때만 양수에서 정의되는 피보나치 수열의 값에서 절댓값은 같고 부호만 다르다는 규칙을 찾음
- 원래의 피보나치 수열을 구해놓고 음수가 입력으로 들어왔을 때 처리만 잘해주면 되는 문제
- 피보나치 점화식은 간단하니 적지않겠음

### 2. 풀이

- 절댓값이 짝수라면 2로 나눈 나머지는 0이 나온다 -2도 2로 나누면 나머지가 0임

  [나머지 연산을 음수로 확장했을 때](https://jeonggyun.tistory.com/228)

## [4883 - 삼각 그래프](https://www.acmicpc.net/problem/4883)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i][j] = i행 j열의 정점까지 왔을 때 최소 비용
- 2. 점화식 세우기
  - dp[i][1] = min(dp[i - 1][1], dp[i - 1][2]) + graph[i][1];
  - dp[i][2] = min({dp[i - 1][1], dp[i - 1][2], dp[i - 1][3], dp[i][1]}) + graph[i][2];
  - dp[i][3] = min({dp[i - 1][2], dp[i - 1][3], dp[i][2]}) + graph[i][3];
  - 진입할 수 있는 경로가 각 열의 정점마다 차이가 있기에 가능한 모든 경우를 고려해줘야함
  - 비용이 정수라는 것과 비용의 제곱은 백만보다 작다는 것으로 보아 음수일 수도 있다는 뜻임, 제곱 얘기가 없었으면 음수를 내가 과연 고려했을까?
- 3. 초기값 정하기
  - (1, 2)에서 출발해야한다는 제약조건때문에 1행과 2행, 2행과 그 밑의 경우로 나눴는데, 1행과 2행에서는 (1,1)이 고려되지 않아야하기 때문임
  - 그래서 2행의 각 정점에 도달할 수 있는 경우를 모두 고려하여 초기값을 정했음
  - dp[2][1] = graph[1][2] + graph[2][1];
  - dp[2][2] = min({dp[2][1], graph[1][2], graph[1][2] + graph[1][3]}) + graph[2][2];
  - dp[2][3] = min({dp[2][2], graph[1][2], graph[1][2] + graph[1][3]}) + graph[2][3];

### 2. 풀이

- 정답코드를 보니 초기값으로 (1,1)에는 정점이 가질 수 있는 최대비용을 (1,3)에는 (1,2) -> (1,3)의 비용을 초기값으로 두고 2행부터 바로 점화시켰는데, 이게 훨씬 좋은 방법같다 간단히 끝나네

## [9251 - LCS](https://www.acmicpc.net/problem/9251)

### 1. 해결 핵심 아이디어

- 처음에는 dp[i][j] = j번 문자열의 i길이에서 LCS의 길이로 설정

  ```cpp

  cnt += (s[i][j] == s[1 - i][k]);
  dp[j][i] = dp[j - 1][i] + (cnt > 0);

  ```

- 이와 같이 점화식을 작성하였는데, 여기서의 논리적 결함은 BCDEFGHA / ACDEFGHB가 주어졌을 때 정답은 6이지만 7로 나온다 이유는 ACD로 시작하는 문자열의 끝에 B의 경우 위 점화식대로하면 7이나오는데, B는 LCS의 구성요소가 아님에도 불구하고 카운트가된다
- 올바른 정답은 문자열 s1, s2가 있다고할 때 s1의 길이 i를 하나씩 늘려가면서 s2의 모든 요소를 순회하면서 길이 i를 만족하는 공통 부분 문자열이 있는지를 살펴봐야하는 것이다

  - A...B... 과 ABA...B... 의 LCS의 길이는 2이다

- 1. 테이블 정의하기
  - dp[i][j] = a의 i-1번째 글자와 b의 j-1번째 글자까지 LCS의 길이
  - 문자열 인덱스는 0부터고 LCS는 1부터라 이렇게 나옴 굳이 인덱스 맞출려면 맞출 수 있긴한데, 불필요한 과정 필요
- 2. 점화식 세우기
  - if(a[i-1] == b[j-1]) dp[i][j] = dp[i-1][j-1] + 1 (같은 문자를 만났을 때 비교 전 단계 LCS + 1)
  - else dp[i][j] = max(dp[i-1][j], dp[i][j-1]) (다른 문자를 만나면, 현재 위치에서 LCS 구함)
- 3. 초기값 정하기
  - 테이블 전체 0으로 초기화

### 2. 풀이

- 이 문제는 많이 어려운 것 같아서 여러번 봐야겠음

## [1699 - 제곱수의 합](https://www.acmicpc.net/problem/1699)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i] = i를 구성하는 제곱수들 합의 항의 최소 개수
- 2. 점화식 세우기
  - dp[i] = min(dp[i], dp[i - j\*j] + 1) (1 <= j\*j <= i)
- 3. 초기값 정하기
  - 테이블의 초기값으로 최대값인 십만을 1로 구성할 때 항의 개수 십만으로 설정

### 2. 풀이

- 비교적 풀기 쉬운 문제여서 따로 코멘트 없음

## [9084 - 동전](https://www.acmicpc.net/problem/9084)

### 1. 해결 핵심 아이디어

- 2293 - 동전 1문제와 동일하게 풀면 됨

### 2. 풀이

- 2293 - 동전 1문제와 동일 풀이

## [1915 - 가장 큰 정사각형](https://www.acmicpc.net/problem/1915)

### 1. 해결 핵심 아이디어

- 처음에는 dp[i][j] = i행에서 j열에 위치할 때 1이 연속되는 최대길이로 정의했는데, 알고리즘을 짜보니 O(${n^4}{m^4}$)나와서 다른 방법을 생각해봤는데 도무지 떠오르지 않았음
- 크기가 N X N인 정사각형의 특징을 살펴보자
  - 이 정사각형을 크기 1 X 1인 정사각형으로 나눠봤을 때 (N, N) 기준으로 같은 열, 같은 행 좌대각선을 구성하는 크기 1 X 1인 정사각형의 개수가 같다
- 이 사실에 입각해서 문제를 풀어보자
- 주어지는 n x m 크기의 사각형을 1 x 1크기의 정사각형으로 나누고 원소 1을 갖는 정사각형을 나타내는 각 좌표를 위 설명의 (N ,N)라고 생각해보면 좌행, 위열, 좌대각을 구성하는 1 x 1크기의 사각형의 개수 중 최소값이 N X N을 포함하는 정사각형의 한 변의 길이가 된다
- 1. 테이블 정의하기
  - dp[i][j] = i행 j열을 포함하는 정사각형의 한 변의 길이 중 최대값
- 2. 점화식 세우기
  - if(square[i][j] == 1) dp[i][j] = min({dp[i-1][j-1], dp[i][j-1], dp[i-1][j]}) + 1
- 3. 초기값 정하기
  - 테이블을 0으로 채우고 시작

### 2. 풀이

- 1부터 점화시켜서 테이블 중 최대값을 찾아서 제곱해주면 된다

## [10942 - 팰린드롬?](https://www.acmicpc.net/problem/10942)

### 1. 해결 핵심 아이디어

- 이 문제를 풀 위해서 팰린드롬의 특징을 분석해봤음
  - 1. 어떤 문자열 s의 길이가 홀수라면 가운데 인덱스를 기준으로 같은 거리에 있는 문자가 같아야함
  - 2. 어떤 문자열 s의 길이가 짝수라면 문자열을 반으로 나눴을 때 같은 인덱스에 위치하는 문자가 같아야함
- 이렇게 두고, 팰린드롬을 어떻게 분해해서 이게 팰린드롬인지 판단할 수 있을까에 대한 고민을 해봤는데 좀처럼 방법이 떠오르지 않음
- 발견하지 못한 팰린드롬의 특징은 문자열 s를 axa라 하고 x는 임의의 문자열이라고 할 때 s가 팰린드롬이려면, x도 팰린드롬을 만족해야한다는 것이다
- 1. 테이블 정의하기
  - dp[i][j] = 구간 [i, j]의 부분문자열이 팰린드롬을 만족하는지 아닌지를 나타냄
- 2. 점화식 세우기
  - en = st + w
  - if(arr[st] == arr[en] && dp[st+1][en-1]) dp[st][en] = 1
  - window(w)를 2부터 시작해서 하나씩 늘려가면서 팰린드롬을 만족하는지 본다
- 3. 초기값 정하기
  - dp[i][i] = 1
  - if(arr[i-1] == arr[i]) dp[i-1][i] = 1
  - dp[st+1][en-1]을 이용하기위해 길이가 2인 부분 문자열도 초기값으로 넣어준다

### 2. 풀이

- 팰린드롬을 만족하는 문자열이 어떻게 점차 몸집을 불려나가는지를 봤어야했는데, 그 부분을 캐치못한 점이 아쉽다
- 테이블의 정의는 문제여야한다, 테이블 값이 작은 문제의 계산 값이고 그 결과를 이용해서 더 큰 문제를 푸는 것이 다이나믹 프로그래밍이다, 테이블을 어떻게 정의해야할 지 감이 안올 때는 어떤 문제를 푸는지부터 명확히 이해하고 이 문제가 어떻게 분할될 수 있는지 봐야한다
- 이 문제를 예시로 들면, s부터 e까지의 부분 문자열이 팰린드롬인지 판단하는 문제인데, 내 생각은 s++, e--시키면서 팰린드롬인지 일일이 확인하는 것에서 그쳤는데, 이건 작은 문제를 이용하는 게아니라 완전탐색이다
- 큰 문제를 푸는데 필요한 작은 문제들도 큰 문제와 성격이 같다, 이게 뭔 말이냐면, 큰 문제도 팰린드롬을 만족하고 작은 문제도 팰린드롬을 만족한다는 것이고, 피보나치를 구할 때도 i-2번과 i-1번도 피보나치 수열의 일부이고 i번 값 또한 피보나치 수열의 일부이다, 문제의 성격을 벗어나는 값이 테이블로 저장될 수 없다는 것임

## [9655 - 돌 게임](https://www.acmicpc.net/problem/9655)

### 1. 해결 핵심 아이디어

- 돌이 1개가 남았을 때 무조건 상근이가 이기고, 2개 남았을 때는 무조건 창영이가 이긴다
- 이 문제는 굳이 다이나믹 프로그래밍을 사용할 필요가 없이 규칙을 나열해봤을 때 서로 턴이 홀수 짝수로 번갈아가면서 바뀌고, 1개 또는 3개만 가져갈 수 있으므로, 상근이는 홀수 턴 + 홀수 개 = 짝수, 창영이는 짝수 턴 + 홀수 개 = 홀수이므로 N이 짝수이면 무조건 창영이가 이기고, 홀수이면 무조건 상근이가 이긴다
- 이 문제를 분할할 수 있긴한데, i-1개를 가져간 상황에서 돌이 1개 남았을 때, i-2개를 가져간 상황에서 돌이 2개 남았을 때를 생각해보면, 돌이 1개남았을 때랑 2개 남았을 때랑 누가 이길지 명백하다
- 1. 테이블 정의하기
  - dp[i] = 돌이 i개 주어졌을 때 이기는 사람의 번호 (0번 상근, 1번 창영)
- 2. 점화식 정의하기
  - dp[i] = 1 - dp[i-1]
- 3. 초기값 정하기
  - dp[1] = 0
  - dp[2] = 1

### 2. 풀이

- 3부터 점화시켜서 dp[n]으로 승자가 누구인지 가려지면 sk 또는 cy를 알맞게 출력해주면 된다

## [2011 - 암호코드](https://www.acmicpc.net/problem/2011)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i] = 주어진 숫자의 i번 까지 봤을 때 가능한 암호의 경우의 수
- 2. 점화식 세우기
  - if(pw[i] != '0') dp[i] += dp[i-1] (1 ~ 9는 알파벳으로 치환 가능)
  - if(10 <= pw[i-1]pw[i] <= 26) dp[i] += dp[i-2] (10 ~ 26은 알파벳으로 치환 가능)
  - 암호 i는 암호 i-1와 pw[i]로 구성
  - 암호 i는 암호 i-2와 pw[i-1]pw[i]로 구성
- 3. 초기값 설정
  - 0이 들어간 경우때문에 조금 까다로움
  - dp[0] = pw[0] != 0
  - dp[1]이 1이 되는 경우는 세 가지 있음, pw[0]와 합쳐서 알파벳을 만들 수 있고 pw[1]이 0인 경우, pw[1]이 0이 아닌 경우, pw[0]와 합쳐서 알파벳을 만들 수 없고 합친 값이 26보다 크고, 10의 배수가 아닌 경우

### 2. 풀이

- 0처리가 까다로운 것 말고는 어려운 부분은 딱히 없었음

## [2294 - 동전 2](https://www.acmicpc.net/problem/2294)

### 1. 해결 핵심 아이디어

- 2293 - 동전 1문제와 아이디어는 비슷하나 이 문제는 사용되는 동전의 최소 개수를 구하는 문제로, 동전을 차례로 1번부터 N번까지 보면서 동전 i원으로 k원을 만들 수 있는 경우의 수를 만들어가면서 이전 동전의 조합으로 만든 것보다 현재 동전 조합으로 만든 것이 더 동전의 개수가 적다면, 갱신해주면 끝

### 2. 풀이

- dp[j] = min(dp[j-coin[i]] + 1, dp[j])로 점화식 변경해주고 dp 테이블 초기값은 1로 만원을 만들 수 있는 만 개보다 큰 값으로 채워줌

## [2133 - 타일 채우기](https://www.acmicpc.net/problem/2133)

### 1. 해결 핵심 아이디어

- 이 문제를 첫 시도에 틀린이유는 미처 고려하지 못한 경우가 있었기 때문
- 단순히 dp[i-2] _dp[2]에다가 i에서 생성되는 특별한 모양 2개해서 dp[i] = dp[i-2]_ 3 + 2로 정의했는데 내가 고려못했던 부분은 4부터 특이한 모양이 생성되는데 이 경우가 dp[i-2] \* dp[2]에 포함되지 않는 것이었음
- 무슨 말이냐면, dp[8]에서 생성되는 다음의 두 가지 경우를 보자

  ![special case 1](https://user-images.githubusercontent.com/48282185/193450415-181ae173-fcf8-4cd7-b208-980494b40757.png)

  ![special case 2](https://user-images.githubusercontent.com/48282185/193450524-bf37e884-e216-45f1-b780-6fe6ceecd452.png)

- 위의 두 가지 경우들이 dp[i-2] \*\ dp[2]에 포함되지 않는 것을 확인할 수 있다
- 1. 테이블 정의
  - dp[i] = 3 X i 크기의 사각형을 만드는 경우의 수
- 2. 점화식 정의
  - dp[i] = dp[i-2] _dp[2] + 2_ ${\sum\nolimits_{j=2}^{i-4} {dp[i]}}$ + 2
  - 저 특이케이스들은 i가 6일 때부터 생기고, 그 특이케이스가 180도 대칭된 경우까지 총 2가지 나온다
  - 2는 i일 때만 생기는 특이한 모양
- 3. 초기값 정하기
  - dp[2] = 3
  - dp[i] = 0 (i는 홀수)

### 2. 풀이

- 모든 케이스가 잘라진 문제로 풀리는지 봐야하는데, 그러질 못했음

## [1520 - 내리막 길](https://www.acmicpc.net/problem/1520)

### 1. 해결 핵심 아이디어

- 이 문제를 풀 때 처음에는 테이블을 dp[i][j] = 내리막 길로만 내려왔을 때, (i, j)를 거치는 경로의 수라고 두고, (i, j)가 경로에 놓일 조건을 분석해보니, 시작점과 연결되어있어야하고, 상하좌우에 자기보다 큰 원소가 있어야한다는 점이었다, 그래서 시작점과 연결되있다는 확인하기위해 BFS를 사용해서, 상하좌우를 살펴서 자기 보다 작은 원소가 있을 때만 진행하게 만들어줬는데, 이 방식이 논리적으로 잘못된 점이 있는데 (i, j)와 (n, m)이 닿을 수 있는지를 고려안했다는 것이다, 경로라는 것이 (1, 1)에서 (n, m)로 갈 수 있는 정점의 집합인데도 말이다
- 시작점과 끝 점을 고려해서 테이블을 다시 정의해보면, dp[i][j] = (i, j)에서 (n, m)으로 갈 수 있는 경로의 수로 둬야한다, 결국 끝점에 닿을 수 있는지 없는지를 봐야하기 때문이다
- 위 방식을 BFS로 구현하게되면, (n, m)에 도착하고 끝나기때문에, 어느점에서 출발해서 도착점에 닿았는지 추적이 어렵다, 그래서 닿고나서 되돌아오는 DFS로 구현해야한다
- 1. 테이블 정의하기
  - dp[i][j] = (i, j)에서 (n, m)으로 갈 수 있는 경로의 수
- 2. 점화식 세우기
  - dp[i][j] += dfs(nx, ny)
  - dfs(i, j)의 리턴 값은 끝점에 닿으면 1, 이전에 방문했던 점 (x, y)를 만나면 dp[x][y]를 리턴
  - 최종적으로 가능한 모든 경로들이 끝 점이나 중간에 막혀서 리턴되면서 총 경로의 수가 나오게됨
  - 중간에 막히는 것이 어떻게 경로를 이룰 수 있는지 따져봐야하는데, (x, y)가 (n, m)에 닿는 경로 중 하나고, (r, c)의 다음 방문 지점이 (x, y)라고 하자, (r, c)의 원소는 무조건 (x, y)보다 크고, (x, y)가 (n, m)으로 가는 경로 상에 (r, c)보다 큰 값이 없음을 보장할 수 있다, 아니면 경로를 이룰 수 없었을 것이다, 결론적으로 ... -> (r, c) -> (x, y) -> ... -> (n, m)이 성립한다
  - 이런 방식으로하면, 두 경로가 만나는 교점에서 값이 더해져서 테이블 정의에 맞는 경로의 수가 저장되게된다
- 3. 초기값 정하기
  - 0으로 초기값을 설정하면, dp[x][y] = 0일 때 이게 처음 방문 해서 0인건지, 아니면 경로의 개수가 0이어서 0인건지 구별이 안되기 때문에 이 부분문제를 계속해서 풀기 때문에 시간 초과가 난다
  - 초기값은 반드시 답으로 절대 나올 수 없는 값으로 해야 효과가 있다
  - 결론적으로 dp테이블을 -1로 초기화하고 시작해야한다

### 2. 풀이

- 이 문제에서 배운 점이 굉장히 많다
- 언제 dfs를 사용해야하는지, dp를 메모이제이션 용도로 활용하는 것, dp가 뭔지에 대해 다시 한 번 깨우치는 계기가 됨
- dp는 중복되는 부분문제를 재계산하지않기 위한 테크닉인데, 첫 시도에서 dp가 ans(a,b)의 부분문제를 대변하지 않고 단순 가지치기로 사용했었음
- dp[a][b]가 ans(a,b)의 답을 대신해준다고 생각해야한다

## [9657 - 돌 게임 3](https://www.acmicpc.net/problem/9657)

### 1. 해결 핵심 아이디어

- 완벽하게 게임한다는 뜻은 1, 3, 4 중 하나를 골랐을 때 자신이 이길 수 있는 경우, 그 수를 선택한다는 뜻
- 처음에는 가져갈 수 있는 최대한 가져가는 걸로 오해했었음
- 1. 테이블 정의하기
  - dp[i] = 돌 i개가 있을 때 상근이가 이길 수 있을 때 0, 창영이가 이길 수 있으면 1
- 2. 점화식 세우기
  - 상근이부터 시작하기 때문에 상근이 입장에서 이길 수 있으면 경우가 있으면 그 경우를 선택하고, 모든 경우를 다 해봤는데도 못이기면 창영이가 이기는 것
  - dp[i] = ((1 - dp[i - 4]) + (1 - dp[i - 3]) + (1 - dp[i - 1]) >= 3)
  - 1 - dp[i-4]의 뜻은 상근이가 4를 선택했을 때, 선수 교체되므로 i-4개부터 창영이가 먼저 시작 즉, 1 - dp[i]의 의미는 돌이 i개 있을 때 창영이가 이기는 경우를 뜻한다
- 3. 초기값 정하기
  - dp[0] = 1 (4부터 점화시키는데, 돌이 4개면, 상근이가 4개가져가면 끝나므로 4에서는 무조건 상근이가 이기므로 1 - dp[i-4]를 0으로 만들어서 합이 3이 넘지 못하게했음
  - dp[2] = 1

### 2. 풀이

- 완벽하게 게임을 했다는 것을 이해못했는데, 문제 설명이 좀 모호한 것 같다

## [11660 - 구간 합 구하기 5](https://www.acmicpc.net/problem/11660)

### 1. 해결 핵심 아이디어

- 1. 테이블 정의하기
  - dp[i][j] = (1, j)부터 (i, j)까지 누적합
- 2. 점화식 세우기
  - dp[j][i] = dp[j - 1][i] + board[j][i]; (j = 2 ~ n)
- 3. 초기값 설정하기
  - dp[1][i] = board[1][i];

### 2. 풀이

- x1, y1, x2, y2에서 서로 가리키는 점이 같으면 board[x1][y1]
- x1, y1, x2, y2에서 시작과 끝을 가리키는 경우 dp테이블 마지막 행의 모든 열을 더해줌
- 위 두 케이스를 제외하면, dp[x2][i] - dp[x1 - 1][i]을 i가 y1부터 y2까지 더해주면됨

## [2482 - 색상환](https://www.acmicpc.net/problem/2482)

### 1. 해결 핵심 아이디어

- N개 중 k개를 뽑을 수 있는데, 이 때 인접하지 않게 배치할 수 있는 k의 최대값은 N / 2개이다(직접 세보면 앎)
- 원형과 선형문제의 차이점은 i번째에 색칠할지 말지 선택하는 점화식 달라지진 않지만, k의 상한이 달라진다
- 선형에서는 5개에서 3개뽑는 경우도 가능하지만, 원형에서는 최대 2개이다
- 선형과의 차이는 1번과 N번이 맞닿아 있는 점을 제외하면 없음, 그렇기 때문에 1번과 N번 점이 동시에 칠해지는 경우가 없으므로, N번을 칠하는 경우와 그렇지 않는 경우를 나누면된다
- 1. 테이블 정의하기
  - dp[i][j] = i개 색 중 j개를 선택하는 경우의 수
- 2. 점화식 세우기
- dp[i][j] = dp[i-1][j] + dp[i-2][j-1]
- 3. 초기값 정하기
  - N개의 자리 중 하나만 선택하는 경우는 N가지 있음
  - dp[i][1] = i

### 2. 풀이

- 이 문제는 조금만 더 고민해봤으면 풀 수 있었을 것 같은데, 너무 어렵게 생각하는 경향 때문에 포기가 너무 빨라
- 고민 시간을 30분에서 40분으로 늘려야겠음
