# 0x1C 플로이드 알고리즘

<!--ts-->

- [0x1C 플로이드 알고리즘](#0x1c-플로이드-알고리즘)
  - [0x00 알고리즘 설명](#0x00-알고리즘-설명)
  - [0x01 구현](#0x01-구현)
  - [0x02 경로 복원 방법](#0x02-경로-복원-방법)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 7월 22일 금요일 11시 49분 12초 KST -->

<!--te-->

## 0x00 알고리즘 설명

- 모든 정점 쌍 사이의 최단 거리를 구하는 알고리즘
- 방향 그래프이건 무방향 그래프이건 상관없다
- 간선의 값이 음수여도 잘 동작하지만 음수인 사이클이 있으면 문제가 생긴다
- 그림으로 보는 과정

  ![1](https://user-images.githubusercontent.com/48282185/180352345-3278f134-b792-4599-af77-148d4ff2c2d4.png)

  - 최단 거리 테이블을 초기화한다
  - $\infin$는 서로 이웃정점이 아니라서 거리를 알 수 없음을 의미
  - 중간에 다른 정점을 거치지 않았을 때의 최단거리

    ![2](https://user-images.githubusercontent.com/48282185/180352341-d6c68619-54e8-4640-9553-514f3dc11bae.png)

  - ‘1번 정점을 거쳐가면 최단 거리가 갱신되는가?’ 를 살펴본다
  - D는 최단 거리 테이블
  - D[s][t] = s번 정점에서 t번 정점으로 갈 때 다른 정점을 거치지 않고 갈 수 있는 최단 거리
  - s번 정점에서 t번 정점으로 가는 거리 = min(D[s][t], D[s][1] + D[1][t])
  - 2 ↔ 3, 2 ↔ 4, 3 ↔ 4 경로는 1번 정점을 거쳐서 가는 것이 현재까지 최단 경로
  - 이 스텝의 결과는 다른 정점을 거치지 않았거나 1번 정점을 거쳐서 간 최단 거리가 됨

    ![3](https://user-images.githubusercontent.com/48282185/180352339-9dd44b9d-c295-4bd4-9ddc-f5d22d98a12c.png)

  - ‘2번 정점을 거쳐가면 최단 거리가 갱신되는가?’를 살펴본다
  - D[s][t] = s번 정점에서 t번 정점으로 갈 때 다른 정점을 거치지 않거나 1번 정점을 거쳐서 갈 수 있는 최단 거리
  - s번 정점에서 t번 정점으로 가는 거리 = min(D[s][t], D[s][2] + D[2][t])
  - 1↔5, 3↔5 경로는 2번 정점을 거쳐서 갔을 때가 현재까지 최단 경로
  - 이 스텝의 결과는 다른 정점을 거치지 않았거나 1번 정점을 거쳤거나 2번 정점을 거쳐서 간 최단 거리가 됨

    ![4](https://user-images.githubusercontent.com/48282185/180352336-3dc8a77a-28b4-4f1c-a8e1-34f1fec6770c.png)

  - ‘3번 정점을 거쳐가면 최단 거리가 갱신되는가?’를 살펴본다
  - D[s][t] = s번 정점에서 t번 정점으로 갈 때 다른 정점을 거치지 않거나 1번 정점을 거쳤거나 2번 정점을 거쳐서 갈 수 있는 최단 거리
  - s번 정점에서 t번 정점으로 가는 거리 = min(D[s][t], D[s][3] + D[3][t])
  - 3번 정점을 거쳐서 갈 경우 최단 경로가 되는 경우가 없으므로 다음 스텝으로 넘어간다
  - 이 스텝의 결과는 다른 정점을 거치지 않았거나 1번 정점을 거쳤거나 2번 정점을 거쳤거나 3번 정점을 거쳐서 간 최단 거리가 됨

    ![5](https://user-images.githubusercontent.com/48282185/180352334-f94e637c-92c5-4727-8abb-b61cbf941831.png)

  - ‘4번 정점을 거쳐가면 최단 거리가 갱신되는가?’를 살펴본다
  - D[s][t] = s번 정점에서 t번 정점으로 갈 때 다른 정점을 거치지 않거나 1번 정점을 거쳤거나 2번 정점을 거쳤거나 3번 정점을 거쳐서 갈 수 있는 최단 거리
  - s번 정점에서 t번 정점으로 가는 거리 = min(D[s][t], D[s][4] + D[4][t])
  - 1↔5, 3↔5 경로는 4번 정점을 거쳐서 가는 것이 현재까지 최단 경로
  - 이 스텝의 결과는 다른 정점을 거치지 않았거나 1번 정점을 거쳤거나 2번 정점을 거쳤거나 3번 정점을 거쳤거나 4번 정점을 거쳐서 간 최단 거리가 됨

    ![6](https://user-images.githubusercontent.com/48282185/180352331-11b7b9b6-1262-4aa0-87eb-7e780ae87ba1.png)

  - ‘5번 정점을 거쳐가면 최단 거리가 갱신되는가?’를 살펴본다
  - D[s][t] = s번 정점에서 t번 정점으로 갈 때 다른 정점을 거치지 않거나 1번 정점을 거쳤거나 2번 정점을 거쳤거나 3번 정점을 거쳤거나 4번 정점을 거쳐서 갈 수 있는 최단 거리
  - s번 정점에서 t번 정점으로 가는 거리 = min(D[s][t], D[s][5] + D[5][t])
  - 5번 정점을 거쳐서 갈 경우 최단 경로가 되는 경우가 없으므로 다음 스텝으로 넘어간다
  - 이 스텝의 결과는 다른 정점을 거치지 않았거나 1번 정점을 거쳤거나 2번 정점을 거쳤거나 3번 정점을 거쳤거나 4번 정점을 거쳤거나 5번 정점을 거쳐서 간 최단 거리가 됨
  - s번 정점에서 t번 정점으로 최단으로 갈 수 있는 모든 경우의 수를 살펴봤으므로 알고리즘 종료

- 시간복잡도
  - 정점 V개라 할 때 총 V단계에 걸쳐서 갱신이 이루어지고, k=1, 2, 3, …, V번째 단계마다 총 $V^2$개의 모든 D[s][t]값을 D[s][k] + D[k][t]와 비교하기 때문에 O($V^3$)이다
- 알고리즘의 정당성은 각 스텝별로 이루어지는 과정을 귀납적인 논법을 통해 수학적으로 엄밀히 증명가능하다

## 0x01 구현

- 11404 - 플로이드

  - 전형적인 플로이드 알고리즘 문제

    ```cpp
    for (int k = 1; k <= v; ++k)
      for (int i = 1; i <= v; ++i)
        for (int j = 1; j <= v; ++j) {
          if (i == j or k == i or k == j) continue;
          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
        }
    ```

  - 최댓값으로 INT_MAX쓰면 INT_MAX + INT_MAX해서 오버플로 날 수도 있으니 INT_MAX대신 문제에서 주어진 조건들을 활용해 제일 긴 거리가 얼마인지 구해본다
  - 이 문제에서는 99 \* 100,000

    ```cpp
    const int INF = 0x3f3f3f3f;
    ```

  - 1초에 대략 3 ~ 5억번 연산인데 플로이드의 경우 O($V^3$)라 간당간당하지만, 단순 3중 for문이라 써도 괜찮다
  - 보통 알고리즘 풀이 환경에서는 연산보다 대입이 느려서 꼭 필요한 경우만 대입을 해주는 것이 좋다, 특히 플로이드 알고리즘처럼 대입이 많이 일어나는 경우가 더 그렇다
    - min을 사용하는 것과 if문을 써서 꼭 필요한 경우만 갱신해주는 경우의 시간 차이는 정점 1000개일 때 950ms vs 700ms
    - 요런걸 상수 시간 최적화라고 함
  - 근데 보통은 출제자의 의도가 플로이드 알고리즘을 쓰라고 한 게 정해였다면 정점을 1000개 주지 않음

## 0x02 경로 복원 방법

- 단순 플로이드 알고리즘만으로는 최단 거리는 알 수 있어도 최단 경로는 알 수 없다
- 테이블을 하나 더 만들어서 경로를 저장해놓는다
- 그림으로 보는 과정

  ![7](https://user-images.githubusercontent.com/48282185/180352328-6d2c43af-72d4-4fd4-b2df-0dd84266bc88.png)

  - nxt 테이블은 현재 s번 정점에서 t번 정점로 갈 때의 중간 정점번호를 기억한다
  - 초기값은 아무 정점도 거치지 않고 갈 때의 최단 거리이므로 서로 인접인 경우만 상대방의 번호를 적어 둔다 nxt[s][t] = t

    ![8](https://user-images.githubusercontent.com/48282185/180352327-99bba7a5-8ff6-4af1-b6a1-78ad10d33f8b.png)

  - 1번 정점을 거쳐서 최단 경로가 되는 경우는 2 ↔ 3, 2 ↔ 4, 3 ↔ 4 경로인데, 해당 경로들은 기존의 s번 정점에서 t번 정점으로 가는 경로보다 s번 정점에서 1번 정점을 먼저 갔다가 1번 정점에서 t번 정점으로 가는 것이 효율적인 상황이므로 nxt[s][t] = nxt[s][1](if nxt[s][1] == 0이면 1)로 갱신한다

    ![9](https://user-images.githubusercontent.com/48282185/180352323-2a87f82e-7f45-455b-a8db-e1b2a5822042.png)

  - 2번 정점을 거쳐서 최단 경로가 되는 경우는 1↔5, 3↔5 경로인데, 해당 경로들은 기존의 s번 정점에서 t번 정점으로 가는 경로보다 s번 정점에서 2번 정점을 먼저 갔다가 2번 정점에서 t번 정점으로 가는 것이 효율적인 상황이므로 nxt[s][t] = nxt[s][2](if nxt[s][2] == 0이면 2)로 갱신한다

    ![10](https://user-images.githubusercontent.com/48282185/180352321-3479ff37-f939-4d17-abf0-b4716908ea46.png)

  - 3번 정점을 거쳐서 최단 경로가 되는 경우는 없으므로 다음 단계로 넘어감

    ![11](https://user-images.githubusercontent.com/48282185/180352313-44ff463a-492b-40ae-8662-b8a2b23f120e.png)

  - 4번 정점을 거쳐서 최단 경로가 되는 경우는 1↔5, 3↔5 경로인데, 해당 경로들은 기존의 s번 정점에서 t번 정점으로 가는 경로보다 s번 정점에서 4번 정점을 먼저 갔다가 4번 정점에서 t번 정점으로 가는 것이 효율적인 상황이므로 nxt[s][t] = nxt[s][4](if nxt[s][4] == 0이면 4)로 갱신한다

    ![12](https://user-images.githubusercontent.com/48282185/180352289-aa8dc70b-4b4b-4d17-8a22-009812339636.png)

  - 5번 정점을 거쳐서 최단 경로가 되는 경우는 없어서 갱신은 일어나지 않고, 알고리즘 종료

- nxt 테이블을 이용해서 최단 경로 복원하는 방법
  - nxt[s][t] = x(s에서 t로 갈 때 x를 거쳐간다), nxt[x][t] = y(x에서 t로 갈 때 y를 거쳐간다), nxt[y][t] = z(y에서 t로 갈 때 z를 거쳐간다), … nxt[n][t] = t, 즉 t번 정점에 도착할 때까지 계속 타고 들어간다
- 11780 - 플로이드 2

  - 경로 추적

    ```cpp
    void trace_path(int s, int t) {
      vector<int> path = {s};
      int cur = nxt[s][t];
      while (cur != t) {
        path.push_back(cur);
        cur = nxt[cur][t];
      }
      path.push_back(t);
      cout << (int)path.size() << ' ';
      for (int vertex : path) cout << vertex << ' ';
      cout << '\n';
    }
    ```

> 바킹독님 유튜브 강의를 참고하여 제작하였습니다.
