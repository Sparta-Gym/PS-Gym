# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/11404" rel="nofollow">11404 - 플로이드</a>](#11404---플로이드)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 코멘트](#2-코멘트)
  - [<a href="https://www.acmicpc.net/problem/11780" rel="nofollow">11780 - 플로이드 2</a>](#11780---플로이드-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 코멘트](#2-코멘트-1)
  - [<a href="https://www.acmicpc.net/problem/14938" rel="nofollow">14938 - 서강그라운드</a>](#14938---서강그라운드)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 코멘트](#2-코멘트-2)
  - [<a href="https://www.acmicpc.net/problem/21940" rel="nofollow">21940 - 가운데에서 만나기</a>](#21940---가운데에서-만나기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 코멘트](#2-코멘트-3)
  - [<a href="https://www.acmicpc.net/problem/17182" rel="nofollow">17182 - 우주 탐사선</a>](#17182---우주-탐사선)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 코멘트](#2-코멘트-4)
  - [<a href="https://www.acmicpc.net/problem/13168" rel="nofollow">13168 - 내일로 여행</a>](#13168---내일로-여행)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 코멘트](#2-코멘트-5)
  - [<a href="https://www.acmicpc.net/problem/1956" rel="nofollow">1956 - 운동</a>](#1956---운동)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 코멘트](#2-코멘트-6)
  - [<a href="https://www.acmicpc.net/problem/11562" rel="nofollow">11562 - 백양로 브레이크</a>](#11562---백양로-브레이크)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 코멘트](#2-코멘트-7)
  - [<a href="https://www.acmicpc.net/problem/1507" rel="nofollow">1507 - 궁금한 민호</a>](#1507---궁금한-민호)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
    - [2. 코멘트](#2-코멘트-8)
  - [<a href="https://www.acmicpc.net/problem/1719" rel="nofollow">1719 - 택배</a>](#1719---택배)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-9)
    - [2. 코멘트](#2-코멘트-9)
  - [<a href="https://www.acmicpc.net/problem/13314" rel="nofollow">13314 - 플로이드에 오타가?</a>](#13314---플로이드에-오타가)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-10)
    - [2. 코멘트](#2-코멘트-10)
  - [<a href="https://www.acmicpc.net/problem/23286" rel="nofollow">23286 - 허들 넘기</a>](#23286---허들-넘기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-11)
    - [2. 코멘트](#2-코멘트-11)
  - [<a href="https://www.acmicpc.net/problem/13141" rel="nofollow">13141 - Ignition</a>](#13141---ignition)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-12)
    - [2. 코멘트](#2-코멘트-12)
  - [<a href="https://www.acmicpc.net/problem/23258" rel="nofollow">23258 - 밤편지</a>](#23258---밤편지)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-13)
    - [2. 코멘트](#2-코멘트-13)
  - [<a href="https://www.acmicpc.net/problem/1602" rel="nofollow">1602 - 도망자 원숭이</a>](#1602---도망자-원숭이)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-14)
    - [2. 코멘트](#2-코멘트-14)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 12월  3일 토요일 12시 42분 56초 KST -->

<!--te-->

## [11404 - 플로이드](https://www.acmicpc.net/problem/11404)

### 1. 해결 핵심 아이디어

- 전형적인 플로이드 알고리즘 문제
- 최댓값으로 INT_MAX쓰면 INT_MAX + INT_MAX해서 오버플로 날 수도 있으니 INT_MAX대신 문제에서 주어진 조건들을 활용해 제일 긴 거리가 얼마인지 구해본다

### 2. 코멘트

- 최댓값으로 0x3f3f3f3f(10억) 쓰자

  ```cpp
    const int INF = 0x3f3f3f3f;
  ```

## [11780 - 플로이드 2](https://www.acmicpc.net/problem/11780)

### 1. 해결 핵심 아이디어

- 경로 복원하는 문제
- 테이블(nxt)을 하나 더 만들어서 경로를 저장해놓는다
- nxt 테이블은 현재 s번 정점에서 t번 정점로 갈 때의 중간 정점번호를 기억한다
- 초기값은 아무 정점도 거치지 않고 갈 때의 최단 거리이므로 서로 인접인 경우만 상대방의 번호를 적어 둔다 nxt[s][t] = t
- 1번 정점을 거쳐서 최단 경로가 되는 경우는 2 ↔ 3, 2 ↔ 4, 3 ↔ 4 경로인데, 해당 경로들은 기존의 s번 정점에서 t번 정점으로 가는 경로보다 s번 정점에서 1번 정점을 먼저 갔다가 1번 정점에서 t번 정점으로 가는 것이 효율적인 상황이므로 nxt[s][t] = nxt[s][1](if nxt[s][1] == 0이면 1)로 갱신한다(플로이드 알고리즘을 수행하면서 모든 s와 t에 대해 테이블을 채워준다)
- nxt 테이블을 이용해서 최단 경로 복원하는 방법
  - nxt[s][t] = x(s에서 t로 갈 때 x를 거쳐간다), nxt[x][t] = y(x에서 t로 갈 때 y를 거쳐간다), nxt[y][t] = z(y에서 t로 갈 때 z를 거쳐간다), … nxt[n][t] = t, 즉 t번 정점에 도착할 때까지 계속 타고 들어간다

### 2. 코멘트

- 패스

## [14938 - 서강그라운드](https://www.acmicpc.net/problem/14938)

### 1. 해결 핵심 아이디어

- 1. 임의의 정점에서 다른 모든 정점까지 최단거리 구한다 => 플로이드 알고리즘
- 2. 하나의 정점에서 다른 모든 정점까지 거리를 구해놓고, 수색범위에 들어온다면 그 지역의 아이템 획득
- 3. 2번 과정을 모든 정점에 대해서 반복한다
- 4. 최댓값 출력해준다

### 2. 코멘트

- 패스

## [21940 - 가운데에서 만나기](https://www.acmicpc.net/problem/21940)

### 1. 해결 핵심 아이디어

- 방향 그래프의 임의의 두 정점의 최단 거리를 구해줘야하는 문제
- 중간 도시를 x라하고, 친구들이 각각 A, B, C에 있다하면, d[A][x] + d[x][a], d[B][x] + d[x][b], d[C][x] + d[x][c] 중 최대값이 최소가 되어야하는 도시 x를 구해야하기 때문에 이 문제를 풀려면 모든 정점사이의 최단거리를 알아야한다
- x를 1부터 N까지 하나씩 보면서 c배열에 집어넣었던 친구들이 있는 도시와 x사이의 거리가 최대가 최소가 되는 도시 x를 찾는다
- 우선순위 큐에 구한 최댓값을 넣어준 다음 적절히 정답을 출력해주면 끝
- 주의할 점은 자기자신이 중간 도시 x가 될 수 있는데, 자기 자신으로 이동하는 거리는 0이므로 prunning시켜줬다

### 2. 코멘트

- 패스

## [17182 - 우주 탐사선](https://www.acmicpc.net/problem/17182)

### 1. 해결 핵심 아이디어

- 시작점이 정해져있고, 다른 모든 행성을 방문하는데 필요한 최단 거리의 합을 계산하는 문제이다
- 탐사 후 다시 시작 행성으로 돌아올 필요는 없으며 이미 방문한 행성도 중복해서 갈 수 있다는 조건이 붙었다
- 최단거리를 구하는데 중간 정점으로 이미 방문했던 행성을 이용할 수 있다 => 플로이드를 사용할 수 있다
- 시작점을 s라할 때 s에서 제일 가까운 행성 x, x에서 가까운 행성 y, ... 이런식으로 찾아서 그 거리의 합이 최소가 되어야한다
- 처음에는 단순히 플로이드 알고리즘을 수행한 후 시작점에서부터 제일 가까운 행성을 dist배열에서 선택한 후, 그 행성에서 다시 제일 가까운 행성, ...이런식으로 해서 모든 정점을 방문했을 때 종료시키게 했다, 뽑혔던 것만 계속 뽑힐 수 있어서 모든 행성이 뽑힐 수 있게 vis배열을 사용하여 이미 방문했던 행성은 방문하지 못하게하였다(그리디 알고리즘으로 접근했는데, 어떤 케이스에서 안되는지 찾지 못했다)
- 정답코드를 보니 백트래킹으로 모든 방문 경우의 수를 생성하여 최소를 찾았다(방문했던 건 방문 못하게, n과 m문제 처럼 시퀸스 생성해서)

### 2. 코멘트

- 이름이 같은 전역변수랑 지역변수가 있을 때 scope
  - 함수 내에서는 지역변수가 쓰이고, 만약 함수 내에서 전역변수를 사용하려면 ::(범위해결 연산자)를 사용해야한다

## [13168 - 내일로 여행](https://www.acmicpc.net/problem/13168)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [1956 - 운동](https://www.acmicpc.net/problem/1956)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [11562 - 백양로 브레이크](https://www.acmicpc.net/problem/11562)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [1507 - 궁금한 민호](https://www.acmicpc.net/problem/1507)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [1719 - 택배](https://www.acmicpc.net/problem/1719)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [13314 - 플로이드에 오타가?](https://www.acmicpc.net/problem/13314)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [23286 - 허들 넘기](https://www.acmicpc.net/problem/23286)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [13141 - Ignition](https://www.acmicpc.net/problem/13141)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [23258 - 밤편지](https://www.acmicpc.net/problem/23258)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [1602 - 도망자 원숭이](https://www.acmicpc.net/problem/1602)

### 1. 해결 핵심 아이디어

### 2. 코멘트
