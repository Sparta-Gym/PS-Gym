# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/11404" rel="nofollow">11404 - 플로이드</a>](#11404---플로이드)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 코멘트](#2-코멘트)
  - [<a href="https://www.acmicpc.net/problem/11780" rel="nofollow">11780 - 플로이드 2</a>](#11780---플로이드-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 코멘트](#2-코멘트-1)
  - [<a href="https://www.acmicpc.net/problem/14938" rel="nofollow">14938 - 서강그라운드</a>](#14938---서강그라운드)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 코멘트](#2-코멘트-2)
  - [<a href="https://www.acmicpc.net/problem/21940" rel="nofollow">21940 - 가운데에서 만나기</a>](#21940---가운데에서-만나기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 코멘트](#2-코멘트-3)
  - [<a href="https://www.acmicpc.net/problem/17182" rel="nofollow">17182 - 우주 탐사선</a>](#17182---우주-탐사선)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 코멘트](#2-코멘트-4)
  - [<a href="https://www.acmicpc.net/problem/13168" rel="nofollow">13168 - 내일로 여행</a>](#13168---내일로-여행)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 코멘트](#2-코멘트-5)
  - [<a href="https://www.acmicpc.net/problem/1956" rel="nofollow">1956 - 운동</a>](#1956---운동)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 코멘트](#2-코멘트-6)
  - [<a href="https://www.acmicpc.net/problem/11562" rel="nofollow">11562 - 백양로 브레이크</a>](#11562---백양로-브레이크)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 코멘트](#2-코멘트-7)
  - [<a href="https://www.acmicpc.net/problem/1507" rel="nofollow">1507 - 궁금한 민호</a>](#1507---궁금한-민호)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
    - [2. 코멘트](#2-코멘트-8)
  - [<a href="https://www.acmicpc.net/problem/1719" rel="nofollow">1719 - 택배</a>](#1719---택배)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-9)
    - [2. 코멘트](#2-코멘트-9)
  - [<a href="https://www.acmicpc.net/problem/13314" rel="nofollow">13314 - 플로이드에 오타가?</a>](#13314---플로이드에-오타가)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-10)
    - [2. 코멘트](#2-코멘트-10)
  - [<a href="https://www.acmicpc.net/problem/23286" rel="nofollow">23286 - 허들 넘기</a>](#23286---허들-넘기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-11)
    - [2. 코멘트](#2-코멘트-11)
  - [<a href="https://www.acmicpc.net/problem/13141" rel="nofollow">13141 - Ignition</a>](#13141---ignition)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-12)
    - [2. 코멘트](#2-코멘트-12)
  - [<a href="https://www.acmicpc.net/problem/23258" rel="nofollow">23258 - 밤편지</a>](#23258---밤편지)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-13)
    - [2. 코멘트](#2-코멘트-13)
  - [<a href="https://www.acmicpc.net/problem/1602" rel="nofollow">1602 - 도망자 원숭이</a>](#1602---도망자-원숭이)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-14)
    - [2. 코멘트](#2-코멘트-14)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 12월  3일 토요일 12시 42분 56초 KST -->

<!--te-->

## [11404 - 플로이드](https://www.acmicpc.net/problem/11404)

### 1. 해결 핵심 아이디어

- 전형적인 플로이드 알고리즘 문제
- 최댓값으로 INT_MAX쓰면 INT_MAX + INT_MAX해서 오버플로 날 수도 있으니 INT_MAX대신 문제에서 주어진 조건들을 활용해 제일 긴 거리가 얼마인지 구해본다

### 2. 코멘트

- 최댓값으로 0x3f3f3f3f(10억) 쓰자

  ```cpp
    const int INF = 0x3f3f3f3f;
  ```

## [11780 - 플로이드 2](https://www.acmicpc.net/problem/11780)

### 1. 해결 핵심 아이디어

- 경로 복원하는 문제
- 테이블(nxt)을 하나 더 만들어서 경로를 저장해놓는다
- nxt 테이블은 현재 s번 정점에서 t번 정점로 갈 때의 중간 정점번호를 기억한다
- 초기값은 아무 정점도 거치지 않고 갈 때의 최단 거리이므로 서로 인접인 경우만 상대방의 번호를 적어 둔다 nxt[s][t] = t
- 1번 정점을 거쳐서 최단 경로가 되는 경우는 2 ↔ 3, 2 ↔ 4, 3 ↔ 4 경로인데, 해당 경로들은 기존의 s번 정점에서 t번 정점으로 가는 경로보다 s번 정점에서 1번 정점을 먼저 갔다가 1번 정점에서 t번 정점으로 가는 것이 효율적인 상황이므로 nxt[s][t] = nxt[s][1](if nxt[s][1] == 0이면 1)로 갱신한다(플로이드 알고리즘을 수행하면서 모든 s와 t에 대해 테이블을 채워준다)
- nxt 테이블을 이용해서 최단 경로 복원하는 방법
  - nxt[s][t] = x(s에서 t로 갈 때 x를 거쳐간다), nxt[x][t] = y(x에서 t로 갈 때 y를 거쳐간다), nxt[y][t] = z(y에서 t로 갈 때 z를 거쳐간다), … nxt[n][t] = t, 즉 t번 정점에 도착할 때까지 계속 타고 들어간다

### 2. 코멘트

- 패스

## [14938 - 서강그라운드](https://www.acmicpc.net/problem/14938)

### 1. 해결 핵심 아이디어

- 1. 임의의 정점에서 다른 모든 정점까지 최단거리 구한다 => 플로이드 알고리즘
- 2. 하나의 정점에서 다른 모든 정점까지 거리를 구해놓고, 수색범위에 들어온다면 그 지역의 아이템 획득
- 3. 2번 과정을 모든 정점에 대해서 반복한다
- 4. 최댓값 출력해준다

### 2. 코멘트

- 패스

## [21940 - 가운데에서 만나기](https://www.acmicpc.net/problem/21940)

### 1. 해결 핵심 아이디어

- 방향 그래프의 임의의 두 정점의 최단 거리를 구해줘야하는 문제
- 중간 도시를 x라하고, 친구들이 각각 A, B, C에 있다하면, d[A][x] + d[x][a], d[B][x] + d[x][b], d[C][x] + d[x][c] 중 최대값이 최소가 되어야하는 도시 x를 구해야하기 때문에 이 문제를 풀려면 모든 정점사이의 최단거리를 알아야한다
- x를 1부터 N까지 하나씩 보면서 c배열에 집어넣었던 친구들이 있는 도시와 x사이의 거리가 최대가 최소가 되는 도시 x를 찾는다
- 우선순위 큐에 구한 최댓값을 넣어준 다음 적절히 정답을 출력해주면 끝
- 주의할 점은 자기자신이 중간 도시 x가 될 수 있는데, 자기 자신으로 이동하는 거리는 0이므로 prunning시켜줬다

### 2. 코멘트

- 패스

## [17182 - 우주 탐사선](https://www.acmicpc.net/problem/17182)

### 1. 해결 핵심 아이디어

- 시작점이 정해져있고, 다른 모든 행성을 방문하는데 필요한 최단 거리의 합을 계산하는 문제이다
- 탐사 후 다시 시작 행성으로 돌아올 필요는 없으며 이미 방문한 행성도 중복해서 갈 수 있다는 조건이 붙었다
- 최단거리를 구하는데 중간 정점으로 이미 방문했던 행성을 이용할 수 있다 => 플로이드를 사용할 수 있다
- 시작점을 s라할 때 s에서 제일 가까운 행성 x, x에서 가까운 행성 y, ... 이런식으로 찾아서 그 거리의 합이 최소가 되어야한다
- 처음에는 단순히 플로이드 알고리즘을 수행한 후 시작점에서부터 제일 가까운 행성을 dist배열에서 선택한 후, 그 행성에서 다시 제일 가까운 행성, ...이런식으로 해서 모든 정점을 방문했을 때 종료시키게 했다, 뽑혔던 것만 계속 뽑힐 수 있어서 모든 행성이 뽑힐 수 있게 vis배열을 사용하여 이미 방문했던 행성은 방문하지 못하게하였다

  - 최초로 직접 만든 반례!!
  - 그리디 기준으로 정해진 선택이 최적이 아님을 보이기 위해서 제일 가까운 정점을 선택하지 않았을 때 최적이 나오는 경우를 만들어보게됬음
  - 항상 현재 정점에서 제일 가까운 정점으로 방문하는게 최적이 아닐 수 있다

  ```text
  4 0
  0 2 1 2
  2 0 10 10
  1 10 0 2
  10 10 2 0

  ans: 7
  wrong: 8
  ```

  - 내가 처음으로 작성했던 그리디 알고리즘으로 위 케이스가 실행되면 0 -> 3(1) -> 4(3) -> 2(8)이 나오지만
  - 올바른 정답은 2를 갔다가(0에서 가장 가까운 정점이 아님) -> 3 -> 4순이 최적이다(7)

- 정답코드를 보니 백트래킹으로 모든 방문 경우의 수를 생성하여 최소를 찾았다(방문했던 건 방문 못하게, n과 m문제 처럼 시퀸스 생성해서)

### 2. 코멘트

- 이름이 같은 전역변수랑 지역변수가 있을 때 scope
- 함수 내에서는 지역변수가 쓰이고, 만약 함수 내에서 전역변수를 사용하려면 ::(범위해결 연산자)를 사용해야한다
- 그리디가 잘못됬을 때 반례만드는 법: 최적의 기준으로 선택한게 정답이 아닌 케이스를 만들어보기

## [13168 - 내일로 여행](https://www.acmicpc.net/problem/13168)

### 1. 해결 핵심 아이디어

- 모든 도시 간 최소 비용을 알기 위해 플로이드 알고리즘을 사용하여 최단 거리를 계산한다
- 내일로 티켓을 샀을 때와 사지 않았을 때를 각각 따로 저장하여 플로이드 알고리즘을 동시에 수행하였다
- 도시 이름이 문자열로 주어지는데 문자열로 처리하면 인덱싱이 까다로워서 도시마다 id를 부여하였고, 해시에 저장했다(이전에 어떤 문제에서 봤던 아이디어 적용)
- 문제에는 딱히 그런 코멘트가 없었는데, 예시를 볼 때 주어지는 여행하는 도시가 방문 순서이다(이것은 명확하지 않았는데 AC가 되는 것으로 보아 의도된 바인 것 같다)
- 50%할인이 있어서 가중치 배열을 double로 저장했다

### 2. 코멘트

- [함수 매개변수로 이차원배열 넘기는 법](https://dojang.io/mod/page/view.php?id=1969#:~:text=%ED%95%A8%EC%88%98%EC%97%90%EC%84%9C%202%EC%B0%A8%EC%9B%90%20%EB%B0%B0%EC%97%B4,%EA%B0%80%EB%A1%9C%20%ED%81%AC%EA%B8%B0%EB%A5%BC%20%EC%A7%80%EC%A0%95%ED%95%A9%EB%8B%88%EB%8B%A4.)

## [1956 - 운동](https://www.acmicpc.net/problem/1956)

### 1. 해결 핵심 아이디어

- 가중치 합이 최소인 사이클을 찾는 문제
- 처음에는 플로이드 알고리즘을 수행하고, 인접 리스트를 따로 저장하여 DFS를 이용하여 사이클 체크를 해주었다
  - 하지만 플로이드 알고리즘의 최단거리는 어떤 정점을 거쳐서 갱신됐는지 모르기 때문에 인접리스트를 통한 다음정점까지의 거리가 중간의 어느 정점을 거쳐서 방문한 것일 수도 있다, 할거면 간선에 가중치 저장한 다음 모든 시작점에서 DFS를 수행하는 방식으로 했어야한다, 그러면 플로이드도 필요없어진다(뭔 해괴망측한 방법이지?)
  - DFS로 했어도 시간초과는 안나지싶다 => O(V+E)
- 플로이드 알고리즘을 수행하면, 사이클을 찾을 수 있는데 방법은 dist[i][i]의 초기값을 INF로 두고, 플로이드 알고리즘을 수행 후 만약 이 값이 갱신되었다면 중간의 어느 정점을 거쳐서 다시 i로 돌아올 수 있다는 것을 의미 즉, 사이클을 의미한다
- 기존의 플로이드 알고리즘과 차이점은 dist[i][i]를 계산하지 않고 prunning했는데, 여기서는 prunning시키면 안되고, 초기값을 0대신 INF로 줘야함에 유의하자

### 2. 코멘트

- 플로이드 알고리즘으로 사이클 체크를 할 수 있다!

## [11562 - 백양로 브레이크](https://www.acmicpc.net/problem/11562)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [1507 - 궁금한 민호](https://www.acmicpc.net/problem/1507)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [1719 - 택배](https://www.acmicpc.net/problem/1719)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [13314 - 플로이드에 오타가?](https://www.acmicpc.net/problem/13314)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [23286 - 허들 넘기](https://www.acmicpc.net/problem/23286)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [13141 - Ignition](https://www.acmicpc.net/problem/13141)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [23258 - 밤편지](https://www.acmicpc.net/problem/23258)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [1602 - 도망자 원숭이](https://www.acmicpc.net/problem/1602)

### 1. 해결 핵심 아이디어

### 2. 코멘트
