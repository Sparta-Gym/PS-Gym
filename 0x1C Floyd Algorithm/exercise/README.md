# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/11404" rel="nofollow">11404 - 플로이드</a>](#11404---플로이드)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 코멘트](#2-코멘트)
  - [<a href="https://www.acmicpc.net/problem/11780" rel="nofollow">11780 - 플로이드 2</a>](#11780---플로이드-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 코멘트](#2-코멘트-1)
  - [<a href="https://www.acmicpc.net/problem/14938" rel="nofollow">14938 - 서강그라운드</a>](#14938---서강그라운드)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 코멘트](#2-코멘트-2)
  - [<a href="https://www.acmicpc.net/problem/21940" rel="nofollow">21940 - 가운데에서 만나기</a>](#21940---가운데에서-만나기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 코멘트](#2-코멘트-3)
  - [<a href="https://www.acmicpc.net/problem/17182" rel="nofollow">17182 - 우주 탐사선</a>](#17182---우주-탐사선)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 코멘트](#2-코멘트-4)
  - [<a href="https://www.acmicpc.net/problem/13168" rel="nofollow">13168 - 내일로 여행</a>](#13168---내일로-여행)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 코멘트](#2-코멘트-5)
  - [<a href="https://www.acmicpc.net/problem/1956" rel="nofollow">1956 - 운동</a>](#1956---운동)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 코멘트](#2-코멘트-6)
  - [<a href="https://www.acmicpc.net/problem/11562" rel="nofollow">11562 - 백양로 브레이크</a>](#11562---백양로-브레이크)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 코멘트](#2-코멘트-7)
  - [<a href="https://www.acmicpc.net/problem/1507" rel="nofollow">1507 - 궁금한 민호</a>](#1507---궁금한-민호)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
    - [2. 코멘트](#2-코멘트-8)
  - [<a href="https://www.acmicpc.net/problem/1719" rel="nofollow">1719 - 택배</a>](#1719---택배)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-9)
    - [2. 코멘트](#2-코멘트-9)
  - [<a href="https://www.acmicpc.net/problem/13314" rel="nofollow">13314 - 플로이드에 오타가?</a>](#13314---플로이드에-오타가)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-10)
    - [2. 코멘트](#2-코멘트-10)
  - [<a href="https://www.acmicpc.net/problem/23286" rel="nofollow">23286 - 허들 넘기</a>](#23286---허들-넘기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-11)
    - [2. 코멘트](#2-코멘트-11)
  - [<a href="https://www.acmicpc.net/problem/13141" rel="nofollow">13141 - Ignition</a>](#13141---ignition)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-12)
    - [2. 코멘트](#2-코멘트-12)
  - [<a href="https://www.acmicpc.net/problem/23258" rel="nofollow">23258 - 밤편지</a>](#23258---밤편지)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-13)
    - [2. 코멘트](#2-코멘트-13)
  - [<a href="https://www.acmicpc.net/problem/1602" rel="nofollow">1602 - 도망자 원숭이</a>](#1602---도망자-원숭이)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-14)
    - [2. 코멘트](#2-코멘트-14)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 12월  3일 토요일 12시 42분 56초 KST -->

<!--te-->

## [11404 - 플로이드](https://www.acmicpc.net/problem/11404)

### 1. 해결 핵심 아이디어

- 전형적인 플로이드 알고리즘 문제
- 최댓값으로 INT_MAX쓰면 INT_MAX + INT_MAX해서 오버플로 날 수도 있으니 INT_MAX대신 문제에서 주어진 조건들을 활용해 제일 긴 거리가 얼마인지 구해본다

### 2. 코멘트

- 최댓값으로 0x3f3f3f3f(10억) 쓰자

  ```cpp
    const int INF = 0x3f3f3f3f;
  ```

## [11780 - 플로이드 2](https://www.acmicpc.net/problem/11780)

### 1. 해결 핵심 아이디어

- 경로 복원하는 문제
- 테이블(nxt)을 하나 더 만들어서 경로를 저장해놓는다
- nxt 테이블은 현재 s번 정점에서 t번 정점로 갈 때의 중간 정점번호를 기억한다
- 초기값은 아무 정점도 거치지 않고 갈 때의 최단 거리이므로 서로 인접인 경우만 상대방의 번호를 적어 둔다 nxt[s][t] = t
- 1번 정점을 거쳐서 최단 경로가 되는 경우는 2 ↔ 3, 2 ↔ 4, 3 ↔ 4 경로인데, 해당 경로들은 기존의 s번 정점에서 t번 정점으로 가는 경로보다 s번 정점에서 1번 정점을 먼저 갔다가 1번 정점에서 t번 정점으로 가는 것이 효율적인 상황이므로 nxt[s][t] = nxt[s][1](if nxt[s][1] == 0이면 1)로 갱신한다(플로이드 알고리즘을 수행하면서 모든 s와 t에 대해 테이블을 채워준다)
- nxt 테이블을 이용해서 최단 경로 복원하는 방법
  - nxt[s][t] = x(s에서 t로 갈 때 x를 거쳐간다), nxt[x][t] = y(x에서 t로 갈 때 y를 거쳐간다), nxt[y][t] = z(y에서 t로 갈 때 z를 거쳐간다), … nxt[n][t] = t, 즉 t번 정점에 도착할 때까지 계속 타고 들어간다

### 2. 코멘트

- 패스

## [14938 - 서강그라운드](https://www.acmicpc.net/problem/14938)

### 1. 해결 핵심 아이디어

- 1. 임의의 정점에서 다른 모든 정점까지 최단거리 구한다 => 플로이드 알고리즘
- 2. 하나의 정점에서 다른 모든 정점까지 거리를 구해놓고, 수색범위에 들어온다면 그 지역의 아이템 획득
- 3. 2번 과정을 모든 정점에 대해서 반복한다
- 4. 최댓값 출력해준다

### 2. 코멘트

- 패스

## [21940 - 가운데에서 만나기](https://www.acmicpc.net/problem/21940)

### 1. 해결 핵심 아이디어

- 방향 그래프의 임의의 두 정점의 최단 거리를 구해줘야하는 문제
- 중간 도시를 x라하고, 친구들이 각각 A, B, C에 있다하면, d[A][x] + d[x][a], d[B][x] + d[x][b], d[C][x] + d[x][c] 중 최대값이 최소가 되어야하는 도시 x를 구해야하기 때문에 이 문제를 풀려면 모든 정점사이의 최단거리를 알아야한다
- x를 1부터 N까지 하나씩 보면서 c배열에 집어넣었던 친구들이 있는 도시와 x사이의 거리가 최대가 최소가 되는 도시 x를 찾는다
- 우선순위 큐에 구한 최댓값을 넣어준 다음 적절히 정답을 출력해주면 끝
- 주의할 점은 자기자신이 중간 도시 x가 될 수 있는데, 자기 자신으로 이동하는 거리는 0이므로 prunning시켜줬다

### 2. 코멘트

- 패스

## [17182 - 우주 탐사선](https://www.acmicpc.net/problem/17182)

### 1. 해결 핵심 아이디어

- 시작점이 정해져있고, 다른 모든 행성을 방문하는데 필요한 최단 거리의 합을 계산하는 문제이다
- 탐사 후 다시 시작 행성으로 돌아올 필요는 없으며 이미 방문한 행성도 중복해서 갈 수 있다는 조건이 붙었다
- 최단거리를 구하는데 중간 정점으로 이미 방문했던 행성을 이용할 수 있다 => 플로이드를 사용할 수 있다
- 시작점을 s라할 때 s에서 제일 가까운 행성 x, x에서 가까운 행성 y, ... 이런식으로 찾아서 그 거리의 합이 최소가 되어야한다
- 처음에는 단순히 플로이드 알고리즘을 수행한 후 시작점에서부터 제일 가까운 행성을 dist배열에서 선택한 후, 그 행성에서 다시 제일 가까운 행성, ...이런식으로 해서 모든 정점을 방문했을 때 종료시키게 했다, 뽑혔던 것만 계속 뽑힐 수 있어서 모든 행성이 뽑힐 수 있게 vis배열을 사용하여 이미 방문했던 행성은 방문하지 못하게하였다

  - 최초로 직접 만든 반례!!
  - 그리디 기준으로 정해진 선택이 최적이 아님을 보이기 위해서 제일 가까운 정점을 선택하지 않았을 때 최적이 나오는 경우를 만들어보게됬음
  - 항상 현재 정점에서 제일 가까운 정점으로 방문하는게 최적이 아닐 수 있다

  ```text
  4 0
  0 2 1 2
  2 0 10 10
  1 10 0 2
  10 10 2 0

  ans: 7
  wrong: 8
  ```

  - 내가 처음으로 작성했던 그리디 알고리즘으로 위 케이스가 실행되면 0 -> 3(1) -> 4(3) -> 2(8)이 나오지만
  - 올바른 정답은 2를 갔다가(0에서 가장 가까운 정점이 아님) -> 3 -> 4순이 최적이다(7)

- 정답코드를 보니 백트래킹으로 모든 방문 경우의 수를 생성하여 최소를 찾았다(방문했던 건 방문 못하게, n과 m문제 처럼 시퀸스 생성해서)

### 2. 코멘트

- 이름이 같은 전역변수랑 지역변수가 있을 때 scope
- 함수 내에서는 지역변수가 쓰이고, 만약 함수 내에서 전역변수를 사용하려면 ::(범위해결 연산자)를 사용해야한다
- 그리디가 잘못됬을 때 반례만드는 법: 최적의 기준으로 선택한게 정답이 아닌 케이스를 만들어보기

## [13168 - 내일로 여행](https://www.acmicpc.net/problem/13168)

### 1. 해결 핵심 아이디어

- 모든 도시 간 최소 비용을 알기 위해 플로이드 알고리즘을 사용하여 최단 거리를 계산한다
- 내일로 티켓을 샀을 때와 사지 않았을 때를 각각 따로 저장하여 플로이드 알고리즘을 동시에 수행하였다
- 도시 이름이 문자열로 주어지는데 문자열로 처리하면 인덱싱이 까다로워서 도시마다 id를 부여하였고, 해시에 저장했다(이전에 어떤 문제에서 봤던 아이디어 적용)
- 문제에는 딱히 그런 코멘트가 없었는데, 예시를 볼 때 주어지는 여행하는 도시가 방문 순서이다(이것은 명확하지 않았는데 AC가 되는 것으로 보아 의도된 바인 것 같다)
- 50%할인이 있어서 가중치 배열을 double로 저장했다

### 2. 코멘트

- [함수 매개변수로 이차원배열 넘기는 법](https://dojang.io/mod/page/view.php?id=1969#:~:text=%ED%95%A8%EC%88%98%EC%97%90%EC%84%9C%202%EC%B0%A8%EC%9B%90%20%EB%B0%B0%EC%97%B4,%EA%B0%80%EB%A1%9C%20%ED%81%AC%EA%B8%B0%EB%A5%BC%20%EC%A7%80%EC%A0%95%ED%95%A9%EB%8B%88%EB%8B%A4.)

## [1956 - 운동](https://www.acmicpc.net/problem/1956)

### 1. 해결 핵심 아이디어

- 가중치 합이 최소인 사이클을 찾는 문제
- 처음에는 플로이드 알고리즘을 수행하고, 인접 리스트를 따로 저장하여 DFS를 이용하여 사이클 체크를 해주었다
  - 하지만 플로이드 알고리즘의 최단거리는 어떤 정점을 거쳐서 갱신됐는지 모르기 때문에 인접리스트를 통한 다음정점까지의 거리가 중간의 어느 정점을 거쳐서 방문한 것일 수도 있다, 할거면 간선에 가중치 저장한 다음 모든 시작점에서 DFS를 수행하는 방식으로 했어야한다, 그러면 플로이드도 필요없어진다(뭔 해괴망측한 방법이지?)
  - DFS로 했어도 시간초과는 안나지싶다 => O(V+E)
- 플로이드 알고리즘을 수행하면, 사이클을 찾을 수 있는데 방법은 dist[i][i]의 초기값을 INF로 두고, 플로이드 알고리즘을 수행 후 만약 이 값이 갱신되었다면 중간의 어느 정점을 거쳐서 다시 i로 돌아올 수 있다는 것을 의미 즉, 사이클을 의미한다
- 기존의 플로이드 알고리즘과 차이점은 dist[i][i]를 계산하지 않고 prunning했는데, 여기서는 prunning시키면 안되고, 초기값을 0대신 INF로 줘야함에 유의하자

### 2. 코멘트

- 플로이드 알고리즘으로 사이클 체크를 할 수 있다!

## [11562 - 백양로 브레이크](https://www.acmicpc.net/problem/11562)

### 1. 해결 핵심 아이디어

- 이 문제는 한참 고민해봤는데, 아이디어가 떠오르지 않아서 바로 정답코드를 참조하였다
- 지날 수 있는 방향은 비용을 0으로두고, 지나갈 수 없는 방향은 비용을 1로 둔다
- 플로이드 알고리즘을 적용하면 u에서 v로 갈 때 거치는 길들 중에서, 지날 수 없는 방향으로 통과하는 길의 수를 최소화할 수 있다
- 이는 곧 양방향으로 바꿔야 하는 길의 최소 개수가 된다

### 2. 코멘트

- 간선이 끊겼다면 가상의 간선을 만들어보는 건 어떨까?
- 뭔가 1956번도 그렇고 이 문제도 그렇고 dfs풀어야할 것 같은 느낌이 많이 드네

## [1507 - 궁금한 민호](https://www.acmicpc.net/problem/1507)

### 1. 해결 핵심 아이디어

- 임의의 두 정점을 잇는 모든 간선이 있다고 간주하고 필요 없는 간선을 제거해야한다
- 필요 없다는 의미는 u에서 v로 가는 최단 경로가 유일하지 않고 여러 개 존재할 때 1개를 제외한 나머지는 필요 없다는 것이다
- 임의의 두 정점 u, v를 잇는 간선이 입력으로 주어지는 최소 비용을 갖고, 폴로이드 알고리즘을 수행하면서 u에서 중간의 어떤 정점 k를 거쳐서 v로 가는 비용을 계산했을 때 다이렉트 간선의 최소비용과 같다면 (u, v)는 필요가 없어지므로 제거해도 무방하다
- 제거를 했는데 다른데서 필요하면 어쩌냐? 할 수 있는데 그걸 같은 비용으로 대체할 수 있으니(k를 거쳐가는 경로) 제거한 것이므로 제거해도 무방하다
- 최소 도로의 수는 이 모든 필요없는 도로를 제거하고 남은 간선을 의미한다

### 2. 코멘트

- 패스

## [1719 - 택배](https://www.acmicpc.net/problem/1719)

### 1. 해결 핵심 아이디어

- 경로 복원 테이블 구현하는 문제
- 초기에는 서로 인접한 정점끼리만 값을 채울 수 있다, nxt[s][t] = t(s와 t는 서로 인접 정점관계임)
- 플로이드 알고리즘을 진행하면서 중간 정점 k를 통해서 가는 경로가 발견됬을 때, 시작정점 i에서 k로 갈 때 처음 거치는 정점인 nxt[i][k]의 값으로 nxt[i][j]를 갱신해준다

### 2. 코멘트

- 패스

## [13314 - 플로이드에 오타가?](https://www.acmicpc.net/problem/13314)

### 1. 해결 핵심 아이디어

- 첫 번째 코드의 문제는 중간 정점에 N번 정점이 포함되지 않는 것이었다
- 그럼 이 코드가 통과되지 못하려면 N번 정점을 중간지점으로 하는 경로가 최단 경로가 9700개 이상 나와야한다는 결론이 나온다
- 그래서 내가 생각한 아이디어는 인접행렬을 dist[i][n] = 0(1 <= i <= N)이고, 이외에 나머지는 1로 설정하여 모든 정점 사이의 경로가 N번 정점을 거쳐야 최단경로가 되는 데이터를 만들었다
- 정점의 개수는 100개여야한다 정답과 이 오타가 있는 코드는 잘못된 정답을 $(N-1)^2$ 개 내게되는데 99부터는 9700보다 적게 나오기때문이다(D[i][j] (i, j != N)인 정점이 잘못된 정답을 내게된다)

### 2. 코멘트

- 패스

## [23286 - 허들 넘기](https://www.acmicpc.net/problem/23286)

### 1. 해결 핵심 아이디어

- 이 문제는 최단 경로를 구하는 것이 아닌 모든 정점 간의 경로 상에서 제일 가중치가 큰 간선을 찾는 문제였다
- k를 거쳐서 u에서 v로 갈 수 있는 경로를 플로이드 알고리즘을 이용해서 모두 살펴보고, 그 중 가장 가중치가 큰 간선을 저장해주면된다

### 2. 코멘트

- 패스

## [13141 - Ignition](https://www.acmicpc.net/problem/13141)

### 1. 해결 핵심 아이디어

- 시작점에서 각 정점에 언제 처음 도달하는지(불이 붙는지)알기 위해 플로이드 알고리즘 사용
- 시작점에서 다시 시작점으로 돌아오는 경로 중 가장 긴 경로(이하 MX_PATH)를 일직선으로 펴서 생각해봤다(제일 늦게 타는 걸 봐야하므로)
  [참고한 블로그](https://justicehui.github.io/ps/2021/08/25/BOJ13141/)

  ![설명](https://user-images.githubusercontent.com/48282185/206367847-eee89ce1-5740-4e83-942b-58c209da3e46.png)

- 모든 시작점에서 제일 늦게 타기 시작하는 간선이 언제 다 탈 수 있는지를 봐야한다
- 제일 늦게 타기 시작하는 경로를 시작 - u - v - 시작이라고 했을 때 이 경로가 모두 타기 위해선 ($x^{'}$ + $x^{''}$ + $x$) / 2를 해줘야한다
- 양쪽에서 동시에 출발하기 때문에 매초마다 2칸씩 없어지기 때문이다

### 2. 코멘트

- 어렵지만 배울 점이 많았던 문제였다

## [23258 - 밤편지](https://www.acmicpc.net/problem/23258)

### 1. 해결 핵심 아이디어

- 이 문제는 x번 정점에 $2^x$ 의 이슬이 있고, x번 정점을 거쳐가면 이 이슬을 모두 먹어야한다, 근데 x의 상한이(n의 상한이) 300이라 이건 저장할 수 없다
- 그래서 뭔가 특별한 지수 법칙이 필요함을 떠올렸고, 등비수열의 합 공식을 생각했다
  - $2^{1}\ +\ 2^{2}\ +\ 2^{3}\ +\ ...\ +\ 2^{c-1}$ = $2^{c} - 2$ < $2^c$이다
- 즉 상수 c를 갖는 반딧불이 s에서 e로 가기위해선 c-1개의 중간정점을 거쳐야한다는 결론이 나온다(등비수열까진 생각했는데 저 식이 긴가민가해서 여기까지 논리가 못 펼쳐짐..)
- 최단경로 테이블을 3차원으로 만들고, 3차원에는 거쳐온 중간정점 갯수를 저장시켜주자
- 점화식을 써보면 다음과 같다
  - dist[i][j][k] = k개 이하의 중간정점을 거쳐서 i에서 j로 가는 최단 경로
  - dist[i][j][k] = min(dist[i][j][k - 1], dist[i][k][k - 1] + dist[k][j][k - 1])
  - i에서 j를 갈 때 k개 이하의 중간 정점을 거치는 최단거리는 i에서 j로 올 때 k-1개의 중간 정점을 거친 최단거리와 중간정점 k를 통해서 최단거리가 갱신이 될 경우를 비교해줘야한다(이 경우 중간정점 k가 추가된다)

### 2. 코멘트

- 패스

## [1602 - 도망자 원숭이](https://www.acmicpc.net/problem/1602)

### 1. 해결 핵심 아이디어

- 이 문제는 매우 어려워서 이해하는데 한참 걸렸다
- 정점에도 가중치가 있기때문에 플로이드 알고리즘을 수행하면서 살펴보는 중간 정점의 순서가 기존에는 1 ~ n이었다면, 이 문제는 정점의 가중치가 적은 순서대로 살펴봐야한다
- 기존대로 순차적으로 살펴보지 않고 가중치가 적은 순서대로 살펴봐야하는 이유는 이 문제에서는 최단거리에다가 이 경로를 거치는 정점들 중 가장 큰 패널티값까지 더해야 하고 그 결과들 중 가장 작은 걸 찾아야 하는데, 경로 중에서 가장 큰 패널티값이 문제이다, k번째로 패널티가 작은 정점을 사용해서 최단거리 및 dp테이블을 갱신하면 dp[i][j]를 k로 우회하는 경로로 갱신할 때 max(attack_cost[i],max(attack_cost[j],attack_cost[k])) 구문처럼 i, j, k의 패널티 정보만 가지고도 갱신할 수 있게 된다. 왜냐면 i, j, k 정점의 패널티 중 최댓값만 보아도, 이 경로상에서 가장 큰 패널티값을 알 수 있기 때문이다 지금까지는 k보다도 패널티가 적은 정점들만을 사용해서 최단거리를 갱신해 왔으므로, 만약 이번에 k를 추가로 지나서 새로운 최단 경로를 갱신한다면 그 경로상의 정점들 중 가장 패널티가 큰 정점이 k일 것이기 때문이다
- [참고한 질문탭 글](https://www.acmicpc.net/board/view/8589)
- 이 문제를 통해 배운점은 정점에 가중치가 있을 때 중간 정점 방문 순서를 가중치 오름차순이나 내림차순을 이용해서 바꿀 수 있다는 것
- 어떤 경로상에서 제일 큰 값을 찾기 위해 내림차순으로 정렬하여 작은 것부터 차례대로 살펴봐서 갱신해나간다는 점, 이렇게 함으로서 봐야하는 경우의 수가 주는 것

### 2. 코멘트

- 이건 이해가 제대로 됬나 긴가민가하다, 나중에 꼭 다시 보기
