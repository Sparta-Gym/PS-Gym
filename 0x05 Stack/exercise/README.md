# Learning About

## [10828 - 스택](https://www.acmicpc.net/problem/10828)

### 1. 해결 핵심 아이디어

- 스택의 대표 연산을 잘 이해한다

### 2. 풀이

- 5개의 연산에 대한 쿼리를 적절히 구현하면 된다

## [10773 - 제로](https://www.acmicpc.net/problem/10773)

### 1. 해결 핵심 아이디어

- 가장 최근의 수를 지운다는 점에서 제일 적절한 자료구조는 스택이다

### 2. 풀이

- 0이 나오면 pop해서 지워주면 됨

## [1874 - 스택 수열](https://www.acmicpc.net/problem/1874)

### 1. 해결 핵심 아이디어

- push하는 순서가 오름차순을 지켜야하므로 pop되는 순서는 즉, 입력은 내림차순으로 구성된 부분수열이어야 한다, 입력과 출력이 거꾸로란 이야기이다
- 문제에서 대놓고 스택이라고 알려주기 때문에 스택을 이용해야한다는 것을 떠올릴 필요가 없음

### 2. 풀이

1. 입력 elem에 대해 cur(초기값은 1)부터 elem까지 스택에 쌓고, 정답에 +를 추가한다

- cur은 어디까지 쌓였는지 확인하는 용도로 다음에 쌓을 때 이용함
- 만약 4까지 쌓았다면 cur은 다음 쌓을 수일 5를 가리킨다

2. 다음 입력을 확인하고, cur보다 입력이 크다면 1번 과정을 반복하고, 반대의 경우 아무것도 하지 않는다 입력의 원소 하나가 의미하는 것은 스택에서 pop되어 스택 수열의 원소가 된 것이므로, pop하고 top이 입력과 같은지 확인한다 만약 다르다면 오름차순이 아닌 것이므로 스택수열 일 수 없으므로 NO를 출력한다, 같으면 정답에 -를 추가한다

3. 모든 입력에 대해 NO인 경우가 없었다면, 정상적인 스택 수열이다

## [2493 - 탑](https://www.acmicpc.net/problem/2493)

### 1. 해결 핵심 아이디어

- 이 문제를 제일 쉽게 풀 수 있는 idea는 2중 for문을 돌면서 현재 보고 있는 원소보다 큰 원소가 나올 때까지 찾는 것인데, N의 크기로 보아 O($N^2$)으로는 시간초과가 날 것을 예상할 수 있다
- 문제 자체는 단순한데 Gold V 정도의 난이도가 매겨진 이유는 문제만 읽고 스택을 사용해야되는 것인지 감을 잡기 어렵기 때문인 것 같고, 나 또한 스택이라는 것을 모르고 풀었으면, 스택을 이용해서 풀었을 지 의문이다
- 제일 상단이 아닌 나머지 원소들의 확인/변경이 원칙적으로 불가능하기 때문에 각 탑을 입력받을 때, 이전에 나온 탑이 `현재 입력 탑보다 크면서, 제일 늦게 들어온 값이어야한다.` 이 점을 캐치하면, 스택을 사용해야함을 어렴풋이 짐작할 수 있다

### 2. 풀이

- 스택의 top을 입력으로 들어오는 탑들을 커버할 수 있는 탑으로 본다, 다시 말해 top보다 작으면, top이 커버할 수 있는 탑이므로 쌓는다
- 만약 top보다 input이 크다면, 이제 top으로 커버 불가능하므로, 커버 가능한 top이 나올 때까지 pop한다
- 탑은 번호와 높이 두 쌍의 정보를 가지고 있어야한다, 그러므로 pair로 관리한다

### 3. 구현팁

- 모든 탑을 커버할 수 있는 관념적 탑을 쌓고 시작함으로써 구현을 편하게 할 수 있다
- 관념적 탑이 없다고 생각하면 스택이 비어있을 때 처리가 까다롭다

## [6198 - 옥상 정원 꾸미기](https://www.acmicpc.net/problem/6198)

### 1. 해결 핵심 아이디어

- 현재 들어가는 input과 바로 이전의 input의 대소 관계를 비교해야하는 점에서 스택으로 풀어야하는 문제임을 알 수 있다
- 2493번 탑 문제와 굉장히 유사하지만 합을 구하는 것이므로 각 탑이 몇 개를 내다볼 수 있는지 저장하지 않아도 된다는 점과 서로 바라 보는 방향이 반대라는 점에서 차이가 있다
- 스택에서는 top() 이외에 참조가 불가능하므로 각 스텝에서 이전에 나왔던 건물들이 현재 건물을 쳐다 볼 수 있는지를 파악하고 합에 누적시켜주면 되는데, '이전까지 몇 개가 쌓였는가?'를 알려면 '현재 스택에 몇 개가 쌓여있는가?'를 보면 된다
- 10 3 7 처럼 3이 중간에 껴있으면 누적시키고, 스택에서 빼야한다 빼지 않으면, 3이 7을 볼 수 있는 잘못된 경우가 나오기 때문

### 2. 풀이

- 매 단계마다 들어오는 input을 스택에 push한다
- top() <= input이면 pop시킨다
- push 전에 합계에 스택 사이즈를 누적하여 더한다

### 3. 주의 사항

- 스택이 비었을 때, pop시킬 수 있으니 !empty() 조건을 추가해야한다

## [17298 - 오큰수](https://www.acmicpc.net/problem/17298)

### 1. 해결 핵심 아이디어

- 오른쪽에 있으면서 $A_i$보다 큰 수 중 가장 왼쪽에 있는 것, 오른쪽에 있다 == 스택에 쌓여있다, 가장 왼쪽 == top(), 가장 왼쪽이라는 조건과 이전에 쌓였던 정보들이 현재 input과 관계가 있을 수 있어(오큰수 관계) 이 문제가 스택을 써야한다는 것을 추측할 수 있다
- 6198 옥상 문제와 동일한 논리를 적용하면 되는데, 스택에 쌓인 수들이 몇 번째 들어왔는지 기억해놔야된다는 점

### 2. 풀이

- 매 단계마다 들어오는 input을 스택에 push한다
- top() <= input이면 pop시킨다
- 각 스텝에서 pop되는 원소들의 오큰수는 input이므로 pop하면서 오큰수 배열에 input을 기록해놓는다

### 3. 주의 사항

- 스택이 비었을 때, pop시킬 수 있으니 !empty() 조건을 추가해야한다

### 4. 구현 팁

- 이 문제처럼 원소의 입력 순서가 중요할 때 pair를 이용해서 순서와 값을 같이 저장하면 편하다

## [3015 - 오아시스 재결합](https://www.acmicpc.net/problem/3015)

- 줄 서 있는(순서 있는) 상황에서 자기 보다 앞에 있는 것들 중 처음으로 자기보다 큰 게 나올 때까지 경우의 수가 생성됨
- 자기 보다 앞에 있는 것들 중 처음이라는 조건 때문에 스택을 사용해야된다는 것을 추측할 수 있다
- 이 문제에서 관건은 서로 쳐다볼 수 있는 쌍의 수를 구하는 것인데, 앞서 봤던 문제들과는 달리 양방향에서 쳐다볼 수 있다는 조건이 나오는데, 다른 말로하면 스택에 쌓여있는 특정 원소와 현재 들어오는 input사이에 이 둘 보다 큰 게 없어야 한다, 앞서 봤던 문제들과는 다른 처리 방식이 필요함

### 2. 풀이

- 스택에 쌓여있는 원소 A와 현재 들어온 input B 사이에 큰 게 없어야하므로, top() <= input인 경우 pop시킨다.
- push 할 때, 스택이 비어있지 않으면서(쌍이 생기려면 원소가 2개 이상), top > input인 경우 쌍의 수를 증가시킨다, (top, input)
- pop할 때도 쌍의 수를 증가시켜줘야한다 input이전에 쌓인 원소들 간의 쌍들의 경우
- 이 문제가 까다로운 점은 높이가 같을 때를 고려해야하기 때문인데, 이 점을 고려 못해서 실제로 틀리기도 했다

  - 문제에서는 A와 B가 서로 볼 수 있으려면 두 사람 사이에 A 또는 B보다 키가 큰 사람이 없어야 된다고 했다, 중간에 B와 같은 높이가 있어도 무방하다
  - 4 1 2 2 2을 예시로 해보자
  - 2끼리는 서로 쳐다볼 수 있다
  - 단순히 !s.empty() and s.top() <= input으로 ans++을 하면, 세 번째 2와 다섯 번째 2의 쌍을 고려하지 못한다(오답 원인)
  - 그래서 pop하면서 같은 높이가 연속되는 경우를 처리해줘야하는데, 세 번째 2와 쌍을 이루는 세 번째 2 왼쪽의 원소들과 네 번째, 다섯 번째 2도 쌍을 이룬다
  - 세 번째 2가 4와 쌍을 이루면, 네 번째 다섯 번째 2도 4와 쌍을 이루므로, 세 번째 2를 pop하면서, 그것과 쌍을 이루는 수를 기억해뒀다가 네 번째 2와 쌍을 이루는 수에 누적시켜야한다
  - top의 원소밖에 참조 못하는다는 스택의 특성 때문에 중간원소를 참조못한다, but 문제를 풀려면 각 사람이 자신과 이루는 쌍의 수가 저장되어야하기에, pair를 써서 기록해둔다(사람의 높이로 쌍이 되는지 보는 것이기 때문에 키는 스택으로 관리되어야하고, 보조 정보로 쌍의 수가 저장되어야함)

  ```cpp
     int height, cnt = 1;
    cin >> height;
    while (!s.empty() && s.top().first <= height) {
      if (s.top().first == height) cnt += s.top().second;
      ans += s.top().second;
      s.pop();
    }
    if (!s.empty() && s.top().first > height) ans++;
    s.push({height, cnt});
  ```

## [6549 - 히스토그램에서 가장 큰 직사각형](https://www.acmicpc.net/problem/6549)

### 1. 해결 핵심 아이디어

### 2. 풀이
