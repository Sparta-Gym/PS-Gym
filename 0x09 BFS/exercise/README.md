# Learning About

## [1926 - 그림](https://www.acmicpc.net/problem/1926)

### 1. 해결 핵심 아이디어

- 문제에서 자명하게 가로나 세로로 1이 연결돼있는 것을 영역이라고 지정해주어 쉽게 flood fill 문제임을 파악할 수 있다
- flood fill 문제는 BFS나 DFS를 통해서 해결할 수 있다, 노드를 정확히 한 번씩만 방문하기 때문에 영역의 크기는 물론 모든 노드를 방문하기 때문에 영역과 그것이 아닌 것을 구분지을 수 있다

### 2. 풀이

- 이차원배열에서 1이 나올 때마다 큐에 넣고 BFS를 돌리되, 이미 방문한 정점일 수 있으므로 방문배열을 보고 아직 미방문 노드만 큐에 넣는다
- 미방문 노드라면 큐에 넣고 방문 여부 체크를 해준다
- bfs의 수행횟수가 영역의 갯수가 된다
  - 시작점의 갯수 = 영역의 갯수

## [2178 - 미로 탐색](https://www.acmicpc.net/problem/2178)

### 1. 해결 핵심 아이디어

- 시작점과 도착점이 주어지고, 이 둘 사이의 최단 거리를 구하는 문제이다
- 인접 노드로 갈 때 가중치가 이동 거리 1이므로 모든 간선의 가중치는 1이고, BFS를 사용해서 최단거리를 구할 수 있는데, 이는 한 노드가 방문 처리될 때 이 노드의 모든 인접노드가 큐에 들어가기 때문에 최단 거리를 구할 수 있는 것이다

### 2. 풀이

- 한 줄단위로 입력되기에 string타입의 배열을 만들어서 한 줄씩 입력받는다
- 최단 거리를 구할 때는 방문배열 대신 거리 배열을 만들어서 -1로 초기화한 다음, 큐에 넣고, u를 지금 보고있는 노드, v를 u의 인접노드라고 할 때, dist[v] = dist[u] + 1가 되게 만들어놓으면, dist배열에는 시작점으로부터 각 정점까지의 최단거리가 저장된다, dist 배열로 방문여부 체크를 할 수 있는데, 이미 거리가 계산돼있다면, 방문했던 것으로 간주할 수 있기 때문이다
- dist[도착점]을 출력하면 끝

## [7576 - 토마토](https://www.acmicpc.net/problem/7576)

### 1. 해결 핵심 아이디어

- 시작점이 여러 개일 때 BFS를 응용해서 최단 거리를 구하는 문제이다
- 익은 토마토가 익지 않은 인접 토마토를 익게하는데 하루가 걸린다는 점에서 최단 거리를 구하는 문제라는 것을 알 수 있다
- 일반적인 BFS문제와는 다르게 갈 수 없는 포인트를 -1, 아직 안 간 포인트를 0, 시작점을 1로 구분해주기에 BFS를 사용하더라도 시간 제한 내에 들어올 수 있다는 점을 알 수 있다
- 어떤 시작점으로 부터 제일 멀리떨어져 있는 포인트까지의 거리가 모든 토마토가 익는데 걸리는 최소 일수이고, 모든 토마토가 익지 못하는 경우도 주어질 수 있으므로 토마토가 있는 포인트의 dist가 과정이 끝나고도 -1이면 그것이 익지 못한 토마토이므로 -1을 출력해준다

### 2. 풀이

- 이차원배열을 입력받으면서 1이 나오는 것을 모두 큐에 집어넣는다
- 모두 입력받고 BFS를 돌린다, 이러면 각 영역의 시작점에서 시작되기에 모든 영역을 탐색할 수 있다
- 어떤 포인트가 여러 개의 영역의 교점이 될 수도 있는데, 그 포인트를 먼저 포함시키는 영역에 들어가야 최단 거리를 구할 수 있다
- dist에서 제일 큰 값을 뽑아내되, dist내에 -1이 있다면, 불가능한 케이스이므로 -1 출력한다

## [4179 - 불!](https://www.acmicpc.net/problem/4179)

### 1. 해결 핵심 아이디어

- 시작점이 두 종류일 때 BFS를 응용해서 최단 거리를 구하는 문제이다
- 이 문제의 특이점은 out of bound일 때 미로를 탈출했다고 간주한다는 점이다
- 불이 붙은 곳은 사람이 갈 수 없는데, 불이 붙기전에 사람이 이동할 수 있는 포인트인지 판단은 불을 시작점으로 하는 BFS를 돌려 최단 거리를 구해놓고, 이후 사람을 시작점으로 하는 BFS를 돌려 최단 거리를 구한다. 어떤 포인트에 대해 불을 시작점으로 하는 최단 거리 > 사람을 시작점으로 하는 최단 거리일 때, 불이 붙기 전에 사람이 올 수 있는 포인트임을 의미한다

### 2. 풀이

- 문자열로 입력 받는다, 입력 이후 불의 시작점, 사람의 시작점을 큐에 넣는다
- 불에 대한 BFS를 돌고, 그 이후 사람에 대한 BFS를 돈다
- 불에 대한 BFS는 일반 BFS와 같지만 사람에 대한 BFS는 out of bound가 됬을 때, 결과를 출력하고, `fire[nx][ny] != -1 && fire[nx][ny] <= escape[cur.x][cur.y] + 1` 일 때 continue시키는데, 불은 못가는데 사람은 갈 수 있는 포인트이거나(불이 없는 경우도 주어짐) 둘 다 갈수있는데, 사람이 더 빨리 올 수 있는 포인트만 밟으면서 탈출할 수 있음을 의미한다
- BFS가 끝날 때까지 탈출못했으면, IMPOSSIBLE 출력해주면 된다

## [1697 - 숨바꼭질](https://www.acmicpc.net/problem/1697)

### 1. 해결 핵심 아이디어

- 일차원 직선에서 BFS를 응용해서 최단 거리를 구하는 문제이다
- 이차원 배열에서 인접이 동서남북이었다면, 여기서는 문제에서 정의된 대로 -1, +1, \*2가 인접이 된다

### 2. 풀이

- 목표 포인트인 k에 도달하면 BFS를 끝내고, dist[k]를 출력한다

## [1012 - 유기농 배추](https://www.acmicpc.net/problem/1012)

### 1. 해결 핵심 아이디어

- flood fill 문제로 영역의 개수를 구하면 된다

### 2. 풀이

- 배추가 심어진 포인트를 입력 받은 후 이차원배열 돌면서 1인 포인트를 시작점으로 BFS를 돌 되, 방문한 포인트라면 건너뛴다

## [10026 - 적록색약](https://www.acmicpc.net/problem/10026)

### 1. 해결 핵심 아이디어

- flood fill 문제로 영역의 개수를 구하는 문제인데, 두 가지 케이스가 주어진다
- 적록색약의 경우 R과 G를 같은 것으로 인식, 아니면 R과 G를 다른 것으로 인식한다
- 두 경우에 대해 next point를 체크할 때 조건만 달리해주면 쉬운 문제

### 2. 풀이

- R, G, B 각각에 대해 시작점으로 간주하고 큐에 넣되, 이미 방문한 경우는 넣지 않는다
- 색약인 경우와 아닌 경우 논리를 달리 짜주고, 각각 BFS를 돌리고 영역의 개수 구하고 출력하면 끝

## [7569 - 토마토](https://www.acmicpc.net/problem/7569)

### 1. 해결 핵심 아이디어

- 7576과 삼차원 배열에서 BFS를 수행한다는 점이 차이이외에는 동일하다
- 삼차원도 이차원과 별다를게 없다, 인접이 상하동서남북 여섯개로 늘어난 것 뿐임

### 2. 풀이

- dz배열 추가해서 위 아래로 이동할 수 있는 경우의 수를 추가해주고 각 토마토를 시작점으로 BFS를 돌려서 최단 거리 출력하면 끝

## [7562 - 나이트의 이동](https://www.acmicpc.net/problem/7562)

### 1. 해결 핵심 아이디어

- BFS를 이용해서 최단 거리를 구하는 문제
- 인접 노드가 여덟개인 경우

### 2. 풀이

- 마찬가지로 각 인접의 경우에 대해 next point가 될 수 있게 만들어주고, 도착점까지의 최단 거리 출력해주면 끝

## [5427 - 불](https://www.acmicpc.net/problem/5427)

### 1. 해결 핵심 아이디어

- 4179번과 동일한 문제

### 2. 풀이

- 4179와 동일하게 풀면 됨

## [2583 - 영역 구하기](https://www.acmicpc.net/problem/2583)

### 1. 해결 핵심 아이디어

- 오른쪽 아래, 왼쪽 위 좌표 입력 받고, 1로 채운다음 0으로 구성된 영역의 개수와 크기 구하는 문제
- 각 시작점에 대해 BFS를 돌아주면 끝

### 2. 풀이

- 좌표를 받고 어디부터 어디까지 1로 채워야하는지 잘 정해준다
- 크기를 오름차순으로 출력해줘야되므로 각 영역의 너비를 담는 컨테이너로 priority_queue를 이용하였다

## [2667 - 단지번호붙이기](https://www.acmicpc.net/problem/2667)

### 1. 해결 핵심 아이디어

- 영역의 개수와 크기를 구하는 문제
- 각 시작점에 대해 BFS를 돌아주면 끝

### 2. 풀이

- 한 줄로 입력받으므로, string타입 배열로 입력받아서 시작점에 대해 BFS를 돌아준다
- 크기를 오름차순으로 출력해줘야되므로 각 영역의 너비를 담는 컨테이너로 priority_queue를 이용하였다

## [5014 - 스타트링크](https://www.acmicpc.net/problem/5014)

### 1. 해결 핵심 아이디어

- 일차원 직선에서 BFS를 응용해서 최단 거리를 구하는 문제이다
- 문제에서 정의된 대로 인접 노드는 +U -D가 인접이 된다

### 2. 풀이

- 목표 포인트인 G에 도달하면 BFS를 끝내고, dist[G]를 출력한다
- 도달못하는 경우는 use the stairs를 출력해주는데, 불가능한 경우는 모든 정점을 방문하고나서도 G에 도달하지 못한 경우이다

## [2468 - 안전 영역](https://www.acmicpc.net/problem/2468)

### 1. 해결 핵심 아이디어

- 각 입력에 대해 최소값부터 최대값까지 안전 영역을 구한다
- next point 결정 기준은 현재 비의 양보다 영역의 높이가 높은 곳 기준이다
- 각 시작점은 현재 비의 양보다 높이가 높은 포인트가 된다

### 2. 풀이

- 0부터 입력 값 중 최대값까지 돌면서 안전영역의 개수 구하고, 최대값 리턴해주면 끝
- 높이가 0일때는 안전영역의 수 1이고, 최대값일 때는 0인데, 이 둘의 제외한다고 드라마틱한 차이가 일어나는 것은 아니니 포함해도 상관없다

## [6593 - 상범 빌딩](https://www.acmicpc.net/problem/6593)

### 1. 해결 핵심 아이디어

- 삼차원 배열에서 BFS를 이용해서 최단 거리를 구하는 문제
- 불가능한 경우는 BFS를 다 돌고도 도착점에 못가는 경우

### 2. 풀이

- 문자열로 한줄씩 주어지므로 string타입 배열로 받아서 처리한다

## [2206 - 벽 부수고 이동하기](https://www.acmicpc.net/problem/2206)

### 1. 해결 핵심 아이디어

- 처음에는 모든 벽을 부숴보는 모든 경우에 대해 완전탐색을 생각했는데, 시간초과 날 것이 뻔했고, 정답을 보기로했다
- 다음의 자료들을 참고하여 문제를 풀었다

  [백준 질문 탭](https://www.acmicpc.net/board/view/27386)

  [블로그](https://kscodebase.tistory.com/66)

- 이 문제와 같이 벽을 부술 수 있는 경우 새로운 테크닉을 요구한다
- 벽을 부수고 온 경우와 아닌 경우를 차원을 나눠서 생각한다
- 벽을 한 번밖에 부수지 못하기 때문에 0의 우주를 벽을 부수지 않고 현재 포인트까지 온 우주라고하고, 1의 우주를 벽을 한 번 부수고 현재 포인트까지 온 우주라고 하자 각 관계를 살펴보면 아래와 같다
  - 0의 우주 -> 0의 우주, 가능한 우주
  - 0의 우주 -> 1의 우주, 가능한 우주
  - 1의 우주 -> 1의 우주, 가능한 우주
  - 1의 우주 -> 0의 우주, 불가능한 우주, 벽을 더이상 못 부숨
- 큐에 벽을 부수고 왔는지 아닌지 상태를 좌표와 함께 넣어야하고, 이 상태에 따라 정해진 차원에서 거리를 계산해야한다
- 0의 우주에 있는 포인트가 1에 둘러쌓여 있는 경우라도 큐에 인접 노드를 넣으면서 1의 우주에 있는 포인트를 한 번씩 넣어볼 수 있어 모든 경우에 대해 탐색 가능하다, 아직 부순 경우가 아니기 때문임
- 이렇게 이동에 특정 상태가 수반되는 경우 상태를 변수라 하고 변수가 추가된 경우로, 앞으로 어떤 문제에 이동에 제약을 주는 상태가 있다면, 차원을 추가해보는 방법도 고려해보자

### 2. 풀이

- 삼차원배열을 두고 삼차원은 0과 1로 구성, 각각은 벽을 부수지 않고 도착점에 도달한 우주, 벽을 하나 부수고 도착점에 도달한 우주를 의미한다
- 벽을 부수는 경우와 벽을 부수기 전 + 벽을 부수고 난 후를 나눠서 논리를 작성한다

## [9466 - 텀 프로젝트](https://www.acmicpc.net/problem/9466)

### 1. 해결 핵심 아이디어

- BFS 연습 셋에 있긴 하나 이 문제는 DFS를 이용하는데, 이유는 사이클내에 있는지 아닌지 판단하기 위해 사이클을 만날 때까지 깊이로 뻗어나가면서 방문하기 때문이다
- 팀을 이루는 경우는 사이클을 형성하는 경우이고, 이 문제는 사이클에 속하지 않는 노드의 수를 세는 문제이다
- dfs를 이용해서 사이클내에 있는 노드인지 아닌지 판단할 수 있다, 자세한 건 아래 링크를 참고하자
  - [DFS 알고리즘 노트](../../0x0A%20DFS/README.md#0x03-그래프-탐색과-cycle)

### 2. 풀이

- 미방문 노드에 대해 사이클 내의 노드인지 판별하고, 모든 탐색끝난 후 사이클 내에 있지 않은 노드의 수를 세서 리턴하면 끝
- 사이클 내에 있는지 아닌지 판단하는데 DFS를 쓴다는 점 기억하자

## [2573 - 빙산](https://www.acmicpc.net/problem/2573)

### 1. 해결 핵심 아이디어

- 영역 개수 구하는 문제인데, 이 문제가 특이한 점은 맵이 계속 변한다는 점이다
- 얼음이 녹는 시뮬레이션을 만드는데, 실수하기 좋은 점이 각 포인트에 인접한 바다의 수를 세고난 후 그만큼 빼고 나면 현재 스텝에서 녹는 얼음끼리 서로 영향을 끼친다, 다시 말해 (i-1, j)과 (i, j)가 모두 얼음이라고 가정하면, 문제에서 의도한 바는 동시에 녹는건데, (i-1, j)가 녹고나서 (i, j)가 녹게된다
- 그래서 인접 바다를 발견하면 뺄게아니라 각 얼음에서 인접한 바다 수를 각각 세놓고, 모든 얼음에 대해서 다 세고난 후 빼줘야한다

### 2. 풀이

- 맵을 입력 받고, 시간이 지남에 따라 맵의 상태를 변화시켜주고, 변화된 맵에서 영역의 개수를 세주다가, 영역이 2개 이상이되면 멈춘다
- 모든 빙산이 녹기까지 분리안되는 경우가 있을 수 있어, 매 스텝마다 맵 원소의 합이 0인지 확인해서 불가능한 경우인지 체크해줘야한다

## [2146 - 다리 만들기](https://www.acmicpc.net/problem/2146)

### 1. 해결 핵심 아이디어

- 간단한 솔루션은 첫번째로 BFS 돌면서 영역에 번호를 매겨놓은 다음, 한 번더 BFS 돌 되, 인접노드가 같은 영역인 경우는 건너뛰고, 바다를 건너가면서 다른 영역에 도달하면, 그 때 거리를 계산하고, 최소값 갱신을 해준다, N의 크기가 100이하이고, 시간 제한도 2초 이내이므로 통과하는데는 문제가 없다 -> O($N^2$)
- 시작점이 여러 개일 때 BFS를 이용해서 영역을 넓혀가는 문제(7576 - 토마토)와 비슷하게 각 영역의 외곽들(바다와 맞닿아있는)을 시작점으로 간주하고, 동시에 BFS를 돌려서 확장하다가 둘이 닿으면, 그게 다리의 길이가 된다
- 외곽에서 출발하여 바다를 메우면서 진행한다고 생각해보면, 닿는다는 개념을 쉽게 구현할 수 있다. next point가 바다가 아니라 다른 영역의 번호라면 닿은 것이다

### 2. 풀이

- 단순히 다른 영역을 만났다고 해서 dist[cur.x][cur.y] + dist[nx][ny]를 출력하면 이건 다리가 만들어진거지 최소가 아닐 수 있기 때문에 모든 영역의 교점에 대해 최소값 갱신 연산이 이뤄져야한다

## [13549 - 숨바꼭질 3](https://www.acmicpc.net/problem/13549)

### 1. 해결 핵심 아이디어

- 이 문제는 간선이 0또는 1로 이뤄진 그래프에서 최단거리를 구하는 문제이고, 이런류의 문제를 해결하는 알고리즘은 0-1 BFS이다
- 자세한 내용은 [BFS 알고리즘 노트](../README.md#0x06-응용-5---0-1-bfs) 참고

### 2. 풀이

- 0-1 BFS를 돌리고, 나온 최단거리를 출력해주면 끝

## [1600 - 말이 되고픈 원숭이](https://www.acmicpc.net/problem/1600)

### 1. 해결 핵심 아이디어

- 이 문제는 4179번 불!문제랑 7562번 나이트의 이동이 섞인 문제이다
- 다만 불!문제는 벽을 한 번만 뚫을 수 있었는데 이 문제는 K번 원숭이에서 말로 변환이 가능하다, 이전 차원에서 다음 차원으로 이동하면 이전 차원으로는 돌아갈 수 없는데, 이전 차원으로 돌아갈 수 있다는 소리는 말로 변환을 안한 경우와 합쳐지기 때문에 틀린 경우가 되고, K번 카운트에서 어긋나게 된다
- 불!문제와 또 다른 점은 out of bound에 도달한다고 끝나는게 아니라 도착점이 존재한다
- 각 차원에서 도착점에 도달할 수 있다, 그래서 최소를 찾기 위해 모든 경우를 살펴봐야 하기에 차원 이동 횟수 < k일 때는 차원 이동을 해주고(말의 움직임) 아니면 이동하지 않고, 원숭이의 움직임에 따라 도착에 갈 수 있는지 본다
- 쉽게 이해하기 위해 다중우주론에서 도착점에 도달할 수 있는 우주들 중(차원들)에서 제일 빨리 도착점에 도달하는 우주를 찾는 것이라고 생각하면된다, 그러기 위해서는 모든 다중우주를 봐야한다, 왜냐면 어떤 우주가 최단 거리를 만들어낼지 모르기 때문이다

### 2. 풀이

- 차원 이동 횟수를 좌표와 함께 큐에 담는다
- 차원 이동 횟수가 k보다 작을 때는 차원을 이동해서 말의 움직임을 쓸 수 있고, 아닐 때는 원숭이의 움직임을 써서 도착점에 도달할 수 있는지 본다
- 도착 못하는 경우도 있을 수 있으니 큐가 빌 때까지 수행하고나서도 최소값이 갱신되지 않았다면, 어떤 차원에서도 도착점에 못 간 케이스이므로 -1을 출력해준다

## [13913 - 숨바꼭질 4](https://www.acmicpc.net/problem/13913)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [14442 - 벽 부수고 이동하기 2](https://www.acmicpc.net/problem/14442)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [16933 - 벽 부수고 이동하기 3](https://www.acmicpc.net/problem/16933)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [16920 - 확장 게임](https://www.acmicpc.net/problem/16920)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [11967 - 불켜기](https://www.acmicpc.net/problem/11967)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [17071 - 숨바꼭질 5](https://www.acmicpc.net/problem/17071)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [9328 - 열쇠](https://www.acmicpc.net/problem/9328)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [3197 - 백조의 호수](https://www.acmicpc.net/problem/3197)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [20304 - 비밀번호 제작](https://www.acmicpc.net/problem/20304)

### 1. 해결 핵심 아이디어

### 2. 풀이
