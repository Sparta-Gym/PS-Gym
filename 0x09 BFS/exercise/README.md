# Learning About

## [1926 - 그림](https://www.acmicpc.net/problem/1926)

### 1. 해결 핵심 아이디어

- 문제에서 자명하게 가로나 세로로 1이 연결돼있는 것을 영역이라고 지정해주어 쉽게 flood fill 문제임을 파악할 수 있다
- flood fill 문제는 BFS나 DFS를 통해서 해결할 수 있다, 노드를 정확히 한 번씩만 방문하기 때문에 영역의 크기는 물론 모든 노드를 방문하기 때문에 영역과 그것이 아닌 것을 구분지을 수 있다

### 2. 풀이

- 이차원배열에서 1이 나올 때마다 큐에 넣고 BFS를 돌리되, 이미 방문한 정점일 수 있으므로 방문배열을 보고 아직 미방문 노드만 큐에 넣는다
- 미방문 노드라면 큐에 넣고 방문 여부 체크를 해준다
- bfs의 수행횟수가 영역의 갯수가 된다
  - 시작점의 갯수 = 영역의 갯수

## [2178 - 미로 탐색](https://www.acmicpc.net/problem/2178)

### 1. 해결 핵심 아이디어

- 시작점과 도착점이 주어지고, 이 둘 사이의 최단 거리를 구하는 문제이다
- 인접 노드로 갈 때 가중치가 이동 거리 1이므로 모든 간선의 가중치는 1이고, BFS를 사용해서 최단거리를 구할 수 있는데, 이는 한 노드가 방문 처리될 때 이 노드의 모든 인접노드가 큐에 들어가기 때문에 최단 거리를 구할 수 있는 것이다

### 2. 풀이

- 한 줄단위로 입력되기에 string타입의 배열을 만들어서 한 줄씩 입력받는다
- 최단 거리를 구할 때는 방문배열 대신 거리 배열을 만들어서 -1로 초기화한 다음, 큐에 넣고, u를 지금 보고있는 노드, v를 u의 인접노드라고 할 때, dist[v] = dist[u] + 1가 되게 만들어놓으면, dist배열에는 시작점으로부터 각 정점까지의 최단거리가 저장된다, dist 배열로 방문여부 체크를 할 수 있는데, 이미 거리가 계산돼있다면, 방문했던 것으로 간주할 수 있기 때문이다
- dist[도착점]을 출력하면 끝

## [7576 - 토마토](https://www.acmicpc.net/problem/7576)

### 1. 해결 핵심 아이디어

- 시작점이 여러 개일 때 BFS를 응용해서 최단 거리를 구하는 문제이다
- 익은 토마토가 익지 않은 인접 토마토를 익게하는데 하루가 걸린다는 점에서 최단 거리를 구하는 문제라는 것을 알 수 있다
- 일반적인 BFS문제와는 다르게 갈 수 없는 포인트를 -1, 아직 안 간 포인트를 0, 시작점을 1로 구분해주기에 BFS를 사용하더라도 시간 제한 내에 들어올 수 있다는 점을 알 수 있다
- 어떤 시작점으로 부터 제일 멀리떨어져 있는 포인트까지의 거리가 모든 토마토가 익는데 걸리는 최소 일수이고, 모든 토마토가 익지 못하는 경우도 주어질 수 있으므로 토마토가 있는 포인트의 dist가 과정이 끝나고도 -1이면 그것이 익지 못한 토마토이므로 -1을 출력해준다

### 2. 풀이

- 이차원배열을 입력받으면서 1이 나오는 것을 모두 큐에 집어넣는다
- 모두 입력받고 BFS를 돌린다, 이러면 각 영역의 시작점에서 시작되기에 모든 영역을 탐색할 수 있다
- 어떤 포인트가 여러 개의 영역의 교점이 될 수도 있는데, 그 포인트를 먼저 포함시키는 영역에 들어가야 최단 거리를 구할 수 있다
- dist에서 제일 큰 값을 뽑아내되, dist내에 -1이 있다면, 불가능한 케이스이므로 -1 출력한다

## [4179 - 불!](https://www.acmicpc.net/problem/4179)

### 1. 해결 핵심 아이디어

- 시작점이 두 종류일 때 BFS를 응용해서 최단 거리를 구하는 문제이다
- 이 문제의 특이점은 out of bound일 때 미로를 탈출했다고 간주한다는 점이다
- 불이 붙은 곳은 사람이 갈 수 없는데, 불이 붙기전에 사람이 이동할 수 있는 포인트인지 판단은 불을 시작점으로 하는 BFS를 돌려 최단 거리를 구해놓고, 이후 사람을 시작점으로 하는 BFS를 돌려 최단 거리를 구한다. 어떤 포인트에 대해 불을 시작점으로 하는 최단 거리 > 사람을 시작점으로 하는 최단 거리일 때, 불이 붙기 전에 사람이 올 수 있는 포인트임을 의미한다

### 2. 풀이

- 문자열로 입력 받는다, 입력 이후 불의 시작점, 사람의 시작점을 큐에 넣는다
- 불에 대한 BFS를 돌고, 그 이후 사람에 대한 BFS를 돈다
- 불에 대한 BFS는 일반 BFS와 같지만 사람에 대한 BFS는 out of bound가 됬을 때, 결과를 출력하고, `fire[nx][ny] != -1 && fire[nx][ny] <= escape[cur.x][cur.y] + 1` 일 때 continue시키는데, 불은 못가는데 사람은 갈 수 있는 포인트이거나(불이 없는 경우도 주어짐) 둘 다 갈수있는데, 사람이 더 빨리 올 수 있는 포인트만 밟으면서 탈출할 수 있음을 의미한다
- BFS가 끝날 때까지 탈출못했으면, IMPOSSIBLE 출력해주면 된다

## [1697 - 숨바꼭질](https://www.acmicpc.net/problem/1697)

### 1. 해결 핵심 아이디어

- 일차원 직선에서 BFS를 응용해서 최단 거리를 구하는 문제이다
- 이차원 배열에서 인접이 동서남북이었다면, 여기서는 문제에서 정의된 대로 -1, +1, \*2가 인접이 된다

### 2. 풀이

- 목표 포인트인 k에 도달하면 BFS를 끝내고, dist[k]를 출력한다

## [1012 - 유기농 배추](https://www.acmicpc.net/problem/1012)

### 1. 해결 핵심 아이디어

- flood fill 문제로 영역의 개수를 구하면 된다

### 2. 풀이

- 배추가 심어진 포인트를 입력 받은 후 이차원배열 돌면서 1인 포인트를 시작점으로 BFS를 돌 되, 방문한 포인트라면 건너뛴다

## [10026 - 적록색약](https://www.acmicpc.net/problem/10026)

### 1. 해결 핵심 아이디어

- flood fill 문제로 영역의 개수를 구하는 문제인데, 두 가지 케이스가 주어진다
- 적록색약의 경우 R과 G를 같은 것으로 인식, 아니면 R과 G를 다른 것으로 인식한다
- 두 경우에 대해 next point를 체크할 때 조건만 달리해주면 쉬운 문제

### 2. 풀이

- R, G, B 각각에 대해 시작점으로 간주하고 큐에 넣되, 이미 방문한 경우는 넣지 않는다
- 색약인 경우와 아닌 경우 논리를 달리 짜주고, 각각 BFS를 돌리고 영역의 개수 구하고 출력하면 끝

## [7569 - 토마토](https://www.acmicpc.net/problem/7569)

### 1. 해결 핵심 아이디어

- 7576과 삼차원 배열에서 BFS를 수행한다는 점이 차이이외에는 동일하다
- 삼차원도 이차원과 별다를게 없다, 인접이 상하동서남북 여섯개로 늘어난 것 뿐임

### 2. 풀이

- dz배열 추가해서 위 아래로 이동할 수 있는 경우의 수를 추가해주고 각 토마토를 시작점으로 BFS를 돌려서 최단 거리 출력하면 끝

## [7562 - 나이트의 이동](https://www.acmicpc.net/problem/7562)

### 1. 해결 핵심 아이디어

- BFS를 이용해서 최단 거리를 구하는 문제
- 인접 노드가 여덟개인 경우

### 2. 풀이

- 마찬가지로 각 인접의 경우에 대해 next point가 될 수 있게 만들어주고, 도착점까지의 최단 거리 출력해주면 끝

## [5427 - 불](https://www.acmicpc.net/problem/5427)

### 1. 해결 핵심 아이디어

- 4179번과 동일한 문제

### 2. 풀이

- 4179와 동일하게 풀면 됨

## [2583 - 영역 구하기](https://www.acmicpc.net/problem/2583)

### 1. 해결 핵심 아이디어

- 오른쪽 아래, 왼쪽 위 좌표 입력 받고, 1로 채운다음 0으로 구성된 영역의 개수와 크기 구하는 문제
- 각 시작점에 대해 BFS를 돌아주면 끝

### 2. 풀이

- 좌표를 받고 어디부터 어디까지 1로 채워야하는지 잘 정해준다
- 크기를 오름차순으로 출력해줘야되므로 각 영역의 너비를 담는 컨테이너로 priority_queue를 이용하였다

## [2667 - 단지번호붙이기](https://www.acmicpc.net/problem/2667)

### 1. 해결 핵심 아이디어

- 영역의 개수와 크기를 구하는 문제
- 각 시작점에 대해 BFS를 돌아주면 끝

### 2. 풀이

- 한 줄로 입력받으므로, string타입 배열로 입력받아서 시작점에 대해 BFS를 돌아준다
- 크기를 오름차순으로 출력해줘야되므로 각 영역의 너비를 담는 컨테이너로 priority_queue를 이용하였다

## [5014 - 스타트링크](https://www.acmicpc.net/problem/5014)

### 1. 해결 핵심 아이디어

- 일차원 직선에서 BFS를 응용해서 최단 거리를 구하는 문제이다
- 문제에서 정의된 대로 인접 노드는 +U -D가 인접이 된다

### 2. 풀이

- 목표 포인트인 G에 도달하면 BFS를 끝내고, dist[G]를 출력한다
- 도달못하는 경우는 use the stairs를 출력해주는데, 불가능한 경우는 모든 정점을 방문하고나서도 G에 도달하지 못한 경우이다

## [2468 - 안전 영역](https://www.acmicpc.net/problem/2468)

### 1. 해결 핵심 아이디어

- 각 입력에 대해 최소값부터 최대값까지 안전 영역을 구한다
- next point 결정 기준은 현재 비의 양보다 영역의 높이가 높은 곳 기준이다
- 각 시작점은 현재 비의 양보다 높이가 높은 포인트가 된다

### 2. 풀이

- 0부터 입력 값 중 최대값까지 돌면서 안전영역의 개수 구하고, 최대값 리턴해주면 끝
- 높이가 0일때는 안전영역의 수 1이고, 최대값일 때는 0인데, 이 둘의 제외한다고 드라마틱한 차이가 일어나는 것은 아니니 포함해도 상관없다

## [6593 - 상범 빌딩](https://www.acmicpc.net/problem/6593)

### 1. 해결 핵심 아이디어

- 삼차원 배열에서 BFS를 이용해서 최단 거리를 구하는 문제
- 불가능한 경우는 BFS를 다 돌고도 도착점에 못가는 경우

### 2. 풀이

- 문자열로 한줄씩 주어지므로 string타입 배열로 받아서 처리한다

## [2206 - 벽 부수고 이동하기](https://www.acmicpc.net/problem/2206)

### 1. 해결 핵심 아이디어

- 처음에는 모든 벽을 부숴보는 모든 경우에 대해 완전탐색을 생각했는데, 시간초과 날 것이 뻔했고, 정답을 보기로했다
- 다음의 자료들을 참고하여 문제를 풀었다

  [백준 질문 탭](https://www.acmicpc.net/board/view/27386)

  [블로그](https://kscodebase.tistory.com/66)

- 이 문제와 같이 벽을 부술 수 있는 경우 새로운 테크닉을 요구한다
- 벽을 부수고 온 경우와 아닌 경우를 차원을 나눠서 생각한다
- 벽을 한 번밖에 부수지 못하기 때문에 0의 우주를 벽을 부수지 않고 현재 포인트까지 온 우주라고하고, 1의 우주를 벽을 한 번 부수고 현재 포인트까지 온 우주라고 하자 각 관계를 살펴보면 아래와 같다
  - 0의 우주 -> 0의 우주, 가능한 우주
  - 0의 우주 -> 1의 우주, 가능한 우주
  - 1의 우주 -> 1의 우주, 가능한 우주
  - 1의 우주 -> 0의 우주, 불가능한 우주, 벽을 더이상 못 부숨
- 큐에 벽을 부수고 왔는지 아닌지 상태를 좌표와 함께 넣어야하고, 이 상태에 따라 정해진 차원에서 거리를 계산해야한다
- 0의 우주에 있는 포인트가 1에 둘러쌓여 있는 경우라도 큐에 인접 노드를 넣으면서 1의 우주에 있는 포인트를 한 번씩 넣어볼 수 있어 모든 경우에 대해 탐색 가능하다, 아직 부순 경우가 아니기 때문임
- 이렇게 이동에 특정 상태가 수반되는 경우 상태를 변수라 하고 변수가 추가된 경우로, 앞으로 어떤 문제에 이동에 제약을 주는 상태가 있다면, 차원을 추가해보는 방법도 고려해보자

### 2. 풀이

- 삼차원배열을 두고 삼차원은 0과 1로 구성, 각각은 벽을 부수지 않고 도착점에 도달한 우주, 벽을 하나 부수고 도착점에 도달한 우주를 의미한다
- 벽을 부수는 경우와 벽을 부수기 전 + 벽을 부수고 난 후를 나눠서 논리를 작성한다

## [9466 - 텀 프로젝트](https://www.acmicpc.net/problem/9466)

### 1. 해결 핵심 아이디어

- BFS 연습 셋에 있긴 하나 이 문제는 DFS를 이용하는데, 이유는 사이클내에 있는지 아닌지 판단하기 위해 사이클을 만날 때까지 깊이로 뻗어나가면서 방문하기 때문이다
- 팀을 이루는 경우는 사이클을 형성하는 경우이고, 이 문제는 사이클에 속하지 않는 노드의 수를 세는 문제이다
- dfs를 이용해서 사이클내에 있는 노드인지 아닌지 판단할 수 있다, 자세한 건 아래 링크를 참고하자
  - [DFS 알고리즘 노트](../../0x0A%20DFS/README.md#0x03-그래프-탐색과-cycle)

### 2. 풀이

- 미방문 노드에 대해 사이클 내의 노드인지 판별하고, 모든 탐색끝난 후 사이클 내에 있지 않은 노드의 수를 세서 리턴하면 끝
- 사이클 내에 있는지 아닌지 판단하는데 DFS를 쓴다는 점 기억하자

## [2573 - 빙산](https://www.acmicpc.net/problem/2573)

### 1. 해결 핵심 아이디어

- 영역 개수 구하는 문제인데, 이 문제가 특이한 점은 맵이 계속 변한다는 점이다
- 얼음이 녹는 시뮬레이션을 만드는데, 실수하기 좋은 점이 각 포인트에 인접한 바다의 수를 세고난 후 그만큼 빼고 나면 현재 스텝에서 녹는 얼음끼리 서로 영향을 끼친다, 다시 말해 (i-1, j)과 (i, j)가 모두 얼음이라고 가정하면, 문제에서 의도한 바는 동시에 녹는건데, (i-1, j)가 녹고나서 (i, j)가 녹게된다
- 그래서 인접 바다를 발견하면 뺄게아니라 각 얼음에서 인접한 바다 수를 각각 세놓고, 모든 얼음에 대해서 다 세고난 후 빼줘야한다

### 2. 풀이

- 맵을 입력 받고, 시간이 지남에 따라 맵의 상태를 변화시켜주고, 변화된 맵에서 영역의 개수를 세주다가, 영역이 2개 이상이되면 멈춘다
- 모든 빙산이 녹기까지 분리안되는 경우가 있을 수 있어, 매 스텝마다 맵 원소의 합이 0인지 확인해서 불가능한 경우인지 체크해줘야한다

## [2146 - 다리 만들기](https://www.acmicpc.net/problem/2146)

### 1. 해결 핵심 아이디어

- 간단한 솔루션은 첫번째로 BFS 돌면서 영역에 번호를 매겨놓은 다음, 한 번더 BFS 돌 되, 인접노드가 같은 영역인 경우는 건너뛰고, 바다를 건너가면서 다른 영역에 도달하면, 그 때 거리를 계산하고, 최소값 갱신을 해준다, N의 크기가 100이하이고, 시간 제한도 2초 이내이므로 통과하는데는 문제가 없다 -> O($N^4$)
- 시작점이 여러 개일 때 BFS를 이용해서 영역을 넓혀가는 문제(7576 - 토마토)와 비슷하게 각 영역의 외곽들(바다와 맞닿아있는)을 시작점으로 간주하고, 동시에 BFS를 돌려서 확장하다가 둘이 닿으면, 그게 다리의 길이가 된다
- 외곽에서 출발하여 바다를 메우면서 진행한다고 생각해보면, 닿는다는 개념을 쉽게 구현할 수 있다. next point가 바다가 아니라 다른 영역의 번호라면 닿은 것이다

### 2. 풀이

- 단순히 다른 영역을 만났다고 해서 dist[cur.x][cur.y] + dist[nx][ny]를 출력하면 이건 다리가 만들어진거지 최소가 아닐 수 있기 때문에 모든 영역의 교점에 대해 최소값 갱신 연산이 이뤄져야한다

## [13549 - 숨바꼭질 3](https://www.acmicpc.net/problem/13549)

### 1. 해결 핵심 아이디어

- 이 문제는 간선이 0또는 1로 이뤄진 그래프에서 최단거리를 구하는 문제이고, 이런류의 문제를 해결하는 알고리즘은 0-1 BFS이다
- 자세한 내용은 [BFS 알고리즘 노트](../README.md#0x06-응용-5---0-1-bfs) 참고

### 2. 풀이

- 0-1 BFS를 돌리고, 나온 최단거리를 출력해주면 끝

## [1600 - 말이 되고픈 원숭이](https://www.acmicpc.net/problem/1600)

### 1. 해결 핵심 아이디어

- 이 문제는 4179번 불!문제랑 7562번 나이트의 이동이 섞인 문제이다
- 다만 불!문제는 벽을 한 번만 뚫을 수 있었는데 이 문제는 K번 원숭이에서 말로 변환이 가능하다, 이전 차원에서 다음 차원으로 이동하면 이전 차원으로는 돌아갈 수 없는데, 이전 차원으로 돌아갈 수 있다는 소리는 말로 변환을 안한 경우와 합쳐지기 때문에 틀린 경우가 되고, K번 카운트에서 어긋나게 된다
- 불!문제와 또 다른 점은 out of bound에 도달한다고 끝나는게 아니라 도착점이 존재한다
- 각 차원에서 도착점에 도달할 수 있다, 그래서 최소를 찾기 위해 모든 경우를 살펴봐야 하기에 차원 이동 횟수 < k일 때는 차원 이동을 해주고(말의 움직임) 아니면 이동하지 않고, 원숭이의 움직임에 따라 도착에 갈 수 있는지 본다
- 쉽게 이해하기 위해 다중우주론에서 도착점에 도달할 수 있는 우주들 중(차원들)에서 제일 빨리 도착점에 도달하는 우주를 찾는 것이라고 생각하면된다, 그러기 위해서는 모든 다중우주를 봐야한다, 왜냐면 어떤 우주가 최단 거리를 만들어낼지 모르기 때문이다

### 2. 풀이

- 차원 이동 횟수를 좌표와 함께 큐에 담는다
- 차원 이동 횟수가 k보다 작을 때는 차원을 이동해서 말의 움직임을 쓸 수 있고, 아닐 때는 원숭이의 움직임을 써서 도착점에 도달할 수 있는지 본다
- 도착 못하는 경우도 있을 수 있으니 큐가 빌 때까지 수행하고나서도 최소값이 갱신되지 않았다면, 어떤 차원에서도 도착점에 못 간 케이스이므로 -1을 출력해준다

## [13913 - 숨바꼭질 4](https://www.acmicpc.net/problem/13913)

### 1. 해결 핵심 아이디어

- 1697번 숨바꼭질과 같은 문제인데, 최단 경로를 추적해야한다
- path라는 배열을 따로 두어, path[nxt] = cur으로 저장한 다음 BFS돌리고, 경로를 역추적해서 거꾸로 출력해주면 끝
- 거꾸로 출력할 때 스택을 사용했는데, 다른 코드에서는 덱도 쓰더라

### 2. 풀이

- 1차원 BFS 구현하고, 경로를 담는 배열을 선언하고 next point를 큐에 넣을 때 경로 배열도 갱신해주었다

## [14442 - 벽 부수고 이동하기 2](https://www.acmicpc.net/problem/14442)

### 1. 해결 핵심 아이디어

- 1600번 말이 되고픈 원숭이 문제를 응용하면 풀 수 있는 문제였다
- 벽 뚫는 횟수를 차원으로 놓고, 서로 다른 우주에서 경우의 수를 모두 보고 최솟값을 구한다

### 2. 풀이

- 최솟값 찾을 때 차원을 0부터 k까지 봐야되는데 그 이유는 벽을 안 뚫고 간 우주 + 벽을 1번 뚫고 간 우주 + ... + 벽을 k번 뚫고 간 우주, 총 k개인데, k라고 놔서 엣지 케이스에서 한참 헤맸다, for문 무지성으로 적지말고, 맞는지 찬찬히 생각해보기
- const int range = 1e4 + 1; 전역변수를 놓고 string 타입 배열과 int 타입 삼차원 배열 전역으로 초기화해줬는데 `'/usr/lib/libc++.1.dylib' (no such file), '/usr/local/lib/libc++.1.dylib' (no such file)` 오류가 났다, 이유 찾아보기

## [16933 - 벽 부수고 이동하기 3](https://www.acmicpc.net/problem/16933)

### 1. 해결 핵심 아이디어

- 이 문제는 다른 벽 뚫기 시리즈와 다르게 자리에 그대로 있는 것이 가능하고, 낮과 밤이 추가된다
- 낮과 밤의 상태를 나타내기 위해 차원을 하나더 추가하여 사차원 배열에서 BFS를 수행한다
- 처음에 시도했던 방식
  - 벽을 뚫던 말던 현재 칸에 머무는 것은 가능하니 dist[1-t][d][x][y]를 아직 방문한 적이 없다면, 큐에 넣어줬다, 이렇게 한 이유는 모든 경우를 다 봐야하기 때문
  - 낮이고, 벽을 뚫을 수 있다면 벽을 뚫고 이동한다
  - 밤이거나 벽을 뚫을 수 없다면 현재 차원에서 계속 진행한다
  - 이 경우에서 고려 못한 케이스는 밤이고, 벽을 뚫을 기회가 있었음에도 벽에 막혀서 continue 됬는데, 이미 낮의 차원 point를 방문체크를 위에서 했기때문에 무한 루프에 빠졌다
- 가능한 경우를 보자
  - 낮일 때
    - 벽을 뚫을 기회가 있다면 벽을 뚫고 진행한다
    - 벽을 뚫을 기회가 없다면 현재 차원에서 계속 진행한다
  - 밤일 때
    - 벽을 뚫을 기회가 있다면 낮까지 기다렸다가 벽을 뚫고 진행한다
    - 벽을 뚫을 기회가 없다면 현재 차원에서 계속 진행한다
- 밤에서 낮을 기다려야하는 경우는 벽을 뚫을 기회가 있을 때만 하면된다, 밤이 주는 제약이 벽을 못 뚫는 것이고, 벽을 뚫을 수 있는데도, 그 자리 그대로 있는 것은 최단 경로가 아니기 때문에 고려할 케이스가 아니다
- next point가 벽이 아니고, 미방문한 경우한 경우 무조건 이동한다
- 이동할 수 없는 경우는 벽에 막힌 경우
  - 벽을 뚫을 기회가 없다면 continue시킨다, 불가능한 케이스라면(기회 < 벽의 수) 큐가 비어 BFS 종료됨
  - 벽을 뚫을 기회가 있고, 낮이면 벽을 뚫고 계속 진행한다
  - 벽을 뚫을 기회가 있고, 밤이면 낮을 기다린다
- 현재 자리에서 의미없이 낮과 밤만 바꿔주고 시작해서 밤에서 낮이 될 때까지 기다렸다가 벽을 뚫고 진행할 수 있는 경우에도 이미 낮이 방문 처리 되있어서 무한 루프에 빠졌는데, 앞으로는 가능한 모든 경우의 수를 나열해보고나서 코딩에 들어가야겠다, 무지성을 반성하자

### 2. 풀이

- 변수가 나올 때 차원을 증가시키는 응용은 잘 적용했음
- 모든 경우를 나열해보고 고려할 케이스와 고려 안해도 되는 케이스를 나누고, 정해진 논리에 허점이 없는지 봐야겠다
- 구현팁

  ```cpp
  queue<tuple<int, int, int, int>> q;
  q.push({1,2,3,4});
  // tie대신 패킹하는 방법이 또 있다!
  auto [x, y, w, t] = q.front();
  ```

## [16920 - 확장 게임](https://www.acmicpc.net/problem/16920)

### 1. 해결 핵심 아이디어

- age라는 나이 변수를 큐에 좌표와 함께 담고, 인접 노드로 큐에 들어갈 때 age를 1씩 깎는다
- age가 1인 경우는 현재 턴에서 확장이 끝났다는 의미이고, 다음턴의 시작점이 되야함을 의미한다
- age가 0인 경우는 확장이 불가능한 경우이므로 인접 검사에서 continue 시켜준다
- 확장 게임이 끝난 상태가 모든 칸이 알파벳으로 차있는 경우라고 생각했다가 질문탭의 테스트 케이스를 보고 아닌 경우도 있음을 깨닫고, 모든 플레이어에 대해 인접 노드가 생성가 생성되지않으면 그 누구도 확장을 못하는 것이므로 게임을 끝내야한다

### 2. 풀이

- 전역변수로 vector를 쓸 때 사이즈 지정을 넉넉하게 해주지 않아서 런타임에러났는데, 배열로 바꿔주고 사이즈도 넉넉히 잡아주자

## [11967 - 불켜기](https://www.acmicpc.net/problem/11967)

### 1. 해결 핵심 아이디어

- 문제 이해를 잘못해서 한참 삽질하다가 출발점이 (1,1)로 고정되있고, 여기서 이동하려면, 인접 노드들이 불이 밝혀져야한다
- 암소가 이동할 수 있는 영역은 (1,1)과 연결된 영역이라는 의미, 근데 불 새로 켜지는 곳마다 다 돌았음..
- 질문 탭의 [링크](https://www.acmicpc.net/board/view/38241)를 보고 깨달았음
- (1,1)에서 시작해서 영역을 확장해나가되, 불을 켤 수 있는 방을 다 켜고, (1,1)가 포함된 영역이 더 이상 켜지지 않으면 종료한다

### 2. 풀이

- 각 좌표(A)에서 불을 새로 켤 수 있는 좌표(B)쌍을 표현하기 위해 key를 A고 value를 B(여러개일 수 있어서 벡터로 담음)로 하는 `map<pair<int, int>, vector<pair<int, int>>>`로 담음
- pair도 `auto[x,y] = pair`이런 식으로 패킹 가능, 개편함!!
- 정답코드보니 `vis했었다는 사실만으로 (1,1)과 연결된지 알 수 있었는데 서로 같은 영역내에 아직 미 발견된 포인트라면 이 포인트의 인접 포인트들 중 하나는 반드시 이전에 방문했었던 칸이어야한다` -> 나는 매번 (1,1)부터 시작하고 매턴 끝나면 방문배열 초기화줬는데, 지리는 최적화다!!
- 그리고 (1,1)과 연결되있으면서 각 스텝에서 새로 발견되는 불켜진 포인트를 큐에 넣어준다

## [17071 - 숨바꼭질 5](https://www.acmicpc.net/problem/17071)

### 1. 해결 핵심 아이디어

- 문제 테스트 케이스를보면 `17 5`가 나오는데, 원하는 위치인 5를 수빈이는 2초에 최초로 방문할 수 있고, 4초에 재방문할 수 있다, 동생은 4초에 방문한다, 답이 4초인점으로 미뤄볼 때 재방문 가능하다는 것을 알 수 있다
- 이 문제는 다른 문제와는 다르게 특정 칸을 재방문할 수 있다는 특성이 있다, 그렇다고 실제로 BFS를 돌면서 재방문시킨다는 의미는 아니다, 그러면 BFS도 아닐뿐더러 무한루프임
- 이 문제의 이동을 보면 next point를 -1, +1, \*2로 결정하는데 -1과 +1이 번갈아가면서 나오면서 다시 자기 자신으로 되돌아오는것을 볼 수 있다
- 시각 t에 x 좌표에 첫 방문했으면 시각 t+2에도 좌표 x에 재방문한다, 다시 말해 x에 최초로 도달하는 t가 얼마인가?, 그 시간이 홀수인가 짝수인가에 따라서 t 이후에 x에 도달할 수 있는지 없는지 판별난다 만약 t가 짝수였다면 t 이후의 짝수 시각에서 x에 도달할 수 있다
- 자연수 t와 t+2에는 무슨 관계가 있을까? 바로 홀수, 짝수 관계이다
- 어떤 특정 좌표 x에 이전에 방문했는지 판별하려면 최단 거리 배열에 홀수 시간에 방문했는지 짝수 시간에 방문했는지 기록해야한다, 홀수 짝수를 구분하기 위해 차원을 추가한다

### 2. 풀이

- 재방문이 필요하다는 것을 알게되고나서, 특별한 알고리즘이 있을 거 같아서 바로 정답코드를 찾아봤는데, 다음부터는 그것을 모르고도 풀 수 있는지 보자
- k를 범위 제한 내에서 +1, +3, +6, ... 증가시키면서 dist배열을 탐색한다, 현재 시각 t보다 dist배열에 담겨있는 값이 작거나 같을 때 t보다 이전에 도달했거나 t 도달한 것이므로 만날 수 있음을 의미하고 t를 출력해주면 끝, 만약 범위벗어날 때까지 못 만나면 -1출력해주면 된다

## [9328 - 열쇠](https://www.acmicpc.net/problem/9328)

### 1. 해결 핵심 아이디어

- 이전에 방문했던 칸을 다시 방문해야한다, 지나오다가 잠겨있어서 못지나갔던 문의 열쇠가 발견되었을 경우
  - 열쇠가 발견될 때마다 방문이전의 미지의 영역의 시작점이 추가되는 셈이다, 이전에 문으로 막혀있던 지점의 좌표를 담고있다가 열쇠가 발견되면, 시작점을 추가해준다
- 시작점이 여러 종류이다, .이거나 열쇠를 처음부터 가지고 있는 문이거나 어디서든지 시작할 수 있다
  - 정답코드를 보다가 효율적인 방법을 찾았다, 외곽만 따서 .이거나 알파벳일 때 시작점으로 추가해주려했는데, 매 테스트케이스마다 O($N^2$)이 들어간다, 이보다 효율적인 구현방법이 있는데, 맵을 둘러싸는 테두리 영역을 두고, 들어갈 수 있 수 있는 포인트를 통해 맵으로 들어가게하는 구현법이다.

### 2. 풀이

- 이전에 못 지나가는 점을 저장하기 위해 큐를 따로 선언해놓는다
- 열쇠가 발견될 때마다 못 지나가는 점을 지정하는 큐에서 열쇠에 해당하는 문의 포인트(들)을 큐에 넣어준다
- 이 아이디어는 재방문하는게 아니라, 방문하면서 못지나가는 포인트들을 저장해놓기만 해서 모든 포인트들을 정확히 한 번씩만 방문하게 되어 BFS를 사용하면 되는 것을 알 수 있다

## [3197 - 백조의 호수](https://www.acmicpc.net/problem/3197)

### 1. 해결 핵심 아이디어

- 이 문제는 단순히 얼음 녹이고나서 백조가 만날 수 있는지 판단하면 얼음을 녹이는데, 얼음을 녹이는 과정을 떠올려보면 모든 물 칸에 대해 인접칸에 얼음이 있는지 살펴보고 녹인다, 이 과정에서 최악의 경우 시간복잡도는 $R*C$ 가 소요되고(모든 물을 시작점으로 넣고 BFS를 통해서 인접 칸 탐색하면서 얼음이면 큐에 담아두고 BFS끝나면 다음 턴에 물로 바꾸고 같은 과정 반복), 백조가 만날 수 있는지 판단 역시 BFS를 통해서 하므로 $R*C$ 에 이뤄지고,최악의 경우 매 턴마다 얼음이 둘이 대각선에서 만날 때까지 (1500 \* 1에서 혹은 1 \* 1500에서 양 끝이 백조이고 나머지는 다 얼음인 케이스) 대략 1500 / 2일 정도 걸리기 때문에 녹이고 만나는지 보는 과정을 O(max(R, C))번 하게 되어 최종적으로 시간 복잡도는 $1500^3$ 걸리게 되어 시간초과가 난다
- 원인을 따져보면 매턴마다 돌아가는 BFS가 원인이고, 이 횟수를 줄여야함을 짐작해볼 수 있다
- 9328번 열쇠문제에서 현재는 지나가지 못하는 칸이지만 나중에 지나갈 수 있는 경우 따로 큐에 저장해놓고 나중에 갈 수 있을 때 시작점으로 이용해서 한 번의 BFS만을 돌고 모든 문서를 찾았었던 아이디어를 이 문제의 최적화에도 응용할 수 있다(응용했었어야 됐는데 안 했음 why? 아직 덜 익숙해서 그런가)
- 얼음을 녹일 때 직전에 녹은 얼음 주변만 확인하면 된다는 사실을 캐치하면 매번 미방문 물을 일일이 확인해서 시작점으로 설정 후 BFS를 돌릴필요 없다
- 현재는 지나가지 못하지만(현재 얼음이지만) 다음 번에 지나갈 수 있기에(지금 있는 곳이 물이기 때문에 다음 턴에는 녹는다) 다음 턴의 시작점으로 이용해서 매번 시작점부터 BFS를 돌지 않아도 된다 이런 방식으로 구현하면 최대 모든 칸이 큐에 들어갈 수 있으므로 O(RC)에 해결할 수 있다
- 앞으로 매 턴에서 BFS를 돌리는 문제 유형의 경우 한 번의 BFS로 가능한지 살펴봐야겠다
- 모든 칸을 정확히 한 번씩만 방문해서 문제를 풀 수 있을지 그럴려면 어떻게 해야하는지에 대한 깊은 고민이 필요하다

### 2. 풀이

- 물 위를 BFS 돌기 위한 큐, 현재 턴에 녹은 얼음이 다음 턴의 시작이므로 그것을 저장할 큐 하나, 백조가 서로 만나는지 확인하기 위해 BFS를 돌리는데 필요한 큐, 얼음에 막혀있어서 진행 못하는 물(다음 시작점)을 저장할 큐 하나 총 네 개의 큐를 지정해놓는다
- 이 문제에서 주의해야할 점은 백조도 물 위에 있기때문에 물로 취급해줘야한다는 것이다
- 백조는 둘 중 아무거나 시작점으로해도 상관 없다, 움직이는게 아니라 거리는 항상 일정하기 때문, 시작점으로 큐에 넣고나서 물로 바꿔준다
- 맵을 돌면서 모든 물을 얼음 BFS 큐의 시작점으로 넣는다
- `두 마리의 백조가 호수에서 살고 있었다. 그렇지만 두 마리는 호수를 덮고 있는 빙판으로 만나지 못한다.` 라는 문제의 조건을 보면 백조끼리 0일 째에 만나는 경우는 없는 것으로 봐도 무방하다

## [20304 - 비밀번호 제작](https://www.acmicpc.net/problem/20304)

### 1. 해결 핵심 아이디어

- 입력 제한으로 봤을 때 브루트포스돌리면 시간초과가 날 것은 자명해서 브루트포스는 아니겠구나 짐작은 했지만, 이 문제가 왜 BFS인가 싶었다, 아예 감도 안오는 문제는 처음임
- 정답을 보고나니 어떤 시각에서 봐야했었는지 알 수 있었다
  - BFS는 가중치가 1 또는 0으로 이루어진 간선을 가진 그래프에서 최단 거리를 구할 수 있다
  - 이 문제에서 정의되는 인접 노드는 안전거리가 1차이나는 노드이다
  - 서로 다른 비트 수를 구하는 방법은 현재 노드를 이진 수로 변환 후, 최대 자리 수 까지 한 비트씩 뒤집어보면서 구할 수 있다
  - 이게 제일 핵심인데, 어떤 수 k와 x가 안전거리가 1일 때, k와 안전거리가 2인 수들을 구하는 방법은 x의 비트 중 한 비트만 뒤집으면 되는 것임
  - $S_{1}S_{2}...S_{N}$ 과 $L_{1}L_{2}...L_{N}$ 의 안전거리가 1이라할 때, $S_{i}$ <> $L_{i}$ 라면, 구간 [1,N]에서 k <> i인 k에 대하여 다음이 성립한다 $S_{k}$ = $L_{k}$, 즉 한 비트만 제외하고 나머지는 같으므로, 여기서 임의의 k에 대해 $L_{k}$가 뒤집어지면 안전거리가 2가 된다
  - 이런식으로 안전거리를 1씩 늘리면서 탐색하고, 로그인 시도한 비밀번호들에 대해 제일 먼 안전거리를 갖는 비밀번호를 출력해주면된다 => 시작점이 여러개인 BFS를 응용할 수 있다

### 2. 풀이

- 비트마스크는 어떤 특정한 알고리즘이 아닌 비트를 활용한 테크닉인데, [블로그](https://mygumi.tistory.com/361)에 어떤 것들이 있는지 잘 나와있다
- 처음에는 서로 다른 비트를 어떻게 찾아내지에 너무 생각이 꽂혀서 정답과는 거리가 먼 생각들 위주로 했던 것 같다
- 근데 BFS의 연습 문제란 것을 알고 푸는 이상, 이 문제를 어떻게 해석해야 BFS로 풀리는지 생각을 해봐야겠다, 근데 너무 어려웠다 이런 류의 문제를 많이 풀어봐야겠다
