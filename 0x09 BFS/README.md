# 0x09 BFS

<!--ts-->

- [0x09 BFS](#0x09-bfs)
  - [0x00 알고리즘 설명](#0x00-알고리즘-설명)
  - [0x01 예시](#0x01-예시)
  - [0x02 응용 1 - 거리측정](#0x02-응용-1---거리측정)
  - [0x03 응용 2 - 시작점이 여러 개 일 때](#0x03-응용-2---시작점이-여러-개-일-때)
  - [0x04 응용 3 - 시작점이 두 종류일 때](#0x04-응용-3---시작점이-두-종류일-때)
  - [0x05 응용 4 - 1차원에서의 BFS](#0x05-응용-4---1차원에서의-bfs)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 6월 28일 화요일 12시 55분 24초 KST -->

<!--te-->

## 0x00 알고리즘 설명

- 외부 윤곽석을 따라서 구분되는 영역의 색을 한번에 바꾸는 것 ⇒ flood fill
- 다차원 배열에서 각 칸을 방문할 때 너비를 우선으로 방문하는 알고리즘
- BFS는 그래프 자료구조에서 모든 노드를 방문하기 위해 고안된 알고리즘
  - 어떤 문제를 해결하는가?
    - 그래프(정점과 간선으로 이루어진 자료구조)의 정점을 모두 방문시킨다. ⇒ 그래프를 탐색한다.
    - 그렇다면 그래프에 대한 이해가 선행되어야한다.

## 0x01 예시

1. 시작하는 칸을 큐에 넣고 방문했다는 표시를 남김
2. 큐에서 원소를 꺼내어 그 칸에 상하좌우로 인접한 칸에 대해 3번을 진행
3. 해당 칸을 이전에 방문했다면 아무 것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 큐에 삽입
4. 큐가 빌 때 까지 2번을 반복

- 모든 칸이 큐에 1번씩 들어가므로 시간복잡도는 칸이 N개일 때 O(N)
- bfs template code

  ![bfs](https://user-images.githubusercontent.com/48282185/159775904-e4fddcc2-b939-454f-a39d-aeb14ad5dc73.png)

  ```cpp
  #include <bits/stdc++.h>

  using namespace std;

  #define x first // 행
  #defind y second // 렬

  int board[500][500];
  int visit[500][500];

  // 상하좌우
  int dx[4] = {1,0,-1,0}; // x가 행
  int dy[4] = {0,1,0,-1}; // y가 열

  int n = 7, m = 10; // n 행, m 열

  int main(void){
   ios::sync_with_stdio(false);
   cin.tie(nullptr);
   queue<pair<int,int>> Q;

   visit[0][0] = true;

   Q.push({0, 0});

   while(!Q.empty()){
    pair<int, int> cur = Q.front(); Q.pop();
    cout << '(' << cur.x << ", " << cur.y << ") ->";
    for(int dir=0; dir < 4; ++dir){
     int nx = cur.x + dx[dir];
     int ny = cur.y + dy[dir];
     if(nx < 0 || nx >=n || ny < 0 || ny >= m) continue;
     // board[nx][ny] == 1인 칸만 방문 가능해서 아래 조건이 들어간 것임
     if(visit[nx][ny] || board[nx][ny] != 1) continue;
     visit[nx][ny] = true;
     Q.push({nx, ny});
    }
   }
  }
  ```

## 0x02 응용 1 - 거리측정

- 최단 경로의 길이를 찾는 문제
- BFS를 이용해 시작점에서 연결된 다른 모든 점으로 최단 경로를 찾을 수 있다.
- 각 점을 방문하면서 체크하는 동작대신 시작점과의 거리를 넣을 수 있는데, 큐에 들어가는 순서와 관련이 있다.(사방으로 퍼지는 느낌)
- 한 점에서 다른 점으로 가는 비용이 다른 경우는 BFS로 최단 거리 구할 수 없다
  - 스텝 바이 스텝으로 인접 노드가 들어가는 원리이기에 최단 거리를 구할 수 있는 것인데, 각 인접 노드로 가는 거리가 다르다고 하면 안 되는 것은 조금만 생각해보면 알 수 있다
- 대표 문제

  [2178번: 미로 탐색](http://boj.kr/2178)

## 0x03 응용 2 - 시작점이 여러 개 일 때

- 대표 문제

  [7569번: 토마토](https://www.acmicpc.net/problem/7569)

- 토마토가 익어간다 ⇒ 인접한 토마토가 익어있다면, 다음날에(거리)가 익게된다. ⇒ bfs 최단 경로를 응용해본다.
- 토마토가 다 익기까지 필요한 최소 일수를 구하려면 모든 익지 않은 토마토들에 대해 가장 가깝게 위치한 익은 토마토까지의 거리를 구해야한다. ⇒ bfs 최단 경로를 응용해본다.
- 익은 토마토의 개수가 여러 개 일 수 있다. ⇒ 모든 익은 토마토들을 시작점을 기준으로 bfs를 돌린다고 가정했을 때 그러면 BFS의 시간 복잡도가 O(NM)이고, 모든 칸이 익은 토마토라 가정했을 때, 최종적인 시간 복잡도는 O($N^{2}M^{2}$)이 되기때문에 시간 내에 해결할 수 없다. 이 문제는 특이하게 시작점(익은 토마토가) 다른 칸과 달리 1로 주어지므로 bfs를 수행하기 전에 알 수 있다.(1926번 그림 문제도 시작점이 여러개였는데 이때는 시작점과 다른 이동할 수 있는 점이 모두 1이었고, 구분이 불가능하여 사전에 시작점인지 확인할 수 없었던 차이가 있다.)
- bfs를 돌 때 큐에 쌓이는 순서는 반드시 거리순이다!

## 0x04 응용 3 - 시작점이 두 종류일 때

- 동시에 두 지점에서 출발해야 문제를 해결할 수 있을 때는 각자 돌 되, 다른 시작점의 이동 경로에 영향을 끼치는 시작점부터 BFS를 돌고 그 이후에 남은 시작점을 BFS돌리면 된다.

  [4179번: 불!](http://boj.kr/4179)

  - 영향을 끼치는 시작점 ⇒ 불은 사람의 탈출경로에 영향을 끼친다
  - 영향을 받는 시작점 ⇒ 사람은 불이 붙은 곳으로는 이동할 수 없다.
  - 불 문제의 경우는 어느 하나가 독립적이지 않고 서로에게 영향을 주는 케이스가 아니다. 불만 사람에게 영향을 주지 사람의 이동경로가 불이 번지는데는 영향이 없었다. 하지만 두 시작점의 경로가 서로에게 상호작용이 된다면, 예로 불과 소방수(불을 끄면서 진행) / 불과 물 등이 있다.(18809 문제) 이 경우는 백트래킹 알고리즘을 추가적으로 알아야 해결할 수 있다. 시간 순으로 동시에 진행해야한다.
  - 이 문제의 경우 미로 외곽이라면 어느 곳이던 탈출가능한 경우인데, BFS를 돌다가 범위를 벗어날 경우 탈출 할 수 있음을 의미한다.

    ```cpp
        
        if (nx < 0 || nx >= n || ny < 0 || ny >= m) {
          // 범위가 벗어났다는 것은 탈출에 성공했음을 의미
          // 큐에 거리 순으로 들어가므로 최초에 탈출한 시간을 출력하면 된다.
          cout << escape[cur.x][cur.y] + 1;
          return 0;
        };
        
      ```

## 0x05 응용 4 - 1차원에서의 BFS

- 수빈이가 이동할 수 있는 위치는 현재 위치 x에서 x+1, x-1, 2x가 될 수 있다. 이렇게 이동할 수 있는 위치를 노드라고 생각하고, 각 위치까지의 거리는 1이다.(가능 노드 - 도달 가능 노드, 자식이 3개) 한 번에 건너뛸 수 있기에 거리가 1이다.

  [1697번: 숨바꼭질](http://boj.kr/1697)

- 범위에 주의해야한다. 동생과 수빈이가 0과 100,000사이에 있다고 하지만 이동 중에는 이를 뛰어넘을 수도 있기 때문이다.

## 0x06 응용 5 - 0-1 BFS

- 대표 문제

  [13549번: 숨바꼭질 3](https://www.acmicpc.net/problem/13549)

- 간선이 0 또는 1로 구성돼있는 그래프에서 최단 거리를 구할 때 사용할 수 있는 방법
- 이 알고리즘을 학습하기 전에, 나중에 명료하게 이해할 수 있는 보조 정리가 필요하다.
  - **보조 정리 : BFS를 실행하는 동안 정점을 포함하는 큐에는 BFS트리의 최대 두 개의 연속한 레벨의 요소만 포함할 수 있습니다. (여기서 레벨이란 한 정점에서 다른 정점까지의 거리) 즉, 연속한 레벨의 요소라면 거리가 1(레벨 1) 또는 거리가 0(같은 레벨 = 레벨 0)**
  - 증명 : BFS트리는 그래프에서 BFS를 실행하는 동안 만들어진 트리이다. BFS는 인접한 정점으로만 이동하므로 큐의 모든 정점은 다른 모든 정점까지 최대 하나의 레벨만 차이나기 때문에 위 보조 정리는 참이다.
- 이 알고리즘은 간선의 가중치가 0 또는 1인 그래프에서 작동하기 때문에 0-1 BFS라고 불린다. 간선의 가중치가 0 또는 1인 임의의 정점 u에 BFS를 실행해보자 다익스트라처럼 큐에는 오직 이전 정점을 통해 최단 거리가 줄어든 정점만 큐에 삽하면서 동시에 큐는 항상 시작점으로부터의 거리에 대해 정렬된 상태이다. 이제, 우리는 u 정점에 있다. 간선(u, v)를 지날 때, 우리는 두 가지 경우 중 한 가지가 일어나는 것을 확신할 수 있다.
  1. v는 u와 같은 레벨이다.
  2. v는 u의 1레벨 아래이다.
- 간선의 가중치가 0 또는 1이기 때문에 위 두 가지 경우만 나오게 된다. 다시 말해,
  1. 가중치가 0이라는 것은 v는 u와 같은 레벨(현재까지 거쳐온 가중치 합)이다.
  2. 가중치가 1이라는 것은 v는 u의 1레벨 아래이다.
- 이미 BFS 실행 중에는 큐에 있는 정점은 최대 2가지의 레벨로만 이루어져 있는 것을 알고 있고, 결론적으로 만약 우리가 u정점에 있다면, 큐는 레벨이 L[u] 또는 L[u]+1인 정점만 들어있다. 그리고, 간선 (u, v)에 대해, L[v]는 L[u] 또는 L[u]+1다. 그러므로, v 정점을 거쳐갈 경우 u 정점과 시작점 사이의 최단거리가 단축되고, u 정점과 v 정점이 같은 레벨이라면 큐의 앞 부분에 v 정점을 삽입한다 u 정점과 v 정점의 레벨이 1 차이나는 경우에는 큐 뒷부분에 삽입한다 이 행위는 BFS가 제대로 작동하기 위해 큐가 정렬된 상태를 유지하기 위함이다(최단 거리를 만들기 위해 같은 레벨인 거 먼저 보고, 같은 레벨인게 없다면 뒤에거 보겠다)
- 하지만, 일반적인 큐 구조를 사용하면 삽입과 정렬된 상태를 유지하는 것을 O(1)만에 수행하지 못하고 우선순위 큐는 정렬된 상태를 유지하는데 O(logN)이 소요된다, 일반적인 큐의 문제는 다음 3가지 기능을 수행하는데 도움이 되는 연산이 없다는 것이다
  1. 다음 정점 추출하기(BFS를 위해 정점 추출)
  2. 가장 앞쪽에 삽입하기(같은 레벨의 정점 삽입)
  3. 가장 뒤쪽에 삽입하기(다른 레벨의 정점 삽입)
- 다행스러운건, 모든 기능을 제공하는 자료구조가 있는데 deque이다 이것이 0-1 BFS에서 덱을 사용하는 이유이다
- 0-1 BFS의 동작
  1. deque front에서 `노드(now)` pop
  2. `인접 노드(next)`를 체크한다.
  3. `현재 노드(now)까지의 비용 + 인접 노드(next)로의 가중치` **<** `인접 노드(next)와 시작점 사이의 최적의 비용` 인 경우 next까지 소요된 최적의 비용을 갱신한다. (<= 가 아니라 < 임에 주의하자)
  4. next로의 가중치가 0이면 deque front에 삽입, 1이면 deque back에 삽입한다
  5. deque가 empty될 때까지 반복
- 0-1 BFS **시간 복잡도 분석**
  - 가중치가 1인 간선을 0번 거쳐서 목적지 도달 가능?(최선) -> 가중치가 1인 간선을 1번 거쳐서 목적지 도달 가능? -> .... -> 가중치가 1인 간선을 E번 거쳐서 목적지 도달 가능?(최악)
  - 이런 식으로 비용이 적은 경로부터 탐색을 하게 되기 때문에 특정 간선을 2번 이상 지나가는 경우는 없다. ⇒ O(E)
  - 똑같이 모든 정점도 2번 이상 경유하는 경우가 없으므로 덱 크기는 최대 |V|이다. ⇒ O(V)
  - 따라서 0-1 BFS는 O(V)+O(E)=O(V+E)의 시간 복잡도를 가지게 된다.

> 바킹독님 유튜브 강의를 참고하여 제작하였습니다.
>
> [BaaarkingDog](https://www.youtube.com/c/BaaarkingDog)
>
> justicehui님 블로그 0-1 BFS 관련 글을 참고하였습니다.
>
> [0-1 BFS 알고리즘](https://justicehui.github.io/medium-algorithm/2018/08/30/01BFS/)
