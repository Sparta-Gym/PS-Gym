# 0x09 BFS

<!--ts-->

- [0x09 BFS](#0x09-bfs)
  - [0x00 알고리즘 설명](#0x00-알고리즘-설명)
  - [0x01 예시](#0x01-예시)
  - [0x02 응용 1 - 거리측정](#0x02-응용-1---거리측정)
  - [0x03 응용 2 - 시작점이 여러 개 일 때](#0x03-응용-2---시작점이-여러-개-일-때)
  - [0x04 응용 3 - 시작점이 두 종류일 때](#0x04-응용-3---시작점이-두-종류일-때)
  - [0x05 응용 4 - 1차원에서의 BFS](#0x05-응용-4---1차원에서의-bfs)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 6월 28일 화요일 12시 55분 24초 KST -->

<!--te-->

## 0x00 알고리즘 설명

- 외부 윤곽석을 따라서 구분되는 영역의 색을 한번에 바꾸는 것 ⇒ flood fill
- 다차원 배열에서 각 칸을 방문할 때 너비를 우선으로 방문하는 알고리즘
- BFS는 그래프 자료구조에서 모든 노드를 방문하기 위해 고안된 알고리즘
  - 어떤 문제를 해결하는가?
    - 그래프(정점과 간선으로 이루어진 자료구조)의 정점을 모두 방문시킨다. ⇒ 그래프를 탐색한다.
    - 그렇다면 그래프에 대한 이해가 선행되어야한다.

## 0x01 예시

1. 시작하는 칸을 큐에 넣고 방문했다는 표시를 남김
2. 큐에서 원소를 꺼내어 그 칸에 상하좌우로 인접한 칸에 대해 3번을 진행
3. 해당 칸을 이전에 방문했다면 아무 것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 큐에 삽입
4. 큐가 빌 때 까지 2번을 반복

- 모든 칸이 큐에 1번씩 들어가므로 시간복잡도는 칸이 N개일 때 O(N)
- bfs template code

  ![bfs](https://user-images.githubusercontent.com/48282185/159775904-e4fddcc2-b939-454f-a39d-aeb14ad5dc73.png)

  ```cpp
  #include <bits/stdc++.h>

  using namespace std;

  #define x first // 행
  #defind y second // 렬

  int board[500][500];
  int visit[500][500];

  // 상하좌우
  int dx[4] = {1,0,-1,0}; // x가 행
  int dy[4] = {0,1,0,-1}; // y가 열

  int n = 7, m = 10; // n 행, m 열

  int main(void){
   ios::sync_with_stdio(false);
   cin.tie(nullptr);
   queue<pair<int,int>> Q;

   visit[0][0] = true;

   Q.push({0, 0});

   while(!Q.empty()){
    pair<int, int> cur = Q.front(); Q.pop();
    cout << '(' << cur.x << ", " << cur.y << ") ->";
    for(int dir=0; dir < 4; ++dir){
     int nx = cur.x + dx[dir];
     int ny = cur.y + dy[dir];
     if(nx < 0 || nx >=n || ny < 0 || ny >= m) continue;
     // board[nx][ny] == 1인 칸만 방문 가능해서 아래 조건이 들어간 것임
     if(visit[nx][ny] || board[nx][ny] != 1) continue;
     visit[nx][ny] = true;
     Q.push({nx, ny});
    }
   }
  }
  ```

## 0x02 응용 1 - 거리측정

- 최단 경로의 길이를 찾는 문제
- BFS를 이용해 시작점에서 연결된 다른 모든 점으로 최단 경로를 찾을 수 있다.
- 각 점을 방문하면서 체크하는 동작대신 시작점과의 거리를 넣을 수 있는데, 큐에 들어가는 순서와 관련이 있다.(사방으로 퍼지는 느낌)
- 한 점에서 다른 점으로 가는 비용이 다른 경우는 BFS로 최단 거리 구할 수 없다
  - 스텝 바이 스텝으로 인접 노드가 들어가는 원리이기에 최단 거리를 구할 수 있는 것인데, 각 인접 노드로 가는 거리가 다르다고 하면 안 되는 것은 조금만 생각해보면 알 수 있다
- 대표 문제

  [2178번: 미로 탐색](http://boj.kr/2178)

## 0x03 응용 2 - 시작점이 여러 개 일 때

- 토마토가 익어간다 ⇒ 인접한 토마토가 익어있다면, 다음날에(거리)가 익게된다. ⇒ bfs 최단 경로를 응용해본다.
- 토마토가 다 익기까지 필요한 최소 일수를 구하려면 모든 익지 않은 토마토들에 대해 가장 가깝게 위치한 익은 토마토까지의 거리를 구해야한다. ⇒ bfs 최단 경로를 응용해본다.
- 익은 토마토의 개수가 여러 개 일 수 있다. ⇒ 모든 익은 토마토들을 시작점을 기준으로 bfs를 돌린다고 가정했을 때 그러면 BFS의 시간 복잡도가 O(NM)이고, 모든 칸이 익은 토마토라 가정했을 때, 최종적인 시간 복잡도는 O(N^2 \* M^2)이 되기때문에 시간 내에 해결할 수 없다. 이 문제는 특이하게 시작점(익은 토마토가) 다른 칸과 달리 -1로 주어지므로 bfs를 수행하기 전에 알 수 있다.(1926번 그림 문제도 시작점이 여러개였는데 이때는 시작점과 다른 이동할 수 있는 점이 모두 1이었고, 구분이 불가능하여 사전에시작점인지 확인할 수 없었던 차이가 있다.)
- bfs를 돌 때 큐에 쌓이는 순서는 반드시 거리순이다!

## 0x04 응용 3 - 시작점이 두 종류일 때

- 동시에 두 지점에서 출발해야 문제를 해결할 수 있을 때는 각자 돌 되, 다른 시작점의 이동 경로에 영향을 끼치는 시작점부터 BFS를 돌고 그 이후에 남은 시작점을 BFS돌리면 된다.

  [4179번: 불!](http://boj.kr/4179)

  - 영향을 끼치는 시작점 ⇒ 불은 사람의 탈출경로에 영향을 끼친다
  - 영향을 받는 시작점 ⇒ 사람은 불이 붙은 곳으로는 이동할 수 없다.
  - 불 문제의 경우는 어느 하나가 독립적이지 않고 서로에게 영향을 주는 케이스가 아니다. 불만 사람에게 영향을 주지 사람의 이동경로가 불이 번지는데는 영향이 없었다. 하지만 두 시작점의 경로가 서로에게 상호작용이 된다면, 예로 불과 소방수(불을 끄면서 진행) / 불과 물 등이 있다.(18809 문제) 이 경우는 백트래킹 알고리즘을 추가적으로 알아야 해결할 수 있다. 시간 순으로 동시에 진행해야한다.
  - 이 문제의 경우 미로 외곽이라면 어느 곳이던 탈출가능한 경우인데, BFS를 돌다가 범위를 벗어날 경우 탈출 할 수 있음을 의미한다.

        ```cpp
        if (nx < 0 || nx >= n || ny < 0 || ny >= m) {
          // 범위가 벗어났다는 것은 탈출에 성공했음을 의미
          // 큐에 거리 순으로 들어가므로 최초에 탈출한 시간을 출력하면 된다.
          cout << escape[cur.x][cur.y] + 1;
          return 0;
        };
        ```

## 0x05 응용 4 - 1차원에서의 BFS

- 수빈이가 이동할 수 있는 위치는 현재 위치 x에서 x+1, x-1, 2x가 될 수 있다. 이렇게 이동할 수 있는 위치를 노드라고 생각하고, 각 위치까지의 거리는 1이다.(가능 노드 - 도달 가능 노드, 자식이 3개) 한 번에 건너뛸 수 있기에 거리가 1이다.

  [1697번: 숨바꼭질](http://boj.kr/1697)

- 범위에 주의해야한다. 동생과 수빈이가 0과 100,000사이에 있다고 하지만 이동 중에는 이를 뛰어넘을 수도 있기 때문이다.

> 바킹독님 유튜브 강의를 참고하여 제작하였습니다.
>
> [BaaarkingDog](https://www.youtube.com/c/BaaarkingDog)
