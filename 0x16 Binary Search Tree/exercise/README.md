# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/7662" rel="nofollow">7662 - 이중 우선순위 큐</a>](#7662---이중-우선순위-큐)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 코멘트](#2-코멘트)
  - [<a href="https://www.acmicpc.net/problem/1202" rel="nofollow">1202 - 보석 도둑</a>](#1202---보석-도둑)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 코멘트](#2-코멘트-1)
  - [<a href="https://www.acmicpc.net/problem/21939" rel="nofollow">21939 - 문제 추천 시스템 Version 1</a>](#21939---문제-추천-시스템-version-1)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 코멘트](#2-코멘트-2)
  - [<a href="https://www.acmicpc.net/problem/23326" rel="nofollow">23326 - 홍익 투어리스트</a>](#23326---홍익-투어리스트)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 코멘트](#2-코멘트-3)
  - [<a href="https://www.acmicpc.net/problem/21944" rel="nofollow">21944 - 문제 추천 시스템 Version 2</a>](#21944---문제-추천-시스템-version-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 코멘트](#2-코멘트-4)
  - [<a href="https://www.acmicpc.net/problem/19700" rel="nofollow">19700 - 수업</a>](#19700---수업)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 코멘트](#2-코멘트-5)
  - [<a href="https://www.acmicpc.net/problem/1539" rel="nofollow">1539 - 이진 검색 트리</a>](#1539---이진-검색-트리)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 코멘트](#2-코멘트-6)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 11월  7일 월요일 17시 14분 43초 KST -->

<!--te-->

## [7662 - 이중 우선순위 큐](https://www.acmicpc.net/problem/7662)

### 1. 해결 핵심 아이디어

- 중복 허용되니 multimap을 사용하자
- 삽입, 삭제가 빈번하고 최대값, 최소값을 매번 찾아주는데 BST는 정렬돼있으므로 begin()이 최소값을, prev(end())가 최대값을 가리키기때문에 삭제도 간단하다

### 2. 코멘트

- STL warm up용 문제

## [1202 - 보석 도둑](https://www.acmicpc.net/problem/1202)

### 1. 해결 핵심 아이디어

- 그리디 풀이를 쉽게 떠올릴 수 있는데 이게 맞는지 증명을 해봐야한다
  - 내가 생각한 풀이는 제일 가격이 높은 보석 순으로 가방에 담되, 이 가방을 선택할 때는 보석의 무게보다 크면서 제일 작은 정수를 선택하자이다
  - 일단 첫 번째로 제일 가격이 높은 순으로 담는게 최적의 답인지 부터 따져봐야하고, 두 번째는 가방을 선택할 때 보석의 무게보다 크면서 제일 작은 정수를 선택하는게 맞는지 봐야한다
  - 가방의 무게부터 보자
    - 귀류법으로 ‘가장 가격이 높은 보석 x를 해당 보석을 담을 수 있는 가방 중 최대 무게가 A보다 큰 가방 B를 이용해 보석을 담는게 더 이득인 경우가 있는가?’ 를 증명해보자
      - A말고 가방 B를 이용해서 더 이득인 경우가 있다고 하자. 만약 그 경우 가방 A에 다른 보석 y가 있다면 가방 A와 가방 B의 내용물을 바꿔도 제한 조건에 위배되지않는다, 가방 A에 다른 보석이 없다면 보석 x를 가방 B에서 A로 옮겨도 제한 조건에 위배되지 않는다. 즉, 가방 B에 x를 담는게 가방 A에 x를 담는 것보다 이득인 경우는 없다
    - 귀류법은 모순을 보이거나 그런 경우가 존재하지 않음을 보이면 된다
  - 제일 가격이 높은 순으로 담는게 최적인가를 보자
    - 귀류법으로 ‘가장 가격이 높은 보석을 담을 수 있는 가방 중 최대 무게가 가장 작은 A가 존재하는데도 불구하고 가방에 넣지 않는게 최적의 답이 될 수 있는가?’를 증명해보자
      - 가장 가격이 높은 보석 x를 담지 않고 최적의 해가 됬다고 가정하자 A에는 다른 보석 y가 담겼을 경우, x와 y를 교체하는 것이 이득이다. 또 A가 비었다고 가정하면 A에 x를 담을 수 있으므로 최적의 답이 아니다. 따라서 가장 가격이 높은 보석을 담을 수 있는 상황이라면 담는 게 최적이다
  - 그러면 왜 이 문제가 이진 검색 트리로 풀면 좋은지를 봐야하는데 가방이 선택됬다는 것은 후보지에서 제외시켜야 하고, 제거를 해야한다는 뜻이다. 제일 최적의 가방을 이진탐색으로 찾을 수 있다고 해도 제거를 해야하니 find도 O(logN), erase도 O(logN)인 이진 검색 트리를 사용하면 좋다

### 2. 코멘트

- N이 커서 O($N^2$)은 통과가 안될 상황이고 원소의 대소 관계가 필요한데 삽입 혹은 삭제가 빈번한 경우
- 꼭 대소 관계가 아니더라도 그냥 key로 value를 빠르게 찾거나 원소의 삽입 / 검색 / 삭제만 빠르게 처리를 해주어야 할 경우에도 고려해볼 옵션

## [21939 - 문제 추천 시스템 Version 1](https://www.acmicpc.net/problem/21939)

### 1. 해결 핵심 아이디어

- 난이도와 문제번호 중 무엇을 key로 둘지 고민했는데, 들어오는 쿼리들을 보면 문제번호와 난이도 모두 한 번에 찾을 수 있어야하기에 <문제 번호, 난이도> 쌍의 BST하나 <난이도, [문제 번호]> 쌍의 BST하나 두 개를 두었다
- <난이도, [문제 번호]> 쌍의 BST의 경우 문제 번호가 항상 정렬되있어햐 하기에 문제 번호들을 담는 컨테이너를 set으로 두었다
- add의 경우 단순히 추가해주면 되고, solved의 경우 두 BST에서 해당되는 데이터를 삭제해주면 되고, recommend의 경우 최대값은 제일 높은 난이도의 경우 마지막 데이터의 마지막 문제 번호를 출력, 최솟값은 제일 낮은 난이도의 경우 처음 데이터의 첫 문제 번호를 출력해주면 된다

### 2. 코멘트

- 문제번호를 삭제하면서 set 컨테이너가 비었을 때, 해당 pair자체를 날려버려야한다, 그렇지 않으면 <키, 빈 set>으로 남아있게돼서, 잘못된 주소를 참조한다

## [23326 - 홍익 투어리스트](https://www.acmicpc.net/problem/23326)

### 1. 해결 핵심 아이디어

- 처음 접근했던 방식은 현재 위치에 변경에 따른 거리 갱신과 제일 가까운 거리를 산출해줘야하기에 <거리, 구역>으로 BST를 두고 알고리즘을 설계했는데, 시간 초과를 받았다
- 생각해보니 첫 접근방식은 현재 위치가 변경될 때 기존에 유지하고있던 BST를 초기화하고 모든 명소에 대해 다시 거리를 계산해줘야하기 때문에 비효율적이고 여기서 시간 초과가 났다
- 다른 방식을 고민해보다가 생각이 안나서 정답코드를 참고하였다
- 명소의 개수가 최대 50만이므로 만약 모든 쿼리가 현재 위치를 바꾸는 쿼리라면 50만 \* 10만 = 5조라서 시간초과가 나고, 결국에는 현재 위치에서 가장 가까운 거리는 lower_bound이되, 원형이므로, 제일 가까운 명소가 현재 위치번호보다 작다면 이를 보정해줘야한다
- 명소의 개수가 굉장히 많을 수 있으므로 BST로 관리하여 명소를 조회할 때 모든 구역을 살펴보는게 아닌 명소만 살펴보게한다

### 2. 코멘트

- 원형에서 두 거리 차이 구할 때 모듈로를 사용하였는데 여기서 1-indexed라서 보정이 필요하여, 원 구역 번호를 1씩 좌로 평행이동 시키고, 모듈로를 적용 후 다시 우로 평행이동 시켰다
- 좀 충격적인게 있는데, 모듈로가 덧셈 / 뺄셈보다 우선순위가 높은 것을 반대로 알고 있어서 여기서 디버깅을 했다, 왜 반대로 알고있었지??

## [21944 - 문제 추천 시스템 Version 2](https://www.acmicpc.net/problem/21944)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [19700 - 수업](https://www.acmicpc.net/problem/19700)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [1539 - 이진 검색 트리](https://www.acmicpc.net/problem/1539)

### 1. 해결 핵심 아이디어

### 2. 코멘트
