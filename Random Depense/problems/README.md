# 문제 풀이 기록

## 13422 - 도둑

- 성공
- 브루트 포스

## 7511 - 소셜 네트워킹 어플리케이션

- 성공
- union-find

## 2800 - 괄호 제거

- 성공
- 문자열, 비트마스킹(부분 집합 생성)

## 16195 - 1, 2, 3 더하기 9

- 성공
- 2차원 다이나믹 프로그래밍

## 13905 - 세부

- 성공
- parametric search, bfs
- 이 문제를 MST를 이용해서 풀 수 있다는데 어떻게 하는건지 고민해보자

## 16206 - 롤케이크

- 실패
- 그리디
- 실패이유
  - 1. 알고리즘 정당성
    - 10보다 크면서 제일 작은 정수를 먼저 잘라야 더 적은 커팅 횟수로 10을 더 많이 만들 수 있기 때문에 그리디 문제란 건 쉽게 알 수 있었다
    - 하지만 10의 배수를 먼저 처리해줘야한다는 점을 간과했다
    - 10의 배수가 10의 배수가 아닌 수보다 10을 더 많이 만들 수 있음은 자명하다
  - 2. 구현 이슈
    - 처음에는 자르고 나서 10보다 크면 우선순위 큐에 넣어서 다시 시작했는데
    - 나머지와 몫을 이용하면 그럴 필요가 없었는데.. 그것때문에 더 오래걸렸음

## 17123 - 배열 놀이

- 실패
- 누적합
- 실패이유
  - 완탐 말고는 풀이 방법을 제한 시간 내에 떠올리지 못했음
  - 완탐은 매 연산마다 O($N^2$)의 시간복잡도를 갖기 때문에 시간초과가 난다
  - 즉 매 연산마다 일일이 연산을 할 수는 없다
  - 누적합을 이용하면 매번 연산을 할 필요가 없이 누적해뒀다가 나중에 한 번에 더하면 된다
    ![description 17123](https://user-images.githubusercontent.com/48282185/216264470-bd9b9568-6953-42df-be3a-b2c0212716b9.png)
- 시간이 주어졌더라도 누적합에 대한 특성을 잘 이해하지 못해서 이용할 생각을 못했을 것 같다
- 누적합의 특성(어디에 써먹을 수 있는지)에 대한 공부 필요

## 2792 - 보석 상자

- 성공
- parametric search
- 처음에는 다이나믹 프로그래밍으로 접근해보려했다 dp[i][j][k] = i번째 학생이 j번 보석을 k개 골랐을 때 나오는 최소 질투심을 하려했는데, 이러면 모든 학생에게 분배가 끝난상태를 알고있어야된다, 즉 모든 경우를 알아야 구할 수 있기에 완전탐색과 다를게 없었다, 범위를 보니 이분 탐색 문제임을 눈치 챘다
