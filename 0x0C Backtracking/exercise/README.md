# Learning About

## [15649 - N과 M (1)](https://www.acmicpc.net/problem/15649)

### 1. 해결 핵심 아이디어

- 백트래킹 알고리즘을 대표하는 문제
- 조합의 경우의 수는 모든 경우를 나열해봐야함을 알 수 있다 => 완전 탐색해야함을 의미
- 길이가 i인 수열에서 1 ~ i까지 쓰인 수를 알고있으면, 중복을 허용하지 않는 경우의 수에서 i+ 1 ~ n까지 쓰일 수의 집합을 알 수 있음
- 다시 말하면, i + 1번 단계에서 사용할 수를 집합에서 임의로 하나 뽑아낼 수 있음
- 완전 탐색으로 풀려고 하면, 모든 경우를 허용하게 되어 중복을 허락하지 않는다는 문제의 제약 조건을 지킬 수 없음
- 수열의 한자리 채우는 과정이 반복되고 있음 => 재귀로 구현하면 편함을 알 수 있음, 물론 반복문을 사용할 수도 있는데, 재귀보다 구현이 까다로움

### 2. 풀이

- 백트래킹의 전형적인 형태로 기억해두면 좋을 것 같다

```cpp
void back_track(int cur) {
  if (cur == m) {
    // 문제에서 요구한 조건에 만족하는 결과가 완성
    return;
  }
  for (int i = 1; i <= n; ++i) {
    if (is_used[i]) continue; // 불가능한 경우는 더 이상 보지 않는다
    is_used[i] = true;
    make_seq(cur + 1);
    is_used[i] = false;
  }
}
```

## [9663 - N-Queen](https://www.acmicpc.net/problem/9663)

### 1. 해결 핵심 아이디어

- 이 문제가 백트래킹으로 풀리는 이유는 퀸이 체스판 위의 임의의 좌표에 위치하는 모든 경우의 수에서 미리 공격이 불가능한 위치를 알 수 있고, 공격 경로 상에 퀸이 놓이는 것을 사전 차단할 수 있기 때문이다
- 퀸을 체스판에 놓는 작업이 반복되기 때문에 재귀를 사용할 수 있음
- 다음 행에 퀸을 놓을 때 `/` 방향과 `\` 방향 대각선과 같은 열에 위치하는지 확인 후 거기에 놓인 다면, 사전 차단한다
- 같은 대각선 상에 위치하는 것은 y = x + k와 y = -x + k 직선 상에서 같은 점에 놓이는지 보면 된다.
- 매 케이스마다 공격 루트에 놓이는지 검사하는 것은 비효율적이라 i단계에서 퀸을 놓으면, i+1단계에서 퀸을 놓을 수 없는 것도 정해지므로, 미리 해당 좌표들에 갈 수 없는 표시를 해놓으면, 각 스텝마다 일일이 검사하지 않아도 된다

### 2. 풀이

- 시간 제한을 보면 10초란 것을 알 수 있는데, 이처럼 시간이 오래걸리는 문제들을 자주 볼 수 있는데, 백트래킹의 존재 의의 자체가 불가능한 케이스를 미리 걸러 매우 오래 걸리는 완전 탐색문제의 시간 단축을 하기 위함이라고 볼 수 있다
- 재귀함수의 경우 상태 공간트리의 노드의 수로 시간복잡도를 계산하는데, 가지치기가 많이 될 수록 시간복잡도 계산이 어려워진다, 때문에 제일 오래 걸리는 케이스(입력 범위에서 가장 큰 값)을 넣어서 시간을 측정해보자
- 시간을 측정할 때는 릴리즈 모드로 컴파일하자

## [1182 - 부분수열의 합](https://www.acmicpc.net/problem/1182)

### 1. 해결 핵심 아이디어

- 모든 부분 집합을 구해야하는 완전 탐색에서 n의 크기가 최대 20이라 시간복잡도는 최대 O($2^20$)이고, 시간 제한 내에 통과하기 충분하다
- 현재 보고 있는 i번 원소가 중간 결과에 더해졌을 때 s가 될 수 있는지 봐야하고, 만약 i번 원소가 중간 결과에 더해졌을 때 s보다 커지거나 앞으로 남은 모든 수를 더해도 s보다 작을 때 더 이상 보지 않아도 되는 pruning을 적용해볼 수 있겠지만, 그러면 구현이 복잡해진다
- i번 원소를 더하지 않고 다음단계로 넘어간다는 의미는 부분 집합에 i번 원소를 포함시키지 않겠다는 의미로 해석하면 된다

### 2. 풀이

- 구현의 그닥 어렵지 않음, pruning을 적용했으면 따질 경우가 많아서 복잡했을 것임, 같은 문제에서 n의 최대 크기가 커진다면 적용해봐야될 옵션
- 크기가 양수인 부분수열을 따지는 문제로, 모든 원소가 포함되지 않는 공집합이 생성될 수 있으므로, 이 경우를 제외해야함에 주의하자

## [15650 - N과 M (2)](https://www.acmicpc.net/problem/15650)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 오름차순을 유지하는 수열만 뽑아내는 것이었는데, 그 말은 오름 차순을 유지하지 않는 경우의 수라면 pruning을 통해 거르면 된다

### 2. 풀이

- `cur == 0 || cur > 0 && seq[cur-1] < seq[cur]`일 때만 재귀호출하게 구현했음
- 정답 코드를 보니 seq[cur] 다음에 올 수는 seq[cur] + 1이므로 반복문을 1부터 n까지 돌지 않고 시작 값을 seq[cur] + 1로 끝 값을 n으로 해서 반복문을 돌림

## [15651 - N과 M (3)](https://www.acmicpc.net/problem/15651)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 중복을 허용했는데, pruning없이 길이가 m이 될 때까지 모든 가능한 경우를 탐색하면 된다

### 2. 풀이

- pruning관련 코드를 없애면 해결 가능

## [15652 - N과 M (4)](https://www.acmicpc.net/problem/15652)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 중복 허용과 비내름차순을 유지했어야 했다, 중복에 대한 pruning은 없어도 되고, 비내림차순을 유지하게, 이를 만족하지 않는 수열은 pruning하였음

### 2. 풀이

- `cur == 0 || cur > 0 && seq[cur-1] <= seq[cur]`일 때만 재귀호출하게 구현했음

## [15654 - N과 M (5)](https://www.acmicpc.net/problem/15654)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 1부터 N사이의 값을 갖는 수열이 아니라 직접 입력받는 방식었고, 출력을 오름차순으로 해주기 위해 입력받은 후, 정렬해줬다
- 중복을 방지하기 위한 pruning이 필요했고, 이 수가 쓰였는지 판단하는 배열 is_used의 크기를 1e4 + 5정도로 잡아줬다

### 2. 풀이

- 정답코드를 보니, 15649 - N과 M과 동일한 수열을 구하고, 이걸 입력받은 배열의 인덱스로 만들어줘서, is_used의 크기를 10으로 잡아서 해결할 수 있네 => 이 방식을 사용하면 메모리 크기 이득을 볼 수 있어서 내가 푼 솔루션보다 더 좋은 방법이다

## [15655 - N과 M (6)](https://www.acmicpc.net/problem/15655)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 1부터 N사이의 값을 갖는 수열이 아니라 직접 입력받고 오름차순된 수열만 출력해줘야했고, 출력을 오름차순으로 해주기 위해 입력받은 후 정렬해줬다

### 2. 풀이

- 이전 문제에서 본 정답코드의 형태를 응용해보았음(인덱스를 이용하는 방식과 반복문의 시작점을 변경)

## [15656 - N과 M (7)](https://www.acmicpc.net/problem/15656)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 1부터 N사이의 값을 갖는 수열이 아니라 직접 입력받고 중복을 허용한다 출력을 오름차순으로 해주기 위해 입력받은 후 정렬해줬다

### 2. 풀이

- 중복에 대한 pruning만 없애주면 됨

## [15657 - N과 M (8)](https://www.acmicpc.net/problem/15657)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 1부터 N사이의 값을 갖는 수열이 아니라 직접 입력받고 중복을 허용하고 비오름차순으로만 출력해줘야한다
- 출력을 오름차순으로 해주기 위해 입력받은 후 정렬해줬다

### 2. 풀이

- 커서가 0이 아닐 때, 반복문의 시작점을 이전 원소와 동일하게 해주면 비내림차순으로 수열을 생성할 수 있다
- 커서가 0이면 0으로 설정해주면 된다

## [15663 - N과 M (9)](https://www.acmicpc.net/problem/15663)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 직접 입력 받으면서 입력에 중복된 수가 있고 중복된 수열을 출력하면 안된다는 점이다
- 출력을 오름차순으로 해주기 위해 입력 받은 후 정렬해줬다
- 중복 수열이 출력되지 않기 위해 중복되는 수열이 나올 경우 pruning해줄 필요가 있다
- 다행히 사전 순으로 정렬되므로 원소가 중복된다면 서로 인접해있고, 이 점을 이용하면, 중복 검사를 쉽게 할 수 있다
- pruning 조건을 `is_used[i] || dup == in[i]`로 해줬는데, i번에 위치하는 수가 사용됐거나 사용안됐지만 앞서 나온 수랑 같으면 더 이상 진행되지않는다는 뜻인데 중복이 발생하는 이유를 살펴보면, 같은 자리에 중복된 수가 나오면 중복되는 케이스로 정의할 수 있는데, 이를 막기 위해서는 같은 자리에 중복된 수가 나오는 경우를 사전 차단하면된다, 예를 들어 8이 중복으로 입력되었을 때, 숫자 8로 시작하는 길이가 m인 수열을 만들었으면, 다시 8로 시작하는 수열을 만들면 안된다는 의미임
- 각 재귀함수의 역할은 수열의 i번째 숫자를 결정하는 것인데, 8이 첫번째로 쓰인 케이스가 모두 끝났으면 그 다음 수도 8인데, 수열을 생성하면서 dup를 8로 지정해놨기때문에 다음 턴에서 첫번째 자리에 dup == in[i]에 막혀서 8이 올 수 없다
- 이처럼 무언가를 방지하고 싶으면 그 상황이 왜 일어나는지 알고, 어떻게 막을지 생각해야한다

### 2. 풀이

- 처음에는 단순히 set 자료구조에 저장해서 정답을 내긴했지만, 올바른 알고리즘이라면 아예 중복된 케이스를 생성해내지 말아야한다

## [15664 - N과 M (10)](https://www.acmicpc.net/problem/15664)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 직접 입력 받으면서 입력에 중복된 수가 있는 상황에서 중복된 수열을 만들 수 없고 수열이 비내림차순을 유지해야한다
- 출력을 사전순으로 해주기 위해 입력 받은 후 정렬해줬다
- 비내림차순을 유지하기 위해서는 i+1번 자리에 위치한 수가 i번 자리에 위치한 수보다 크거나 같아야한다

### 2. 풀이

- 비내림차순을 유지시키위한 방법은 두 가지가 있는데, 자리에 놓기 전에 cur > 0 && seq[cur-1]을 보고 in[i]가 크면 pruning을 시키거나 입력 받고 정렬시키기 때문에 다음 스텝의 재귀함수에 반복문의 시작점을 i+1로 줘서 i번 원소보다 크거나 같게 만들 수 있다, 두 번째 방법을 쓰면 is_used를 관리할 필요가 없어지는데, 한 번 본 원소는 더 이상 보지 않기 때문에 사용됬었는지 체크할 필요가 없어지기 때문이다, 후자의 경우 메모리를 아낄 수 있고 유의미한 차이는 없겠지만 반복문의 횟수가 줄어드는 이점이 있어서 더 좋은 방법으로 볼 수 있겠다

## [15665 - N과 M (11)](https://www.acmicpc.net/problem/15665)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 직접 입력 받으면서 입력에 중복된 수가 있는 상황에서 중복된 수열을 만들 수 없고 만들어지는 수열의 원소에 중복을 허용한다
- 출력을 사전순으로 해주기 위해 입력 받은 후 정렬해줬다

### 2. 풀이

- 중복을 허용하면, 중복을 거르기 위한 pruning부분만 제거하면 됨

## [15666 - N과 M (12)](https://www.acmicpc.net/problem/15666)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 직접 입력 받으면서 입력에 중복된 수가 있는 상황에서 중복된 수열을 만들 수 없고 만들어지는 수열의 원소에 중복을 허용하고 비내림차순을 유지해야한다
- 출력을 사전순으로 해주기 위해 입력 받은 후 정렬해줬다

### 2. 풀이

- 15664 - N과 M (10)의 아이디어를 이용해서 다음 스텝의 재귀 함수 반복문을 현재 스텝의 자리수로 주면 다음 스텝에서 수열에 위치할 원소는 현재 스텝의 원소와 같거나 크게된다

## [6603 - 로또](https://www.acmicpc.net/problem/6603)

### 1. 해결 핵심 아이디어

- 중복없이 오름차순을 유지하는 부분 수열을 만들어내는 문제
- 다음 스텝에 현재 스텝에 몇 번째 숫자를 채웠는지 넘겨서 이 숫자보다 작거나 같은 수 못나오게 만들었음

### 2. 풀이

- 풀이에 특별할 것은 없었음

## [1759 - 암호 만들기](https://www.acmicpc.net/problem/1759)

### 1. 해결 핵심 아이디어

- 중복 미허용에 오름 차순인데, 반드시 모음 1개이상, 자음 2개 이상으로 이뤄져야한다, 근데 L에는 모음과 자음이 반드시 주어진다는 조건이 없기에 모음이 하나도 주어지지 않는 경우나 자음이 1개만 주어지는 상황에서는 암호를 만들지 못한다
- 처음에는 좀 복잡하게 생각해서 pruning과정에서 모음과 자음의 개수를 만족하는지 체크하려고 했는데, 이러면 너무 복잡해서, 시간 복잡도를 계산해보니 최대 15개 중 15개를 뽑는 가짓수라서 시간 제한내에 충분히 통과하기에 중복을 허용하지 않는 오름차순 문자열을 만든 다음 모음을 최소 1개 이상, 자음을 최소 2개 이상 포함하는지 보고, 아니라면 폐기했다

### 2. 풀이

- 문제의 모든 제약조건을 pruning하려다보면 복잡해지는 경우가 많은데, 제약 조건의 일부, 위 문제에서는 중복 미허용과 오름차순을 어기는 케이스에만 pruning해주고, 다른 제약 조건들은 만들고 나서 검사해도된다
- 제약조건이 많을 때는 pruning 한 번으로 모든 제약조건을 지키려고 하지마라

## [1941 - 소문난 칠공주](https://www.acmicpc.net/problem/1941)

### 1. 해결 핵심 아이디어

- 처음 내가 시도했던 방식은 N-Queen 문제처럼 S를 발견했을 때 행을 내려가면서 놓을 수 있는 위치(7개 내에 포함되면서 인접)인지 보려했었는데, 너무 고려할 것도 많고 변수도 많아서 다른 솔루션을 생각해봤는데, 배열을 문자열을 하나로 펼쳐놓고 단위로 검사해보는 방법이었는데, 잘라서하자니 `ㅜ` `ㅟ` 이런 형태도 가능해서 그것도 불가능해서 1시간 고민 끝에 답을 보았음
- 답에서는 배열을 문자열 하나로 펼쳐놓고(길이 25) 거기서 7개를 뽑는 조합으로 모든 조합을 시도해서 이 뽑힌 문자들이 인접해있는지 검사해보는 방식이었다
- 조합의 경우의 수는 25C7 = 480700으로 충분히 시간 제한내에 들어올 수 있기에 가능한 방법이다
- 뽑힌 문자들끼리 가로 혹은 세로로 인접하면서 연결됐는지 확인하는 방법은 여러가지 있지만 BFS나 DFS를 이용하면 쉽게 확인할 수 있는데, 상하좌우 인접 탐색하면서 7개가 모두 연결되었는지 그리고 7개 중 'S'가 4개 이상인지 확인하면된다
- 배열을 하나의 문자열로 바꿔보는 생각까지는 했으나 거기서 너무 인접이라는 단어에 매몰된 나머지 구간으로 나눠서 슬라이딩 윈도우 방식으로 검사해야한다고만 생각해서 불가능하다고 판단했던 것 같다 이부분이 좀 아쉬움
- 백트래킹 유형은 완전탐색과 비슷한데, 시간제한을 만족할 수 있게 입력 크기를 주면서 경우의 수를 모두 만들어보면서 아닌거만 걸러내는 방식이 많이 쓰이는 유형으로 풀어볼 수 있게 출제되는 듯 하다

### 2. 풀이

- 백트래킹이라고 너무 pruning에만 집중하려고하지말고 어떤게 정답이 될 지 모르는(모든 경우를 탐색해야하는) 경우의 수를 생성한 다음 안되는 것을 잘라내는 것도 백트래킹이라고 볼 수 있음
- 경우를 생성함에 있어서 모든 경우를 만들어도 시간제한내에 들어올 수 있다면 모든 경우를 만들고 정답이 되는 것만 골라내면됨
- 모든 경우를 만드는데 시간이 걸린다면 경우를 만드는데 pruning을 이용해서 사전 차단하면 됨
- 이 문제를 틀렸던 이유를 곰곰히 생각해보면 나는 인접과 S가 4개이상인지를 atomic하게 고려하려고 해서 문제가 복잡해졌었는데, 암호만들기 문제처럼 S가 4개 이상이되는 문자열만 만들어내고, 그 이후 인접 검사를 한다면 이 문제도 백트래킹을 사용해서 풀었다고 볼 수 있음

## [16987 - 계란으로 계란치기](https://www.acmicpc.net/problem/16987)

### 1. 해결 핵심 아이디어

- 모든 가능한 순서쌍을 만든다, 순서쌍의 정의는 (x, y), y는 x를 제외한 8보다 작거나 같은 자연수 이렇게 순서쌍만들어놓고 쳐서 몇 개 깨지는지 본다, 총 n개의 순서쌍이 만들어짐
- 이렇게 모든 순서쌍을 만들고 계란깨는 시뮬레이션을 돌려서 가능한 경우에(깨지지않은 계란으로 깨지지않은 계란 치는 경우) 총 몇개의 계란이 깨지는지 본다
- 총 8개의 순서쌍이 만들어지므로 $8^8$ = 16777216이라 시간제한 내에 들어올 수 있음
- 순서쌍을 만들때 적절한 자료구조를 생각해보다가 pair 배열로 한 경우 당 n개를 담을까하다가 (x,y)를 x \* 10 + y로 만들고 수열을 만들어줬다
- 가능한 경우만 수열을 만들게끔 pruning을 할 수 있었는데, 역시나 정답코드를 보니 가능한 경우만 생성하여 계란수를 카운트하였다
- 현재 들고있는 계란이 깨졌거나 현재 들고있는 계란을 제외한 모든 계란이 깨졌는지 확인하여 1차 pruning을 하고, 그게 아니라면 자신을 제외한 다른 계란을 골라야하는데, 그 계란이 깨졌는지 확인하는 과정에서 2차 pruning을 하게된다, 그래서 최종적으로 n개가 다 뽑혔으면 계란수를 최대값 갱신을 해준다

### 2. 풀이

- 이 문제와 같이 pruning이 까다롭지 않은 문제는 pruning을 하여 가능한 경우만 생성해주자

## [18809 - Gaaaaaaaaaarden](https://www.acmicpc.net/problem/18809)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [1799 - 비숍](https://www.acmicpc.net/problem/1799)

### 1. 해결 핵심 아이디어

### 2. 풀이
