# Learning About

## [15649 - N과 M (1)](https://www.acmicpc.net/problem/15649)

### 1. 해결 핵심 아이디어

- 백트래킹 알고리즘을 대표하는 문제
- 조합의 경우의 수는 모든 경우를 나열해봐야함을 알 수 있다 => 완전 탐색해야함을 의미
- 길이가 i인 수열에서 1 ~ i까지 쓰인 수를 알고있으면, 중복을 허용하지 않는 경우의 수에서 i+ 1 ~ n까지 쓰일 수의 집합을 알 수 있음
- 다시 말하면, i + 1번 단계에서 사용할 수를 집합에서 임의로 하나 뽑아낼 수 있음
- 완전 탐색으로 풀려고 하면, 모든 경우를 허용하게 되어 중복을 허락하지 않는다는 문제의 제약 조건을 지킬 수 없음
- 수열의 한자리 채우는 과정이 반복되고 있음 => 재귀로 구현하면 편함을 알 수 있음, 물론 반복문을 사용할 수도 있는데, 재귀보다 구현이 까다로움

### 2. 풀이

- 백트래킹의 전형적인 형태로 기억해두면 좋을 것 같다

```cpp
void back_track(int cur) {
  if (cur == m) {
    // 문제에서 요구한 조건에 만족하는 결과가 완성
    return;
  }
  for (int i = 1; i <= n; ++i) {
    if (is_used[i]) continue; // 불가능한 경우는 더 이상 보지 않는다
    is_used[i] = true;
    make_seq(cur + 1);
    is_used[i] = false;
  }
}
```

## [9663 - N-Queen](https://www.acmicpc.net/problem/9663)

### 1. 해결 핵심 아이디어

- 이 문제가 백트래킹으로 풀리는 이유는 퀸이 체스판 위의 임의의 좌표에 위치하는 모든 경우의 수에서 미리 공격이 불가능한 위치를 알 수 있고, 공격 경로 상에 퀸이 놓이는 것을 사전 차단할 수 있기 때문이다
- 퀸을 체스판에 놓는 작업이 반복되기 때문에 재귀를 사용할 수 있음
- 다음 행에 퀸을 놓을 때 `/` 방향과 `\` 방향 대각선과 같은 열에 위치하는지 확인 후 거기에 놓인 다면, 사전 차단한다
- 같은 대각선 상에 위치하는 것은 y = x + k와 y = -x + k 직선 상에서 같은 점에 놓이는지 보면 된다.
- 매 케이스마다 공격 루트에 놓이는지 검사하는 것은 비효율적이라 i단계에서 퀸을 놓으면, i+1단계에서 퀸을 놓을 수 없는 것도 정해지므로, 미리 해당 좌표들에 갈 수 없는 표시를 해놓으면, 각 스텝마다 일일이 검사하지 않아도 된다

### 2. 풀이

- 시간 제한을 보면 10초란 것을 알 수 있는데, 이처럼 시간이 오래걸리는 문제들을 자주 볼 수 있는데, 백트래킹의 존재 의의 자체가 불가능한 케이스를 미리 걸러 매우 오래 걸리는 완전 탐색문제의 시간 단축을 하기 위함이라고 볼 수 있다
- 재귀함수의 경우 상태 공간트리의 노드의 수로 시간복잡도를 계산하는데, 가지치기가 많이 될 수록 시간복잡도 계산이 어려워진다, 때문에 제일 오래 걸리는 케이스(입력 범위에서 가장 큰 값)을 넣어서 시간을 측정해보자
- 시간을 측정할 때는 릴리즈 모드로 컴파일하자

## [1182 - 부분수열의 합](https://www.acmicpc.net/problem/1182)

### 1. 해결 핵심 아이디어

- 모든 부분 집합을 구해야하는 완전 탐색에서 n의 크기가 최대 20이라 시간복잡도는 최대 O($2^20$)이고, 시간 제한 내에 통과하기 충분하다
- 현재 보고 있는 i번 원소가 중간 결과에 더해졌을 때 s가 될 수 있는지 봐야하고, 만약 i번 원소가 중간 결과에 더해졌을 때 s보다 커지거나 앞으로 남은 모든 수를 더해도 s보다 작을 때 더 이상 보지 않아도 되는 pruning을 적용해볼 수 있겠지만, 그러면 구현이 복잡해진다
- i번 원소를 더하지 않고 다음단계로 넘어간다는 의미는 부분 집합에 i번 원소를 포함시키지 않겠다는 의미로 해석하면 된다

### 2. 풀이

- 구현의 그닥 어렵지 않음, pruning을 적용했으면 따질 경우가 많아서 복잡했을 것임, 같은 문제에서 n의 최대 크기가 커진다면 적용해봐야될 옵션
- 크기가 양수인 부분수열을 따지는 문제로, 모든 원소가 포함되지 않는 공집합이 생성될 수 있으므로, 이 경우를 제외해야함에 주의하자

## [15650 - N과 M (2)](https://www.acmicpc.net/problem/15650)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 오름차순을 유지하는 수열만 뽑아내는 것이었는데, 그 말은 오름 차순을 유지하지 않는 경우의 수라면 pruning을 통해 거르면 된다

### 2. 풀이

- `cur == 0 || cur > 0 && seq[cur-1] < seq[cur]`일 때만 재귀호출하게 구현했음
- 정답 코드를 보니 seq[cur] 다음에 올 수는 seq[cur] + 1이므로 반복문을 1부터 n까지 돌지 않고 시작 값을 seq[cur] + 1로 끝 값을 n으로 해서 반복문을 돌림

## [15651 - N과 M (3)](https://www.acmicpc.net/problem/15651)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 중복을 허용했는데, pruning없이 길이가 m이 될 때까지 모든 가능한 경우를 탐색하면 된다

### 2. 풀이

- pruning관련 코드를 없애면 해결 가능

## [15652 - N과 M (4)](https://www.acmicpc.net/problem/15652)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 중복 허용과 비내름차순을 유지했어야 했다, 중복에 대한 pruning은 없어도 되고, 비내림차순을 유지하게, 이를 만족하지 않는 수열은 pruning하였음

### 2. 풀이

- `cur == 0 || cur > 0 && seq[cur-1] <= seq[cur]`일 때만 재귀호출하게 구현했음

## [15654 - N과 M (5)](https://www.acmicpc.net/problem/15654)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 1부터 N사이의 값을 갖는 수열이 아니라 직접 입력받는 방식었고, 출력을 오름차순으로 해주기 위해 입력받은 후, 정렬해줬다
- 중복을 방지하기 위한 pruning이 필요했고, 이 수가 쓰였는지 판단하는 배열 is_used의 크기를 1e4 + 5정도로 잡아줬다

### 2. 풀이

- 정답코드를 보니, 15649 - N과 M과 동일한 수열을 구하고, 이걸 입력받은 배열의 인덱스로 만들어줘서, is_used의 크기를 10으로 잡아서 해결할 수 있네 => 이 방식을 사용하면 메모리 크기 이득을 볼 수 있어서 내가 푼 솔루션보다 더 좋은 방법이다

## [15655 - N과 M (6)](https://www.acmicpc.net/problem/15655)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 1부터 N사이의 값을 갖는 수열이 아니라 직접 입력받고 오름차순된 수열만 출력해줘야했고, 출력을 오름차순으로 해주기 위해 입력받은 후 정렬해줬다

### 2. 풀이

- 이전 문제에서 본 정답코드의 형태를 응용해보았음(인덱스를 이용하는 방식과 반복문의 시작점을 변경)

## [15656 - N과 M (7)](https://www.acmicpc.net/problem/15656)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 1부터 N사이의 값을 갖는 수열이 아니라 직접 입력받고 중복을 허용한다 출력을 오름차순으로 해주기 위해 입력받은 후 정렬해줬다

### 2. 풀이

- 중복에 대한 pruning만 없애주면 됨

## [15657 - N과 M (8)](https://www.acmicpc.net/problem/15657)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 1부터 N사이의 값을 갖는 수열이 아니라 직접 입력받고 중복을 허용하고 비오름차순으로만 출력해줘야한다
- 출력을 오름차순으로 해주기 위해 입력받은 후 정렬해줬다

### 2. 풀이

- 커서가 0이 아닐 때, 반복문의 시작점을 이전 원소와 동일하게 해주면 비내림차순으로 수열을 생성할 수 있다
- 커서가 0이면 0으로 설정해주면 된다

## [15663 - N과 M (9)](https://www.acmicpc.net/problem/15663)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 직접 입력 받으면서 입력에 중복된 수가 있고 중복된 수열을 출력하면 안된다는 점이다
- 출력을 오름차순으로 해주기 위해 입력 받은 후 정렬해줬다
- 중복 수열이 출력되지 않기 위해 중복되는 수열이 나올 경우 pruning해줄 필요가 있다
- 다행히 사전 순으로 정렬되므로 원소가 중복된다면 서로 인접해있고, 이 점을 이용하면, 중복 검사를 쉽게 할 수 있다
- pruning 조건을 `is_used[i] || dup == in[i]`로 해줬는데, i번에 위치하는 수가 사용됐거나 사용안됐지만 앞서 나온 수랑 같으면 더 이상 진행되지않는다는 뜻인데 중복이 발생하는 이유를 살펴보면, 같은 자리에 중복된 수가 나오면 중복되는 케이스로 정의할 수 있는데, 이를 막기 위해서는 같은 자리에 중복된 수가 나오는 경우를 사전 차단하면된다, 예를 들어 8이 중복으로 입력되었을 때, 숫자 8로 시작하는 길이가 m인 수열을 만들었으면, 다시 8로 시작하는 수열을 만들면 안된다는 의미임
- 각 재귀함수의 역할은 수열의 i번째 숫자를 결정하는 것인데, 8이 첫번째로 쓰인 케이스가 모두 끝났으면 그 다음 수도 8인데, 수열을 생성하면서 dup를 8로 지정해놨기때문에 다음 턴에서 첫번째 자리에 dup == in[i]에 막혀서 8이 올 수 없다
- 이처럼 무언가를 방지하고 싶으면 그 상황이 왜 일어나는지 알고, 어떻게 막을지 생각해야한다

### 2. 풀이

- 처음에는 단순히 set 자료구조에 저장해서 정답을 내긴했지만, 올바른 알고리즘이라면 아예 중복된 케이스를 생성해내지 말아야한다

## [15664 - N과 M (10)](https://www.acmicpc.net/problem/15664)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 직접 입력 받으면서 입력에 중복된 수가 있는 상황에서 중복된 수열을 만들 수 없고 수열이 비내림차순을 유지해야한다
- 출력을 사전순으로 해주기 위해 입력 받은 후 정렬해줬다
- 비내림차순을 유지하기 위해서는 i+1번 자리에 위치한 수가 i번 자리에 위치한 수보다 크거나 같아야한다

### 2. 풀이

- 비내림차순을 유지시키위한 방법은 두 가지가 있는데, 자리에 놓기 전에 cur > 0 && seq[cur-1]을 보고 in[i]가 크면 pruning을 시키거나 입력 받고 정렬시키기 때문에 다음 스텝의 재귀함수에 반복문의 시작점을 i+1로 줘서 i번 원소보다 크거나 같게 만들 수 있다, 두 번째 방법을 쓰면 is_used를 관리할 필요가 없어지는데, 한 번 본 원소는 더 이상 보지 않기 때문에 사용됬었는지 체크할 필요가 없어지기 때문이다, 후자의 경우 메모리를 아낄 수 있고 유의미한 차이는 없겠지만 반복문의 횟수가 줄어드는 이점이 있어서 더 좋은 방법으로 볼 수 있겠다

## [15665 - N과 M (11)](https://www.acmicpc.net/problem/15665)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 직접 입력 받으면서 입력에 중복된 수가 있는 상황에서 중복된 수열을 만들 수 없고 만들어지는 수열의 원소에 중복을 허용한다
- 출력을 사전순으로 해주기 위해 입력 받은 후 정렬해줬다

### 2. 풀이

- 중복을 허용하면, 중복을 거르기 위한 pruning부분만 제거하면 됨

## [15666 - N과 M (12)](https://www.acmicpc.net/problem/15666)

### 1. 해결 핵심 아이디어

- 핵심 아이디어는 15649 - N과 M과 동일하다
- 차이점은 직접 입력 받으면서 입력에 중복된 수가 있는 상황에서 중복된 수열을 만들 수 없고 만들어지는 수열의 원소에 중복을 허용하고 비내림차순을 유지해야한다
- 출력을 사전순으로 해주기 위해 입력 받은 후 정렬해줬다

### 2. 풀이

- 15664 - N과 M (10)의 아이디어를 이용해서 다음 스텝의 재귀 함수 반복문을 현재 스텝의 자리수로 주면 다음 스텝에서 수열에 위치할 원소는 현재 스텝의 원소와 같거나 크게된다

## [6603 - 로또](https://www.acmicpc.net/problem/6603)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [1759 - 암호 만들기](https://www.acmicpc.net/problem/1759)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [1941 - 소문난 칠공주](https://www.acmicpc.net/problem/1941)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [16987 - 계란으로 계란치기](https://www.acmicpc.net/problem/16987)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [18809 - Gaaaaaaaaaarden](https://www.acmicpc.net/problem/18809)

### 1. 해결 핵심 아이디어

### 2. 풀이

## [1799 - 비숍](https://www.acmicpc.net/problem/1799)

### 1. 해결 핵심 아이디어

### 2. 풀이
