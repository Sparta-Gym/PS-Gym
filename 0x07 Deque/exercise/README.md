# Learning About

<!--ts-->
* [Learning About](#learning-about)
   * [<a href="https://www.acmicpc.net/problem/1021" rel="nofollow">1021 - 회전하는 큐</a>](#1021---회전하는-큐)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
      * [2. 코멘트](#2-코멘트)
   * [<a href="https://www.acmicpc.net/problem/10866" rel="nofollow">10866 - 덱</a>](#10866---덱)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
      * [2. 코멘트](#2-코멘트-1)
   * [<a href="https://www.acmicpc.net/problem/5430" rel="nofollow">5430 - AC</a>](#5430---ac)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
      * [2. 코멘트](#2-코멘트-2)
   * [<a href="https://www.acmicpc.net/problem/11003" rel="nofollow">11003 - 최솟값 찾기</a>](#11003---최솟값-찾기)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
      * [2. 코멘트](#2-코멘트-3)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 11월  3일 목요일 13시 08분 50초 KST -->

<!--te-->

## [1021 - 회전하는 큐](https://www.acmicpc.net/problem/1021)

### 1. 해결 핵심 아이디어

- 왼쪽으로 한 칸 이동시키는 연산과 오른쪽으로 한 칸 이동시키는 연산이 덱의 push_front(), push_back()과 동일해서 덱을 사용하면 문제가 쉬워진다
- 순서대로 뽑아내기 때문에 어떤 원소를 먼저 뽑느냐에 따라 연산 횟수가 최소가 되는지 고민할 필요 없이, 순서대로 보면서 mid보다 앞에 있으면, 왼쪽으로 이동시키는 것이 최소고, mid보다 뒤에 있으면 오른쪽으로 이동시키는 것이 최소이다

### 2. 코멘트

- find 메서드를 이용해서 target의 위치를 찾고(iterator), 이것과 mid위치를 비교한 다음 적절하게 왼쪽 이동, 오른쪽 이동시켜주면 끝이다

## [10866 - 덱](https://www.acmicpc.net/problem/10866)

### 1. 해결 핵심 아이디어

- 덱 컨테이너의 연산들을 구현하는 문제

### 2. 코멘트

- 입력 쿼리에 따라 적절하게 처리해주면 된다

## [5430 - AC](https://www.acmicpc.net/problem/5430)

### 1. 해결 핵심 아이디어

- 문제 자체는 굉장히 단순한데 함정이 있다
- 시간 제한은 1초인데, reverse의 시간복잡도는 O(N)이고, 함수의 수는 최대 십만, 원소의 수도 최대 십만이므로 $10^{12}$이므로 곧이곧대로 R이 나왔을 때 배열을 뒤집으면 시간 초과에 걸리게 된다
- D는 O(1)이라 상관없다
- 그럼 R일 때 reverse를 하지 않아야하는데 어떻게 할 수 있을까?

  - 계속 시간초과가 나서 질문탭을 보다가 힌트를 얻었다
    [힌트](https://www.acmicpc.net/board/view/25456)

  - reverse 여부를 나타내는 플래그를 두고, 뒤집혔다면 뒤에서 꺼내면되고, 아니라면 앞에서 꺼내면된다
  - 앞과 뒤에서 꺼낼 수 있는 최적의 자료구조는 덱이다, 그래서 이 문제를 덱으로 풀 수 있는 것이다

- 이렇게 연산 자체를 곧이곧대로 했을 때 시간초과가 나는 문제라면 흉내내기로 문제를 해결할 수 있지 않을까? 한 번 떠올려보면 좋을 것 같다

### 2. 코멘트

- is_reverse flag는 초기값을 false로 두고, R 커멘드가 나올때마다 반전시킨다
- D가 나온 경우 is_reverse가 true일 때 뒤집힌 상태이므로, pop_back(), false일 때는 pop_front() 해주면 된다
- 최종 상태를 출력할 때는 is_reverse가 true라면 reverse()를 사용해서 실제로 뒤집는다
- 비어있을 때 D를 사용한 케이스의 경우 is_error flag를 둬서 체크하고, 출력할 때 true로 세팅되있으면, error를 출력해준다

## [11003 - 최솟값 찾기](https://www.acmicpc.net/problem/11003)

### 1. 해결 핵심 아이디어

- 30분 동안 열심히 가장 직관적인 2중 for문 풀이부터 시작해서 최적화를 해나갔는데 결국에는 답을 못 찾았다
- 최적화를 생각해보면서 들었던 생각은 구간 별 정렬 최대 LlogL이라 시간 내에 통과못할 거 같고, 덱이란 걸 모르고 시작했더라면 아마 고민도 하지 않을 풀이였겠지만, 양 끝을 최대나 최소를 두는 방법을 생각했었는데, 예외를 대입시켜보니 올바른 방법은 아니었다
- 정답 코드 참조
  - 항상 오름 차순을 유지하는 deque을 둔다(구간 내에서 가장 작은 값은 front(), 가장 큰 값은 back()이 되게 만든다)
  - 새로운 숫자는 항상 맨뒤에 삽입되는데, 삽입 이전에 deque내에 새로운 숫자보다 큰 숫자를 제거하는 작업이 선행되어야한다(오름차순 유지시키기)
  - deque내에 있는 유효하지 않은 숫자(구간에 포함되있지 않는 값)들은 모두 제거한다
  - deque의 front를 출력하면 그것이 최솟값이 된다
- 생각했던 것에서 한 단계 더 나아가면 정답 근처였는데, 좀 아쉽다 구간의 크기가 고정된다는 고정 관념에 사로 잡혀 유연하게 생각 못한 것 같다.
  - 새로나오는 숫자보다 큰 숫자가 나오면 갖고 있을 필요가 없는데 왜 가져가려했을까
- 윈도우가 슬라이딩하면서 최솟값이나 최댓값 찾는 문제가 나오면, deque을 활용해보자

### 2. 코멘트

- 숫자 입력 받고, 오름 차순 덱에서 숫자보다 큰 거 있으면 뺀다
- 숫자 덱 맨 뒤에 삽입
- 최솟값은 덱 front인데, 이 값이 현재 구간 내의 값이 아닐 수도 있으므로 구간 내의 숫자인지 검사
- deque.front 출력
