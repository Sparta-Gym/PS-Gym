# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/11725" rel="nofollow">11725 - 트리의 부모 찾기</a>](#11725---트리의-부모-찾기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 코멘트](#2-코멘트)
  - [<a href="https://www.acmicpc.net/problem/1991" rel="nofollow">1991 - 트리 순회</a>](#1991---트리-순회)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 코멘트](#2-코멘트-1)
  - [<a href="https://www.acmicpc.net/problem/4803" rel="nofollow">4803 - 트리</a>](#4803---트리)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 코멘트](#2-코멘트-2)
  - [<a href="https://www.acmicpc.net/problem/15681" rel="nofollow">15681 - 트리와 쿼리</a>](#15681---트리와-쿼리)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 코멘트](#2-코멘트-3)
  - [<a href="https://www.acmicpc.net/problem/1240" rel="nofollow">1240 - 노드사이의 거리</a>](#1240---노드사이의-거리)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 코멘트](#2-코멘트-4)
  - [<a href="https://www.acmicpc.net/problem/22856" rel="nofollow">22856 - 트리 순회</a>](#22856---트리-순회)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 코멘트](#2-코멘트-5)
  - [<a href="https://www.acmicpc.net/problem/1068" rel="nofollow">1068 - 트리</a>](#1068---트리)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 코멘트](#2-코멘트-6)
  - [<a href="https://www.acmicpc.net/problem/20955" rel="nofollow">20955 - 민서의 응급 수술</a>](#20955---민서의-응급-수술)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 코멘트](#2-코멘트-7)
  - [<a href="https://www.acmicpc.net/problem/14267" rel="nofollow">14267 - 회사 문화 1</a>](#14267---회사-문화-1)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
    - [2. 코멘트](#2-코멘트-8)
  - [<a href="https://www.acmicpc.net/problem/2250" rel="nofollow">2250 - 트리의 높이와 너비</a>](#2250---트리의-높이와-너비)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-9)
    - [2. 코멘트](#2-코멘트-9)
  - [<a href="https://www.acmicpc.net/problem/2533" rel="nofollow">2533 - 사회망 서비스(SNS)</a>](#2533---사회망-서비스sns)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-10)
    - [2. 코멘트](#2-코멘트-10)
  - [<a href="https://www.acmicpc.net/problem/1967" rel="nofollow">1967 - 트리의 지름</a>](#1967---트리의-지름)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-11)
    - [2. 코멘트](#2-코멘트-11)
  - [<a href="https://www.acmicpc.net/problem/1167" rel="nofollow">1167 - 트리의 지름</a>](#1167---트리의-지름)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-12)
    - [2. 코멘트](#2-코멘트-12)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 11월 21일 월요일 10시 44분 57초 KST -->

<!--te-->

## [11725 - 트리의 부모 찾기](https://www.acmicpc.net/problem/11725)

### 1. 해결 핵심 아이디어

- 탐색할 때, 방문체크 배열대신 부모 배열사용하면 쉽게 해결가능

### 2. 코멘트

- 패스

## [1991 - 트리 순회](https://www.acmicpc.net/problem/1991)

### 1. 해결 핵심 아이디어

- 전위, 중위, 후위 순회 결과 출력해주면 끝
- 각 재귀마다 stdout하면 오래걸릴 수 있으므로 string concatnation 이용했음

### 2. 코멘트

- 패스

## [4803 - 트리](https://www.acmicpc.net/problem/4803)

### 1. 해결 핵심 아이디어

- 입력으로 주어지는 그래프가 트리인지 판단하기 위해 사이클을 체크하는 용도로 dfs를 사용하였다
- 사이클의 판단 여부는 트리는 첫 방문이 마지막 방문이어야한다, 왜냐하면 루트부터 임의의 자식으로 가는 경로는 오직 1개이기 때문이다
- 이 사실을 이용해서 인접 정점이 부모가 아니고, 다른 인접 정점을 살펴볼 때 이미 방문 전적이 있더라면 사이클인 것이다

### 2. 코멘트

- 재귀 함수에서 사이클 발견해서 return false했는데, 그 부분만 false로 리턴되는 것이지 전체 결과가 false가 되는게 아니다
- 전체 결과를 보기위해 트리인지 아닌지 판단하는 불리언 변수하나를 전역으로 선언한다음 사이클 발견하면 값을 바꿔주고 리턴시켜야한다
- 멍청한 실수를..

## [15681 - 트리와 쿼리](https://www.acmicpc.net/problem/15681)

### 1. 해결 핵심 아이디어

- dfs와 같이 재귀적으로 트리를 탐색하면서 자식노드의 수를 세는 방식으로 구현
- 사실 문제에 정답이 다 있어서 할 게 별로 없었다
- 다만 주의할 점은 무방향 그래프이기때문에 이미 방문한 정점은 방문 못하게 자식 노드를 이미 센 노드는 방문못하게 prunning하였음

### 2. 코멘트

- 이거 뭔가 다이나믹 프로그래밍스러운 문제인걸?

## [1240 - 노드사이의 거리](https://www.acmicpc.net/problem/1240)

### 1. 해결 핵심 아이디어

- 두 정점사이의 거리(경로 상 가중치 합)을 구하는 문제
- 원래는 두 정점 사이의 최단 거리를 구하는 알고리즘인 벨만 포드를 썼어야 할 것이지만 이 문제는 N, M모두 상한이 1000이고 시간복잡도는 O(M \* (V+E))이므로 두 정점을 매번 탐색해도 시간제한에 들어올 수 있다
- dfs로 경로를 구해주면 약간 애로사항이 있으므로 bfs를 이용하였음

### 2. 코멘트

- 패스

## [22856 - 트리 순회](https://www.acmicpc.net/problem/22856)

### 1. 해결 핵심 아이디어

- 유사 중위 순회라고 했지만 사실은 중위 순회를 마칠 때까지 간선을 몇 번 거치는지를 세는 문제였음
- 왼쪽이나 오른쪽 자식으로 갈 때 진입할 때랑 되돌아 나올 때 각각 이동횟수를 +1 시켜주면 된다
- 마지막 방문 정점에서 다시 루트로 돌아오는 과정이 이동횟수에 포함되므로 왼쪽자식으로 가는 재귀와 오른쪽자식으로 가는 재귀 사이에서 이동횟수를 갱신해주면 루트로 돌아가는 과정은 빠지게된다

### 2. 코멘트

- 패스

## [1068 - 트리](https://www.acmicpc.net/problem/1068)

### 1. 해결 핵심 아이디어

- dfs를 이용해서 탐색하며 leaf 노드 도달 시 카운트하고, 삭제될 노드를 만나서 prunning시켜서 탐색범위에서 제외시켜 자연스럽게 leaf를 못 세게 막아주었다
- leaf 정점인지 판단하는 법은 부모 이외에 인접이 없어야한다는 점을 이용하였다
- 일직선 트리일 때 주의할 점이 있는데, 다음과 같다

  ![special case](https://user-images.githubusercontent.com/48282185/203670802-ab123ad4-c65c-4803-bfac-a5c12bbe2a9d.png)

  - 이 케이스에서 2가 삭제 대상이라고 했을 때 1이 leaf가 된다, 그래서 이 케이스에 대한 예외 처리가 없으면 기존 leaf 판단법으로는 카운트가 안된다
  - 그래서 인접 리스트의 사이즈가 2이고(부모, 삭제 대상), 다음 정점이 삭제대상이라면 이 케이스에 해당하므로 leaf를 세주었다

### 2. 코멘트

- leaf 노드 카운트할 때는 bfs보단 dfs가 구현이 쉬운 것 같다

## [20955 - 민서의 응급 수술](https://www.acmicpc.net/problem/20955)

### 1. 해결 핵심 아이디어

- 각 연결요소들이 주어지고, 간선을 만들거나 없애서 spanning tree를 만들어줘야하는 문제
- 최소 연산이므로 필요없는 건 하지 말아야한다
- 트리가 되기위해 모든 정점은 연결되어야하므로, 서로 다른 연결 요소끼리 간선으로 이어주고, 연결 요소를 탐색 중 사이클이 발견되면, 제거해줘야한다

### 2. 코멘트

- dfs로 사이클 찾는 거 연습 좀 해야겠다

## [14267 - 회사 문화 1](https://www.acmicpc.net/problem/14267)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [2250 - 트리의 높이와 너비](https://www.acmicpc.net/problem/2250)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [2533 - 사회망 서비스(SNS)](https://www.acmicpc.net/problem/2533)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [1967 - 트리의 지름](https://www.acmicpc.net/problem/1967)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [1167 - 트리의 지름](https://www.acmicpc.net/problem/1167)

### 1. 해결 핵심 아이디어

### 2. 코멘트
