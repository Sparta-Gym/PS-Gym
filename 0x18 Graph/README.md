# 0x18 그래프

<!--ts-->

- [0x18 그래프](#0x18-그래프)
  - [0x00 정의와 표현법](#0x00-정의와-표현법)
  - [0x01 BFS](#0x01-bfs)
  - [0x02 DFS](#0x02-dfs)
  - [0x03 연습 문제](#0x03-연습-문제)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 7월 18일 월요일 13시 49분 45초 KST -->

<!--te-->

## 0x00 정의와 표현법

- 정점과 간선으로 이루어진 자료구조

  ![0](https://user-images.githubusercontent.com/48282185/201797988-fd1ff911-de21-4643-a2e4-3e754cf61283.png)

- 원소 간에 연결관계를 설정해야하는 상황에서 유용하게 활용될 수 있는 자료구조
  - 막상 그래프 문제를 만나면 이게 그래프 문제인지 알아차리지 못할 수 있고 많이 그랬다
  - 관계가 있음을 문제에서 직접적으로 알려주는 유형도 있고, 상태 공간 트리를 만들면서 스스로 관계가 있음을 알아차려야할 수도 있다
  - 예를 들면 어떤 상태에서 무슨 상태까지 되는데 최소 횟수를 거쳐야한다 ⇒ 상태 공간 트리에서 최단거리
- 완전 그래프(complete graph)
  - 임의의 두 쌍의 정점이 간선으로 연결된 그래프
- 연결 그래프(connected graph)
  - 임의의 정점 사이에 경로가 항상 존재하는 그래프
  - 그래프에서 경로는 같은 정점을 거듭 거치지 않는 간선들의 집합이다 ⇒ 사이클 없음
- 단순 그래프(simple graph)
  - 두 정점 사이의 간선이 한 개 이하이고 루프가 존재하지 않는 그래프
- 간과하기 쉬운 점

  ![1](https://user-images.githubusercontent.com/48282185/179447132-f20fb8db-9910-4e28-8936-5d388c7ff128.png)

- 아래와 같이 엄밀한 조건들이 문제에 없는 경우 그래프가 위와 같이 분리돼있다거나 같은 간선이 여러개 이거나 루프가 있다는 것을 고려해서 즉 simple graph가 아님을 인지하고 문제를 풀어야한다

  - 그래프는 연결되어 있다 ⇒ 연결 그래프입니다
  - 그래프는 연결 그래프이다 ⇒ 연결 그래프입니다
  - 두 정점 사이의 간선은 최대 한 개 존재한다 ⇒ 다중 그래프가 아닌 단순 그래프입니다
  - 같은 간선은 한 번만 주어진다 ⇒ 단순 그래프입니다
  - 간선의 두 정점은 서로 다르다 ⇒ 루프가 없습니다, 단순 그래프입니다
  - 간선은 서로 다른 두 정점을 연결한다 ⇒ 루프가 없습니다, 단순 그래프입니다

- 그래프 표현법

  - 인접 행렬

    ![2](https://user-images.githubusercontent.com/48282185/179447130-c3ed883e-6a9a-4905-abb0-a5e15f8da972.png)

    - 연결 돼있는 두 정점 i, j는 인접행렬 adj[i][j]에서 1로 표현됨 → 단순 그래프인 경우
    - 무방향 그래프이면, 대각선 기준으로 대칭, 방향 그래프면 대칭아님
    - 두 정점이 연결되어있는지 확인을 O(1)에 할 수 있다는 장점이 있다
      - 임의의 두 정점 사이 연결 여부를 자주 확인하는 문제면 인접 행렬쓰면 좋을 듯
    - 인접행렬을 위해 필요한 공간은 정점이 V개라 할 때 $V^2$이 필요하다
    - 어떤 정점에 연결된 모든 정점을 확인하기 위해 O(V)가 소요됨

  - 인접 리스트

    ![3](https://user-images.githubusercontent.com/48282185/179447125-00ac4f95-70a0-4b37-addc-87912d2c5dc2.png)

    - 인접 행렬과 비교했을 때 정점이 많고 간선은 상대적으로 작은 상황에서 공간을 절약할 수 있는 방식이고, 종종 메모리 제한으로 인해 인접 리스트만 사용할 수 있는 경우가 있기도 해서 꼭 기억해야함
    - 필요한 공간
      - V(리스트의 크기) + E(방향 그래프일 때) → V + E
      - V + 2E(무방향 그래프일 때) → V + 2E

  - 인접 행렬 vs 인접 리스트

    ![4](https://user-images.githubusercontent.com/48282185/179447124-339e8da1-7e6e-4368-943b-3b8328364ee1.png)

    - 일반적으로 두 점의 연결여부를 자주 확인하는 상황보다 특정 정점에 연결된 모든 정점을 확인하는 경우가 많기 때문에 인접 행렬보다는 인접 리스트가 주로 사용
    - V가 작을 때 구현의 편의를 위해 인접 행렬을 사용하기도 함
    - 왜 E가 $V^2$ 에 가까울 때 효율적이냐하면, 어차피 다 탐색해야하는 상황이기 때문이다

## 0x01 BFS

- 그래프에서 너비를 우선으로 모든 정점을 방문하는 알고리즘
- 만약 상태 사이에 연결이 되있고, 모든 상태를 탐색해야하는 상황일 때 그래프로 문제를 모델링 해 볼 수도 있겠다(상태 공간 트리)
- 과정
  1. 시작하는 정점을 큐에 넣고 방문했다는 표시를 남김
  2. 큐에서 정점을 꺼내어 그 정점과 연결된 모든 정점들에 대해 3번을 진행
  3. 해당 정점을 이전에 방문했다면 아무 것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 큐에 삽입
  4. 큐가 빌 때 까지 2번을 반복
  - 모든 정점이 큐에 최대 1번씩 들어가므로 인접 리스트에서 O(V + E), 인접 행렬에서 O($V^2$)의 시간복잡도를 갖는다
- 다차원 배열에서의 BFS와 마찬가지로 한 정점에서 다른 모든 정점으로의 최단 경로를 찾을 때도 BFS를 이용할 수 있다(간선의 가중치가 모두 같을 때만 사용할 수 있음, 만약 다르다면 최단 경로는 다익스트라나 플로이드 알고리즘을 통해서 찾아야함)

## 0x02 DFS

- 그래프를 깊이를 우선으로 모든 정점을 방문하는 알고리즘
- BFS의 과정에서 큐에 넣는 대신 스택에 넣는다는 차이 이외에는 없다
- 과정
  1. 시작하는 정점을 스택에 넣고 방문했다는 표시를 남김
  2. 스택에서 정점을 꺼내어 그 정점과 연결된 모든 정점들에 대해 3번을 진행
  3. 해당 정점을 이전에 방문했다면 아무 것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 스택에 삽입
  4. 스택이 빌 때 까지 2번을 반복
  - BFS와 같이 모든 정점이 스택에 최대 한 번씩 들어가므로 인접 리스트에서 O(V + E), 인접 행렬에서 O($V^2$)의 시간복잡도를 갖는다
- DFS는 스택 대신 재귀함수 방식으로 구현할 수 있는데 제일 늦게 호출된 함수가 제일 먼저 실행된다는 점에서 스택과 같기 때문(LIFO)
- 재귀로 구현할 때 주의해야하는 점은 스택 영역의 크기 제한이다, 메모리 초과날 우려
  - 백준이나 프로그래머스에서는 스택 영역 크기 제한 없는데, 코딩테스트 전에 꼭 확인해보자
- 재귀로 구현할 때와 스택으로 구현할 때의 차이

  - 갈 수 있는 정점이 여러 개라면 번호가 작은 것 부터 방문할 때 방문순서의 차이

  ![5](https://user-images.githubusercontent.com/48282185/179447116-2acb8736-c7a1-4e54-b8bf-cfcbb58d281f.png)

  - 재귀 방식으로 구현했을 때는 실제 방문을 할 때 방문표시를 남기고, 스택으로 구현한 방식에서는 방문 전에 방문하지 않은 곳을 방문하면 방문표시를 남기기 때문에 발생하는 차이
  - 관념적으로 생각하는 DFS의 방문 순서는 재귀적으로 구현했을 때 나오고, 만약 DFS처럼 막힐 때까지 한 방향으로 직진해야하는 고유 성질을 이용해야하는 문제라면 스택으로 구현하면 안된다
  - DFS의 고유 성질을 이용해야하는 경우로는 cycle detection, SCC, BCC, 오일러 경로 등이 있는데, 코딩테스트 레벨에서는 안 나올 확률이 높다
  - 스택을 이용한 방법으로 관념적으로 생각하는 DFS를 구현할 수 있다

    - 한 정점이 스택에 여러번 들어갈 수 있지만 꺼낸 직후 방문 여부를 확인하기 때문에 시간복잡도는 동일하게 O(V + E)를 갖는다

    ```cpp
    vector<int> adj[10];
    bool visited[10];

    void dfs(void) {
      stack<int> s;
      s.push(1);
      while (!s.empty()) {
        int cur = s.top();
        s.pop();
        if (visited[cur]) continue;
        // 이렇게 실제로 방문할 때 방문표시를 남김으로서 관념적인 DFS의 방문순서를
        // 구현할 수 있다
        visited[cur] = true;
        cout << cur << ' ';
        for (auto nxt : adj[cur]) {
          if (visited[nxt]) continue;
          s.push(nxt);
        }
      }
    }
    ```

## 0x03 연습 문제

- 11724 - 연결 요소의 개수
  - 한 그래프 내에서 연결된 정점 그룹의 개수를 세는 문제
  - 그냥 bfs나 dfs써서 모든 정점을 확인하면서 방문하지 않았다면 시작 정점으로 간주하고, 순회 알고리즘을 돌리면 끝
- 1260 - DFS와 BFS
  - bfs는 그냥 구현하면 되는데, dfs의 경우 문제에서 요구한 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문이라는 조건 때문에 비재귀 방식(스택 방식)으로 구현해야한다
  - 이 문제는 또 특이하게 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다는 조건이 있는데, 어차피 한 번 방문하면 더 이상 안하기 때문에 크게 신경쓰지 않아도 될 듯하다

> 바킹독님 유튜브 강의를 참고하여 제작하였습니다.
