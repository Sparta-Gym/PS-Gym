# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/11724" rel="nofollow">11724 - 연결 요소의 개수</a>](#11724---연결-요소의-개수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 코멘트](#2-코멘트)
  - [<a href="https://www.acmicpc.net/problem/1260" rel="nofollow">1260 - DFS와 BFS</a>](#1260---dfs와-bfs)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 코멘트](#2-코멘트-1)
  - [<a href="https://www.acmicpc.net/problem/2606" rel="nofollow">2606 - 바이러스</a>](#2606---바이러스)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 코멘트](#2-코멘트-2)
  - [<a href="https://www.acmicpc.net/problem/5567" rel="nofollow">5567 - 결혼식</a>](#5567---결혼식)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 코멘트](#2-코멘트-3)
  - [<a href="https://www.acmicpc.net/problem/11403" rel="nofollow">11403 - 경로 찾기</a>](#11403---경로-찾기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 코멘트](#2-코멘트-4)
  - [<a href="https://www.acmicpc.net/problem/2660" rel="nofollow">2660 - 회장뽑기</a>](#2660---회장뽑기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 코멘트](#2-코멘트-5)
  - [<a href="https://www.acmicpc.net/problem/1389" rel="nofollow">1389 - 케빈 베이컨의 6단계 법칙</a>](#1389---케빈-베이컨의-6단계-법칙)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 코멘트](#2-코멘트-6)
  - [<a href="https://www.acmicpc.net/problem/1325" rel="nofollow">1325 - 효율적인 해킹</a>](#1325---효율적인-해킹)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 코멘트](#2-코멘트-7)
  - [<a href="https://www.acmicpc.net/problem/6118" rel="nofollow">6118 - 숨바꼭질</a>](#6118---숨바꼭질)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
    - [2. 코멘트](#2-코멘트-8)
  - [<a href="https://www.acmicpc.net/problem/1707" rel="nofollow">1707 - 이분 그래프</a>](#1707---이분-그래프)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-9)
    - [2. 코멘트](#2-코멘트-9)
  - [<a href="https://www.acmicpc.net/problem/2617" rel="nofollow">2617 - 구슬 찾기</a>](#2617---구슬-찾기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-10)
    - [2. 코멘트](#2-코멘트-10)
  - [<a href="https://www.acmicpc.net/problem/1043" rel="nofollow">1043 - 거짓말</a>](#1043---거짓말)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-11)
    - [2. 코멘트](#2-코멘트-11)
  - [<a href="https://www.acmicpc.net/problem/5214" rel="nofollow">5214 - 환승</a>](#5214---환승)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-12)
    - [2. 코멘트](#2-코멘트-12)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 11월 15일 화요일 10시 42분 00초 KST -->

<!--te-->

## [11724 - 연결 요소의 개수](https://www.acmicpc.net/problem/11724)

### 1. 해결 핵심 아이디어

- 한 그래프 내에서 연결된 정점 그룹(서브 그래프)의 개수를 세는 문제
- 그냥 bfs나 dfs써서 모든 정점을 확인하면서 방문하지 않았다면 시작 정점으로 간주하고, 순회 알고리즘을 돌리면 끝

### 2. 코멘트

- 패스

## [1260 - DFS와 BFS](https://www.acmicpc.net/problem/1260)

### 1. 해결 핵심 아이디어

- bfs는 그냥 구현하면 되는데, dfs의 경우 문제에서 요구한 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문이라는 조건 때문에 비재귀 방식(스택 방식)으로 구현해야한다
- 이 문제는 또 특이하게 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다는 조건이 있는데, 어차피 한 번 방문하면 더 이상 안하기 때문에 크게 신경쓰지 않아도 될 듯하다

### 2. 코멘트

- 패스

## [2606 - 바이러스](https://www.acmicpc.net/problem/2606)

### 1. 해결 핵심 아이디어

- 1번 정점이 포함된 그래프에 속해있는 정점의 개수를 구하는 문제
- 1번을 시작점으로 두고 dfs or bfs를 돌려서 몇 개가 연결되있는지 확인한다
- dfs or bfs는 정점을 정확히 1번씩만 탐색하기에 정점 몇 개가 속해있는지 파악할 수 있다

### 2. 코멘트

- 패스

## [5567 - 결혼식](https://www.acmicpc.net/problem/5567)

### 1. 해결 핵심 아이디어

- 친구와 친구의 친구까지 초대하는 것이므로 1번 정점으로부터 거리가 2이하인 정점의 개수를 구하는 문제이다
- bfs를 이용하여 1번 정점으로부터 다른 정점들까지의 최단 거리를 구해줬고, 거리 계산 후 2이하이면 초대하는 친구를 1씩 증가시켰다

### 2. 코멘트

- 패스

## [11403 - 경로 찾기](https://www.acmicpc.net/problem/11403)

### 1. 해결 핵심 아이디어

- 0부터 n까지 시작점으로 지정하여 탐색알고리즘을 돌려준다
- 방향을 계속 쫓아가는 방식이라 dfs를 선택했다

### 2. 코멘트

- (시작점, 방문한 점) 체크해줘야하는데 (방문점, 그 이후 방문점)에 대해 체크해서 한참 디버깅했다 멍청이!

## [2660 - 회장뽑기](https://www.acmicpc.net/problem/2660)

### 1. 해결 핵심 아이디어

- 이 문제는 한 정점에서 제일 먼 정점까지의 거리가 그 노드의 점수가 되고, 최소 점수를 만족하는 정점이 회장이된다
- 1 ~ n까지 bfs돌려서 다른 정점까지 최단 거리 찾아주고, 그 중 최대값이 해당 정점의 점수이므로 기록해둔다
- 모든 시작점에 대해 돌고나서 점수 중 최솟값 뽑아서 그 정점들을 출력해주면된다

### 2. 코멘트

- 패스

## [1389 - 케빈 베이컨의 6단계 법칙](https://www.acmicpc.net/problem/1389)

### 1. 해결 핵심 아이디어

- 다른 모든 정점까지 최단거리 합이 제일 작은 시작 정점 번호구하는 문제
- 여러개라면 번호가 가장 작은 정점 출력해주기위해 <거리, 정점번호> 쌍을 우선순위 큐로 관리해줬음
- 같은 간선이 중복해서 들어올 수 있기때문에(multi graph) 인접 리스트를 vector대신 set을 사용했음

### 2. 코멘트

- 패스

## [1325 - 효율적인 해킹](https://www.acmicpc.net/problem/1325)

### 1. 해결 핵심 아이디어

- 가장 많은 방문 횟수를 가지는 정점 번호 출력하기, 즉 제일 많은 연결 요소를 갖는 그래프의 소속된 노드를 오름차순으로 출력해주는 문제

### 2. 코멘트

- 처음에 <연결요소 수, 정점 번호>로 우선순위 큐로 괸리해서 최대값만 뽑아줬는데, 자꾸 틀리다해서 원인을 못찾아서 벡터로 바꾸고 정렬했더니 맞았다 왜지??

## [6118 - 숨바꼭질](https://www.acmicpc.net/problem/6118)

### 1. 해결 핵심 아이디어

- 무향 루프 없는 연결 그래프에서 1번으로부터 제일 멀리 떨어져있는 정점(들)을 구하는 문제
- bfs를 이용해서 최단 거리를 계산해주고 거기서 최대값을 갖는 정점들을 조사하여 적절히 출력해주면된다

### 2. 코멘트

- 패스

## [1707 - 이분 그래프](https://www.acmicpc.net/problem/1707)

### 1. 해결 핵심 아이디어

- 임의의 서로 다른 두 정점이 연결되있는지 판단하는 문제
- graph coloring 문제에서 2개의 색깔만 나와야한다(이것을 알긴했는데 다른 방법이 없을까 생각해보다가 '차수를 이용해보면 어떨까?'라는 생각을 해보게 되었음)
- 내가 가정한 전제는 정확하게 두 개의 집합으로 나눠지려면 어떠한 정점도 차수가 2이상이면 안된다는 것이었다, 그 순간 집합이 3개 생겨버리기 때문이다
- 차수를 이용한 방법은 다음 케이스를 잡아내지 못한다

  ![반례]("https://user-images.githubusercontent.com/48282185/202598947-a2bbf04c-acae-4003-b43b-4be681766336.png")

  - 이 예시는 이분 그래프 {1}, {2, 3}이지만 차수를 이용하면 1번 정점의 차수가 2이상이라 이분 그래프가 아니라고 판단하게 된다

- 결국에는 2 - graph coloring으로 풀어야했음
- 컬러링의 핵심은 인접 정점(B) 방문하면서 현재 정점(A)의 색깔과 다른 색을 부여한다, 이후 인접 정점을 살펴볼 때, B의 색이 A의 색과 같으면 2개의 색으로 그래프를 칠하지 못하는 것이므로 이분 그래프가 아니다

### 2. 코멘트

- 그래프 형태를 고려하고 문제를 풀어야지 왜 이렇게 무지성이야??
- 반례 만들어내는 연습에 충실하자
  - 코너 케이스, 랜덤 케이스, 비판적으로 생각하기ㄴ

## [2617 - 구슬 찾기](https://www.acmicpc.net/problem/2617)

### 1. 해결 핵심 아이디어

- 이 문제는 무게의 대소관계가 형성하므로 가벼운 무게가 무거운 무게를 향하는 방향으로해서 그래프를 그려서 in degree나 outdegree가 제일 작은 노드를 찾아주자는 방식으로 접근했는데 그건 아닌 것 같아서 고민하다가 어떤식으로 풀어야할 지 모르겠어서 정답코드를 참조했다
- 정답코드에선 무거운게 가벼운거를 가리키는 관계를 형성하는 그래프 하나, 가벼운 게 무거운 것을 가리키게하는 그래프하나 두 개를 둬서 어떤 정점보다 무게운 게 절반 이상이면 중간이 될 수 없으므로 이 값은 절대 중간값이 될 수 없고, 반대로 어떤 정점보다 가벼운 게 절반 이상이면 중간 이상이면 이 값 또한 절대 중간값이 될 수 없기 때문에 이것들이 나올 때마다 카운트 해주면된다
- 내가 정답에 접근 못한 이유는 중간값이 될 수 없는게 뭔지 명확히 하지 않아서 그런 것 같다

### 2. 코멘트

- 한 문제에 감춰진 관계가 무엇이 있는지 다 찾아봐야겠다, 이 문제 같은 경우는 단순히 무겁다, 가볍다만 있었는데, 한 방향 밖에 생각 못한점이 아쉽다

## [1043 - 거짓말](https://www.acmicpc.net/problem/1043)

### 1. 해결 핵심 아이디어

- 처음 시도 했던 방식

  - 진실을 알고있는지 여부를 체크하는 배열을 만들고 연결 요소(각 파티)에 진실 아는 사람이 포함되어있으면 진실을 알게되므로 그 파티 내의 인원들 모두를 진실 여부 배열에 추가해주는 방식을 생각했었다
  - BFS로 탐색하면서 진실 알고있는 사람이 발견되면 break하고 해당 파티의 인원들 모두를 체크했다
  - 그러다가 문득 파티의 입력 순서에 따라 발견되지 못할 사람이 생길 수 있다는 생각이 들었다
  - 그래서 진실을 알고 있는 사람이 있는 파티만 먼저 BFS로 탐색하여 누가 새로 진실을 알게되는지 알아냈다
  - but 이 방식은 다음과 같은 케이스에서 진실을 아는 사람을 잡아내지 못할 수 있다

    ```plane text
      8 4
      1 1
      3 1 2 3 - p1
      3 4 5 6 - p2
      3 6 7 8 - p3
      2 3 8 - p4
    ```

    - 1이 진실을 알고있으므로 2와 3이 진실을 알게됨(p1)
    - 3이 진실을 알고있으므로 8이 진실을 알게됨(p4)
    - 8이 진실을 알고있으므로 6, 7도 진실을 알게됨(p3)
    - 6이 진실을 알고있으므로 4, 5도 진실을 알게됨(p2)
    - 결론적으로 모두 진실을 알게되므로 답은 0이되야하는데 내 방식은 입력 순서에 디펜던시한 방식이어서 1을 출력했다
    - 입력 순서에 무관하게 구해줘야되는 점을 캐치했음에도 너무 안일하게 생각하고 코딩한 것 같다

- 정답 코드 방식
  - 각 연결요소를 탐색하는게 아니라 파티에서 공통되는 사람은 묶이게끔 관리해줌, 나는 파티 각각을 연결요소로 설정하고 탐색했음
  - 그런 다음 진실을 알고있는 사람을 큐에 전부 집어넣고(시작점이 여러개인 BFS) 그 사람들과 연결된 모든 사람을 파악한다
  - 그런 다음 파티 m개를 돌면서 그 사람들이 포함되어있는지 확인하고 거짓말이 가능한 파티의 수를 체크한다

### 2. 코멘트

- 발상 자체는 나쁘지 않은 것 같지만, 반례를 생각해내고 이것을 검증하는 과정을 안 거치니 문제가 뭔지를 알아도 제대로 못 풀어내는 것 같다 좀 더 꼼꼼해질 필요가 있다
- 참고로 이 문제를 풀다가 union-find로 풀어도 될 것 같다는 생각을 했었는데 질문탭보니까 그 방식으로 푼 사람들이 있더라, 만약 n의 상한이 더 컸으면 union-find가 정해이지 않았을까?

## [5214 - 환승](https://www.acmicpc.net/problem/5214)

### 1. 해결 핵심 아이디어

### 2. 코멘트
