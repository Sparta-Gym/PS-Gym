# 0x01 기초 코드 작성 요령 I

<!--ts-->

- [0x01 기초 코드 작성 요령 I](#0x01-기초-코드-작성-요령-i)
  - [0x00 시간 공간 복잡도](#0x00-시간-공간-복잡도)
    - [1. 시간복잡도](#1-시간복잡도)
    - [2. 공간복잡도](#2-공간복잡도)
  - [0x01 정수 자료형](#0x01-정수-자료형)
  - [0x02 실수 자료형](#0x02-실수-자료형)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 6월 28일 화요일 12시 47분 56초 KST -->

<!--te-->

## 0x00 시간 공간 복잡도

### 1. 시간복잡도

- 정의

  시간복잡도는 입력의 크기와 문제를 해결하는데 걸리는 시간의 상관관계를 나타내는 것으로 대표적으로 빅 O 표기법을 이용하여 표현한다. 컴퓨터는 1초에 약 3-5억번의 연산을 할 수 있다. 이 지식을 코딩테스트에 대입해보자.

  문제의 시간제한이 1초라는 의미는 내가 작성한 알고리즘이 최대 3-5억번 연산 후에 종료되어야함을 의미하고 그 이상 연산이 발생하게 된다면 시간 초과이다.

- **문제 1**

  대회장에서 N명의 사람들이 일렬로 서있다. 거기서 당신은 이름이 '가나다'인 사람을 찾기 위해 사람들에게 이름을 물어볼 것이다. 이름을 물어보고 대답을 듣는데까지 1초가 걸린다면 얼마만큼의 시간이 필요할까?

  - 최선의 경우 - 첫 번째 물어본 사람이 '가나다' 일 때 ⇒ 1초
  - 최악의 경우 - 마지막에 물어본 사람이 '가나다'일 때 ⇒ N초

- 문제 2

  대회장에서 N명의 사람들이 이름 순으로 서있다. 거기서 당신은 이름이 '가나다'인 사람을 찾기 위해 사람들에게 이름을 물어볼 것이다. 이름을 물어보고 대답을 듣는데까지 1초가 걸린다면 얼마만큼의 시간이 필요할까?

  - 최선의 경우 - 처음에 물어본 사람이 '가나다' 일 때 ⇒ 1초
  - 최악의 경우 - 마지막에 물어본 사람이 '가나다'일 때 ⇒ logN초

      왜 logN인지 분석을 해보자

      탐색범위의 길이가 1이면 탐색이 종료된 것이므로(더 이상 볼 게 없거나 마지막 탐색이 타겟을 가리킬 때) 탐색 범위를 줄여나가는 것이 이진 탐색의 과정이라고 할 수 있다.

      처음에는 인덱스 중앙을 가리키고

      두번째에는 탐색범위가 N/2로 줄어들고

      세번째에는 탐색범위가 N/4 줄어들고

      ...

      k번째에는 $N / 2^{k-1}$, k번째에 탐색범위가 1 즉,  $N / 2^{k-1}$ = 1이라고 하면  $log_2N = k - 1$이므로 이진 탐색의 최악의 시간복잡도를 빅 O 표기법으로 표현하면, $log_2N$이다.

  - 평균 ⇒ logN초

    - 자세한 증명은 [다음 링크 참조](<https://iq.opengenus.org/time-complexity-of-binary-search/](https://iq.opengenus.org/time-complexity-of-binary-search>)   / 기댓값(어떤 확률적 사건에 대한 [평균](<https://ko.wikipedia.org/wiki/%ED%8F%89%EA%B7%A0_(%ED%86%B5%EA%B3%84%ED%95%99)>)의 의미)으로 계산한다. 어떤 케이스가 이진탐색의 대상이 될 지 모르기 때문에 확률을 이용하여 평균을 구하는 것이 타당하다.

  - 대표적인 시간복잡도와 허용 범위

    | N의 크기 | 허용 시간복잡도 |
    | --- | --- |
    | N ≤ 11 | O(N!) |
    | N ≤ 25 | O($2^N$) |
    | N ≤ 100 | O($N^4$) |
    | N ≤ 500 | O($N^3$) |
    | N ≤ 3,000 | O($N^{2}logN$) |
    | N ≤ 5,000 | O($N^2$) |
    | N ≤ 1,000,000 | O($NlogN$) |
    | N ≤ 10,000,000 | O($N$) |
    | 그 이상 | O($logN$), O(1) |

      이 표를 활용하여 문제에 대한 내 풀이가 시간 제한을 통과할 수 있을지 확인을 반드시 해봐야한다.

    - 예시 1

      - N 이하의 자연수 중에서 3의 배수이거나 5의 배수인 수를 모두 합한 값을 반환하는 함수 func1(int N) 을 작성하라 (단, N은 10만 이하의 자연수이다.)

        ```cpp
        int func1(int N){
         int cnt = 0;
         for(int i = 3; i <= N; ++i){
          if(i % 3 == 0 || i % 5 ==0) cnt += 1;
         }
         return cnt;
        }
        ```

        위의 표를 활용하여 "시간제한을 통과하기 위해서는 풀이의 시간복잡도가 NlogN을 넘으면 안된다"라는 것을 우선적으로 확인하고 가야한다. 작성한 풀이는 N의 시간복잡도를 가지므로 시간제한에 걸리지 않을 것이다.

    - 예시 2

      - 주어진 길이 N의 int 배열 arr에서 합이 100인 서로 다른 위치의 두 원소가 존재하면 1을, 존재하지 않으면 0을 반환하는 함수 func2(int arr[], int N)을 작성하라. arr의 각 원소는 0이상 100이하이고 N은 1000이하이다. ⇒ N^2 \* logN보다 작으면 됨!

        처음에는 누구나 쉽게 생각할 수 있는 N^2짜리 떠올렸는데, N짜리 풀이가 있다는 것이다!

        누적합을 이용해볼까?, 어떤 특별한 내가모르는 수학 공식이 있을까? 별의별 생각을 다해보다가 10분 정도 더 생각해본 결과 아래와 같은 풀이를 떠올릴 수 있었다. 이렇게 풀면 N으로 풀릴 거 같은데 나중에 나오는 배열 강의에서 해결법을 공개한다고 하니  그 때 확인해보자. N^2 알고리즘에 비해 메모리를 더 사용하기는 하나 요새는 메모리도 잘 발달되있고, 시간이 더 중요하니까!

        ```cpp
        bool func2(int arr[], int N){
         bool result = false;

         vector<int> flag(101, 0);

         for(int elem : arr){
          flag[elem] = 1;
         }

         for(int elem : arr){
          if(flag[100-elem]){
           result = true;
           break;
          }
         }

         return result;
        }
        ```

    - 예시 3

      - N이 제곱수이면 1을 반환하고 제곱수가 아니면 0을 반환하는 함수 func3(int N)을 작성하라 N은 10억 이하의 자연수이다. O(N^2) ⇒ i는 최대 $\sqrt{N}$이 된다.

        ```cpp
        bool func3(int N){
         bool result = false;
         for(int i=1; i*i <= N ; ++i){
          if(N % (i*i) == 0){
           result = true;
           break;
          }
         }
         return result;
        }
        ```

    - 예시 4

      - N이하의 수 중에서 가장 큰 2의 거듭제곱 수를 반환하는 함수 func4(int N)을 작성하라 N은 10억 이하의 자연수이다. N이 2의 k 승이라고 할 때 연산은 k번 이루어지게 되므로 시간복잡도는 logN이 되겠다.

        ```cpp
        int func4(int N){
         int powerOfTwo = 0;
         for(int i = 2; i<=N; i*=2){
          powerOfTwo = i;
         }
         return powerOfTwo;
        }
        ```

### 2. 공간복잡도

- 정의
  - 입력의 크기와 문제를 해결하는데 필요한 공간의 상관관계
  - int형 변수가 4Byte이므로, 메모리제한이 512MB라고 했을때 최대 1.2억개의 int형 변수를 사용할 수 있다.

## 0x01 정수 자료형

- int로 표현할 수 있는 값의 최대는 21억이다. 이를 넘어서면 long long을 활용하자
- 매우 큰 수의 덧셈이 나오면 string으로 변환하여 하는 것도 방법
- 너무 길면 python을 활용하는 것도 방법

## 0x02 실수 자료형

- 실수 표기법(IEEE-754) sign | exponent | fraction
- 0.1 + 0.1 + 0.1 ≠ 0.3 ?? 0.1은 이진수로 표현하면 무한소수기 때문에 이런 현상이 발생하는 것
- float 상대오차 $10^{-6}$ 까지 안전
- double 상대오차 $10^{-15}$ 까지 안전
- 실수에서는 double을 쓰자!
- double에 long long 범위의 정수를 함부로 담으면 안된다!
    + long long은 64비트에서 부호를 제외한 나머지를 온전히 숫자 표현에 사용하지만 double은 IEEE-754에 따르면 아니다
- 실수 비교할 때는 등호를 쓰지말고 둘의 차이로 비교하자.

  ```cpp
  int main(){
   double a = 0.1 + 0.1 + 0.1;
   double b = 0.3;

   if(abs(a-b) < 1e-12){
    // do something...
   }
  }
  ```

**본 내용은 바킹독님의 유튜브 실전 코딩테스트 강의의 내용을 기반으로 제작되었습니다**
