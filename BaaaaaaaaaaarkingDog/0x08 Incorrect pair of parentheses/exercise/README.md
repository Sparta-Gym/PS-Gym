# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/4949" rel="nofollow">4949 - 균형잡힌 세상</a>](#4949---균형잡힌-세상)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 코멘트](#2-코멘트)
  - [<a href="https://www.acmicpc.net/problem/3986" rel="nofollow">3986 - 좋은 단어</a>](#3986---좋은-단어)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 코멘트](#2-코멘트-1)
  - [<a href="https://www.acmicpc.net/problem/9012" rel="nofollow">9012 - 괄호</a>](#9012---괄호)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 코멘트](#2-코멘트-2)
  - [<a href="https://www.acmicpc.net/problem/10799" rel="nofollow">10799 - 쇠막대기</a>](#10799---쇠막대기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 코멘트](#2-코멘트-3)
  - [<a href="https://www.acmicpc.net/problem/2504" rel="nofollow">2504 - 괄호의 값</a>](#2504---괄호의-값)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 코멘트](#2-코멘트-4)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 11월  3일 목요일 13시 09분 28초 KST -->

<!--te-->

## [4949 - 균형잡힌 세상](https://www.acmicpc.net/problem/4949)

### 1. 해결 핵심 아이디어

- 닫는 괄호를 하나씩 없애가면서 문제를 푼다, 중간의 원소가 제거될 수 있다, 올바른 문자열이라면 닫는 괄호가 문자열의 처음으로 나올 수 없고, 닫은 괄호가 나올 때마다 없애가는 형태이므로 문제를 풀기에 가장 적절한 선택은 스택이다

### 2. 코멘트

- '('와 '[' 두 가지가 나오는데, 각각의 괄호에 맞는 쌍이 나올 때 알맞은 처리를 해주면 된다
- 여는 괄호가 나오면 스택에 쌓고, 닫는 괄호가 나오면 스택이 비었으면, 비유효, 스택이 비어있지 않을 때, top()이 여는 괄호가 아니면 비유효, 문자열을 전부 훑었을 때, 스택이 비어있지 않다면 비유효이다.

## [3986 - 좋은 단어](https://www.acmicpc.net/problem/3986)

### 1. 해결 핵심 아이디어

- 괄호가 알파벳으로 바뀌었다, 하지만 쌍을 이룬다는 것에는 변함이 없으니 괄호 닫는 문제와 동일하지만 괄호처럼 여는 괄호, 닫는 괄호가 구분되지 않음에 주의하자

### 2. 코멘트

- 'A'나 'B'가 나오면 스택이 비었을 때는 쌓는다
- top()을 확인한다, input과 top()이 동일하다면 쌍을 찾았으므로 pop()시켜준다
- top()을 확인한다, input과 top()이 다르다면 쌓는다
- 최종적으로 스택이 비어있지 않으면, 좋은 단어가 아니다

## [9012 - 괄호](https://www.acmicpc.net/problem/9012)

### 1. 해결 핵심 아이디어

- 닫는 괄호를 하나씩 없애가면서 문제를 푼다, 중간의 원소가 제거될 수 있다, 올바른 문자열이라면 닫는 괄호가 문자열의 처음으로 나올 수 없고, 닫은 괄호가 나올 때마다 없애가는 형태이므로 문제를 풀기에 가장 적절한 선택은 스택이다

### 2. 코멘트

- 여는 괄호가 나오면 스택에 쌓고, 닫는 괄호가 나오면 스택이 비었으면, 비유효, 스택이 비어있지 않을 때, top()이 여는 괄호가 아니면 비유효, 문자열을 전부 훑었을 때, 스택이 비어있지 않다면 비유효이다.

## [10799 - 쇠막대기](https://www.acmicpc.net/problem/10799)

### 1. 해결 핵심 아이디어

- 인접 괄호쌍이 레이저가 되는 것이므로, 인접 괄호쌍에 대한 인덱싱을 이용한 처리가 필요하고, 인접 괄호쌍을 이루지 않는 여는 괄호는 쇠막대기의 시작을 의미한다
- 즉 인접 괄호쌍들이 레이저가 되는 것이고 그것들 외부에 껍데기 괄호들이 막대기들의 개수가 되는 것이므로 인접 괄호쌍을 발견하면 현재 껍데기의 갯수를 세주면 되는데, 스택 사이즈를 통해 알 수 있다
- 인접하지 않은 괄호쌍을 찾게 되면, 쇠막대기를 끝내줘야하는데 레이저에서 잘리는 제일 오른쪽 부분 쇠막대기를 카운트해줘야한다

### 2. 코멘트

- 인접 괄호쌍을 string의 index를 통해 찾아내고, 그 때마다 잘리는 쇠막대기의 총 개수에 스택 사이즈를 누적시킨다
- 인접하지 않은 괄호쌍 또한 string index를 통해 찾아내고, 쇠막대기가 끝났으므로 잘린 제일 오른쪽 부분 막대기의 수를 포함시키기 위해 총 개수에 1을 누적시킨다

## [2504 - 괄호의 값](https://www.acmicpc.net/problem/2504)

### 1. 해결 핵심 아이디어

- 10799 쇠막대기 문제와 같이 인접 괄호쌍이 나올 때마다 숫자로 변환되는 문제로, 인접 괄호쌍에 대한 처리가 필요하다
- 간단한 예제를 통해 누적시킬 값이 어떻게 결정되는지 보자. 여는 괄호가 나올 때마다 2 또는 3이 곱해져야한다, 이를테면 `([(`의 경우 누적으로 곱할 값은 2 \* 3 \* 2이다. 그리고 괄호쌍이 맞춰질 때마다 누적값에서 제외돼야하므로, 2 또는 3으로 나눠서 누적해서 곱해질 값을 정하고 더한다
- `()[[]]`을 보자 처음 누적곱의 값은 1로 시작한다 '('가 나왔고, 2를 곱해서 누적곱의 값은 2이다 ')'가 나왔으므로 다시 2로 나눠서 1이된다, '['가 나왔으므로 3을 곱하고 또 '['가 나왔으므로 3을 곱해서 총 누적곱의 값은 9이다, 계산값에 9를 더하면 최종적으로 11이 나오게된다
- 즉 괄호가 중첩될 때마다 곱하기, 괄호쌍을 찾으면 나누고 인접 괄호쌍이면, 더하기

### 2. 코멘트

- 올바른 괄호쌍인지 판단해줘야하고, 인접 괄호쌍이 나올 때마다 누적합에 더해져야한다
- 올바른 괄호쌍이 아니라면 0을 출력하자
