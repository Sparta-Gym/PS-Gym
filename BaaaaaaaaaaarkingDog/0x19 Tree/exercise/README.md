# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/11725" rel="nofollow">11725 - 트리의 부모 찾기</a>](#11725---트리의-부모-찾기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 코멘트](#2-코멘트)
  - [<a href="https://www.acmicpc.net/problem/1991" rel="nofollow">1991 - 트리 순회</a>](#1991---트리-순회)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 코멘트](#2-코멘트-1)
  - [<a href="https://www.acmicpc.net/problem/4803" rel="nofollow">4803 - 트리</a>](#4803---트리)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 코멘트](#2-코멘트-2)
  - [<a href="https://www.acmicpc.net/problem/15681" rel="nofollow">15681 - 트리와 쿼리</a>](#15681---트리와-쿼리)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 코멘트](#2-코멘트-3)
  - [<a href="https://www.acmicpc.net/problem/1240" rel="nofollow">1240 - 노드사이의 거리</a>](#1240---노드사이의-거리)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 코멘트](#2-코멘트-4)
  - [<a href="https://www.acmicpc.net/problem/22856" rel="nofollow">22856 - 트리 순회</a>](#22856---트리-순회)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 코멘트](#2-코멘트-5)
  - [<a href="https://www.acmicpc.net/problem/1068" rel="nofollow">1068 - 트리</a>](#1068---트리)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 코멘트](#2-코멘트-6)
  - [<a href="https://www.acmicpc.net/problem/20955" rel="nofollow">20955 - 민서의 응급 수술</a>](#20955---민서의-응급-수술)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 코멘트](#2-코멘트-7)
  - [<a href="https://www.acmicpc.net/problem/14267" rel="nofollow">14267 - 회사 문화 1</a>](#14267---회사-문화-1)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
    - [2. 코멘트](#2-코멘트-8)
  - [<a href="https://www.acmicpc.net/problem/2250" rel="nofollow">2250 - 트리의 높이와 너비</a>](#2250---트리의-높이와-너비)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-9)
    - [2. 코멘트](#2-코멘트-9)
  - [<a href="https://www.acmicpc.net/problem/2533" rel="nofollow">2533 - 사회망 서비스(SNS)</a>](#2533---사회망-서비스sns)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-10)
    - [2. 코멘트](#2-코멘트-10)
  - [<a href="https://www.acmicpc.net/problem/1967" rel="nofollow">1967 - 트리의 지름</a>](#1967---트리의-지름)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-11)
    - [2. 코멘트](#2-코멘트-11)
  - [<a href="https://www.acmicpc.net/problem/1167" rel="nofollow">1167 - 트리의 지름</a>](#1167---트리의-지름)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-12)
    - [2. 코멘트](#2-코멘트-12)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 11월 21일 월요일 10시 44분 57초 KST -->

<!--te-->

## [11725 - 트리의 부모 찾기](https://www.acmicpc.net/problem/11725)

### 1. 해결 핵심 아이디어

- 탐색할 때, 방문체크 배열대신 부모 배열사용하면 쉽게 해결가능

### 2. 코멘트

- 패스

## [1991 - 트리 순회](https://www.acmicpc.net/problem/1991)

### 1. 해결 핵심 아이디어

- 전위, 중위, 후위 순회 결과 출력해주면 끝
- 각 재귀마다 stdout하면 오래걸릴 수 있으므로 string concatnation 이용했음

### 2. 코멘트

- 패스

## [4803 - 트리](https://www.acmicpc.net/problem/4803)

### 1. 해결 핵심 아이디어

- 입력으로 주어지는 그래프가 트리인지 판단하기 위해 사이클을 체크하는 용도로 dfs를 사용하였다
- 사이클의 판단 여부는 트리는 첫 방문이 마지막 방문이어야한다, 왜냐하면 루트부터 임의의 자식으로 가는 경로는 오직 1개이기 때문이다
- 이 사실을 이용해서 인접 정점이 부모가 아니고, 다른 인접 정점을 살펴볼 때 이미 방문 전적이 있더라면 사이클인 것이다

### 2. 코멘트

- 재귀 함수에서 사이클 발견해서 return false했는데, 그 부분만 false로 리턴되는 것이지 전체 결과가 false가 되는게 아니다
- 전체 결과를 보기위해 트리인지 아닌지 판단하는 불리언 변수하나를 전역으로 선언한다음 사이클 발견하면 값을 바꿔주고 리턴시켜야한다
- 멍청한 실수를..

## [15681 - 트리와 쿼리](https://www.acmicpc.net/problem/15681)

### 1. 해결 핵심 아이디어

- dfs와 같이 재귀적으로 트리를 탐색하면서 자식노드의 수를 세는 방식으로 구현
- 사실 문제에 정답이 다 있어서 할 게 별로 없었다
- 다만 주의할 점은 무방향 그래프이기때문에 이미 방문한 정점은 방문 못하게 자식 노드를 이미 센 노드는 방문못하게 prunning하였음

### 2. 코멘트

- 이거 뭔가 다이나믹 프로그래밍스러운 문제인걸?

## [1240 - 노드사이의 거리](https://www.acmicpc.net/problem/1240)

### 1. 해결 핵심 아이디어

- 두 정점사이의 거리(경로 상 가중치 합)을 구하는 문제
- 원래는 두 정점 사이의 최단 거리를 구하는 알고리즘인 벨만 포드를 썼어야 할 것이지만 이 문제는 N, M모두 상한이 1000이고 시간복잡도는 O(M \* (V+E))이므로 두 정점을 매번 탐색해도 시간제한에 들어올 수 있다
- dfs로 경로를 구해주면 약간 애로사항이 있으므로 bfs를 이용하였음

### 2. 코멘트

- 패스

## [22856 - 트리 순회](https://www.acmicpc.net/problem/22856)

### 1. 해결 핵심 아이디어

- 유사 중위 순회라고 했지만 사실은 중위 순회를 마칠 때까지 간선을 몇 번 거치는지를 세는 문제였음
- 왼쪽이나 오른쪽 자식으로 갈 때 진입할 때랑 되돌아 나올 때 각각 이동횟수를 +1 시켜주면 된다
- 마지막 방문 정점에서 다시 루트로 돌아오는 과정이 이동횟수에 포함되므로 왼쪽자식으로 가는 재귀와 오른쪽자식으로 가는 재귀 사이에서 이동횟수를 갱신해주면 루트로 돌아가는 과정은 빠지게된다

### 2. 코멘트

- 패스

## [1068 - 트리](https://www.acmicpc.net/problem/1068)

### 1. 해결 핵심 아이디어

- dfs를 이용해서 탐색하며 leaf 노드 도달 시 카운트하고, 삭제될 노드를 만나서 prunning시켜서 탐색범위에서 제외시켜 자연스럽게 leaf를 못 세게 막아주었다
- leaf 정점인지 판단하는 법은 부모 이외에 인접이 없어야한다는 점을 이용하였다
- 일직선 트리일 때 주의할 점이 있는데, 다음과 같다

  ![special case](https://user-images.githubusercontent.com/48282185/203670802-ab123ad4-c65c-4803-bfac-a5c12bbe2a9d.png)

  - 이 케이스에서 2가 삭제 대상이라고 했을 때 1이 leaf가 된다, 그래서 이 케이스에 대한 예외 처리가 없으면 기존 leaf 판단법으로는 카운트가 안된다
  - 그래서 인접 리스트의 사이즈가 2이고(부모, 삭제 대상), 다음 정점이 삭제대상이라면 이 케이스에 해당하므로 leaf를 세주었다

### 2. 코멘트

- leaf 노드 카운트할 때는 bfs보단 dfs가 구현이 쉬운 것 같다

## [20955 - 민서의 응급 수술](https://www.acmicpc.net/problem/20955)

### 1. 해결 핵심 아이디어

- 각 연결요소들이 주어지고, 간선을 만들거나 없애서 spanning tree를 만들어줘야하는 문제
- 최소 연산이므로 필요없는 건 하지 말아야한다
- 트리가 되기위해 모든 정점은 연결되어야하므로, 서로 다른 연결 요소끼리 간선으로 이어주고, 연결 요소를 탐색 중 사이클이 발견되면, 제거해줘야한다
- 같은 사이클이 두 번씩 체크되므로 /2를 해주자

### 2. 코멘트

- dfs로 사이클 찾는 거 연습 좀 해야겠다

## [14267 - 회사 문화 1](https://www.acmicpc.net/problem/14267)

### 1. 해결 핵심 아이디어

- 이 문제는 칭찬의 쿼리마다 매번 탐색하면 시간초과가 발생한다
  - 인접리스트로 탐색의 시간복잡도는 O(V+E)이고, 이것을 M번 하므로, O(MV + ME)인데, V와 M의 상한이 10만이기때문이다
- 아이디어가 안 떠올라서 정답코드를 참조하였다
- 칭찬 쿼리를 모두 모아서 미리 저장해놓는다
- 트리를 탐색하면서 모아두었던 칭찬을 한 번에 전파한다

### 2. 코멘트

- 되게 간단한 아이디어인데 왜 생각이 안 났을까?

## [2250 - 트리의 높이와 너비](https://www.acmicpc.net/problem/2250)

### 1. 해결 핵심 아이디어

- 처음에 생각했던 방식은 한 열에 노드가 하나씩만 들어가므로 어떤 노드의 자식의 갯수가 필요한 열의 개수가 된다
- 오른쪽 자식 발견될 때마다 부모 노드는 왼쪽으로 한 칸씩 이동해야한다
- 이런 방식으로 재귀함수를 짜보려했는데 너무 복잡해서 구현이 엄두가 나지 않았다
- 이렇게 하는 게 아닌 것같아서 정답코드를 참조하였다
- 관찰을 통해서 발견했어야하는 점은 '열을 어느 순서로 차지하는가?' 였다
- 그림을 보면 왼쪽 자식에게 자신번호 - 1을 부여하고 자신에게 번호를 부여, 그리고 오른쪽 자식에게 자신 번호 + 1을 부여하는 것을 볼 수 있다 => 중위 순회와 같은 순서이다
- 따라서 중위순회를 돌면서 왼쪽부터 열 번호를 부여하고, 해당 깊이의 열번호의 최소(left)와 최대(right)를 갱신한다

### 2. 코멘트

- 이 문제는 접근을 아예 잘못했었다
- 자식의 개수로 너비를 구할 게 아니라(구할 수 있을지도 모르겠다, 자식이 뭐가 있을지 모르는데 어떻게 구하나?, 그럼 자식을 채우면서 계속 업데이트가 일어나야해서 설사 가능하다한 들 비효율적인 방식일 것이다) 결국에는 너비를 구할 때 열번호가 필요하므로 열 번호의 변화를 관찰했어야 했다

## [2533 - 사회망 서비스(SNS)](https://www.acmicpc.net/problem/2533)

### 1. 해결 핵심 아이디어

- 이 문제는 도저히 어떻게 푸는 건지 감이 안 왔다
- 완전탐색으로는 못 푸는 문제가 없으니 접근법이 전혀 떠오르지 않는다면 시작을 완탐으로 해보자
- 정답 코드를 참조해보니 트리 DP라고 하더라
- 트리 DP는 말그대로 트리라는 비선형 자료구조 위에서 작은 문제를 해결해나가면서 결국에는 전체 문제를 푸는 그런 유형이다

  - 참고

    - [블로그 1](https://chanhuiseok.github.io/posts/algo-56/)

    - [블로그 2](https://justicehui.github.io/hard-algorithm/2019/01/18/treeDP/)

- 보통은 다음과 같은 테이블로 문제를 해결한다고 한다
  - dp[i] = i를 루트로 하는 서브트리의 ~~~
  - dp[i][j] = i를 루트로 하는 서브트리에서 i의 상태가 j일 때 ~~~(정점에 상태가 존재)
- 트리에서 dp를 하기전에 탐색 순서를 미리 정하는 것이 일반적인데, 일반적으로 dfs와 많이 조합해서 사용하고, leaf에 도달하면 리턴되면서 값을 완성해나가는 형태가 일반적이라고 한다
- 이 문제도 위 설명이 보고나서 보니 그런 유형 중 하나였다는 것을 깨달았다, 정점 i를 얼리어답토로 결정할 지 말 지를 보면서 문제를 풀어나가야한다
- i번 정점(단계)에서 풀어야할 문제를 정의해보자
  - dp[i][j] = i번 정점을 j(얼리어답터, 노말)로 결정했을 때 필요한 최소 얼리어답터 수
  - 1. i번 정점을 얼리어답터로 결정한 경우
    - i번과 연결된 인접 노드들은 얼리어답터이던 아니던 상관없다
    - 즉 i번을 루트로 하는 서브트리의 해는 i의 다음 정점이 얼리어답터인 경우와 노말인 경우 두 가지를 봐서 더 작은 경우의 수를 선택해야한다
    - dp[i][얼리어답터] = min(dp[nxt][얼리어답터], dp[nxt][노말])
  - 2. i번 정점을 노말로 결정한 경우
    - i번과 연결된 인접 노드는 반드시 얼리어답터여야한다
    - 즉 i번을 루트로 하는 서브트리의 해는 i의 다음 정점이 얼리어답터인 한 가지 경우만 보면된다
    - dp[i][노말] = dp[nxt][얼리어답터]

### 2. 코멘트

## [1967 - 트리의 지름](https://www.acmicpc.net/problem/1967)

### 1. 해결 핵심 아이디어

- 이 문제를 처음 보고 시도해본 방법은 플로이드 워셜과 비슷한 방법의 알고리즘이었다, dp[i][j]라 할 때 i에서 j로 가는 최대 경로
- 이 방법의 문제점은 너무 많은 예외가 있다는 점이고, 구현도 굉장히 까다로울 것이다
- 고민해보다가 방법이 떠오르지 않아 정답코드를 참조하였다
- 트리의 지름을 구하는 방법은 다음과 같다
  - 1. 임의의 노드 x에서 가장 먼 거리에 있는 노드 a를 찾는다
  - 2. 노드 a에서 가장 먼 거리에 있는 노드 b를 찾는다
  - 3. 트리의 지름은 a와 b를 연결하는 경로이다
- 위의 방법이 트리의 지름을 구한다는 정당성은 귀류법으로 증명 가능하다
- 다음과 같은 케이스를 증명해볼 것이다
  - 증명을 위해 노드 x에서 가장 먼 거리에 있는 노드를 a대신 y라고 가정한다
  - 1. 노드 x가 노드 a이거나 b인 경우
  - 2. 노드 y가 노드 a이거나 b인 경우
  - 3. 경로 x-y와 경로 a-b의 일부가 겹치는 경우
  - 4. 경로 x-y와 경롤 a-b가 아예 겹치지 않는 경우
  - 자세한 증명은 아래 링크를 참고하도록 하고 좀 요약해보면, y는 결국에 a 또는 b가 될 수 밖에 없다는 식의 증명임
  - [참고 1](https://bedamino.tistory.com/15)
  - [참고 2](https://velog.io/@zioo/%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%A7%80%EB%A6%84-%EA%B5%AC%ED%95%98%EA%B8%B0)
- x에서 제일 먼 정점을 구하기 위해 dfs를 한 번 수행하고, 찾은 제일 먼 정점에서 다시 제일 먼 정점을 찾기 위해 다시 한 번 dfs를 수행한다
- 하나의 정점에서 가장 멀리 있는 정점은 원의 지름 부분에 해당하는 정점이다

### 2. 코멘트

![예시](https://user-images.githubusercontent.com/48282185/204123758-6eb3eb9c-0f68-4040-88a4-5705c7b1e8cb.png)

- 4번 케이스는 직관적으로 이해가 안되어 보충설명을 덧붙인다
- d(x,y)에서 보자
  - d(a,y) > d(a,b,v)
  - x에서 가장 먼 정점이 y 이기 때문에 d(a,y) 의 길이가 더 길어야 한다
- d(u,v)에서 보자
  - d(b,v) > d(b,a,y)
  - u와 v 가 트리의 지름이기 때문에(u에서 가장 먼 정점은 v) d(b,v) 의 길이가 더 길어야 한다.
- 1번 식 d(a,y) > d(a,b,v)
- 2번 식 d(b,v) > d(b,a,y)
- 2번 식의 d(b,v) 를 1번 식에 대입하면 d(a,y) > d(a,b,v) > (b, v) > d(b,a,y) 다음과 같은 식이 나오는데 d(a,y) > d(b,a,y 는 불가능하므로 모순이 되고, x에서 제일 먼 정점은 지름의 양 끝점인 u 혹은 v가 될 수 밖에 없다
- d(x,y) 와 d(u,v)가 한 점 이상을 공유할 수 밖에 없다.

## [1167 - 트리의 지름](https://www.acmicpc.net/problem/1167)

### 1. 해결 핵심 아이디어

- 1967번 트리의 지름과 동일한 아이디어로 트리의 지름을 구해주면 된다
- 임의의 정점 x로 부터 가장 먼 정점 a를 찾고, a로 부터 가장 먼 정점 b를 찾았을 때 경로 a-b의 가중치 합이 트리의 지름이 된다
- 입력이 까다롭게 되있기 때문에 처리만 잘해주면 된다

### 2. 코멘트

- 패스
