# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/1920" rel="nofollow">1920 - 수 찾기</a>](#1920---수-찾기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 코멘트](#2-코멘트)
  - [<a href="https://www.acmicpc.net/problem/10816" rel="nofollow">10816 - 숫자 카드 2</a>](#10816---숫자-카드-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 코멘트](#2-코멘트-1)
  - [<a href="https://www.acmicpc.net/problem/18870" rel="nofollow">18870 - 좌표 압축</a>](#18870---좌표-압축)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 코멘트](#2-코멘트-2)
  - [<a href="https://www.acmicpc.net/problem/2295" rel="nofollow">2295 - 세 수의 합</a>](#2295---세-수의-합)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 코멘트](#2-코멘트-3)
  - [<a href="https://www.acmicpc.net/problem/1654" rel="nofollow">1654 - 랜선 자르기</a>](#1654---랜선-자르기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 코멘트](#2-코멘트-4)
  - [<a href="https://www.acmicpc.net/problem/10815" rel="nofollow">10815 - 숫자 카드</a>](#10815---숫자-카드)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 코멘트](#2-코멘트-5)
  - [<a href="https://www.acmicpc.net/problem/1822" rel="nofollow">1822 - 차집합</a>](#1822---차집합)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 코멘트](#2-코멘트-6)
  - [<a href="https://www.acmicpc.net/problem/16401" rel="nofollow">16401 - 과자 나눠주기</a>](#16401---과자-나눠주기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 코멘트](#2-코멘트-7)
  - [<a href="https://www.acmicpc.net/problem/2805" rel="nofollow">2805 - 나무 자르기</a>](#2805---나무-자르기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
    - [2. 코멘트](#2-코멘트-8)
  - [<a href="https://www.acmicpc.net/problem/18869" rel="nofollow">18869 - 멀티버스 Ⅱ</a>](#18869---멀티버스-ⅱ)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-9)
    - [2. 코멘트](#2-코멘트-9)
  - [<a href="https://www.acmicpc.net/problem/2467" rel="nofollow">2467 - 용액</a>](#2467---용액)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-10)
    - [2. 코멘트](#2-코멘트-10)
  - [<a href="https://www.acmicpc.net/problem/3151" rel="nofollow">3151 - 합이 0</a>](#3151---합이-0)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-11)
    - [2. 코멘트](#2-코멘트-11)
  - [<a href="https://www.acmicpc.net/problem/14921" rel="nofollow">14921 - 용액 합성하기</a>](#14921---용액-합성하기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-12)
    - [2. 코멘트](#2-코멘트-12)
  - [<a href="https://www.acmicpc.net/problem/1253" rel="nofollow">1253 - 좋다</a>](#1253---좋다)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-13)
    - [2. 코멘트](#2-코멘트-13)
  - [<a href="https://www.acmicpc.net/problem/2143" rel="nofollow">2143 - 두 배열의 합</a>](#2143---두-배열의-합)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-14)
    - [2. 코멘트](#2-코멘트-14)
  - [<a href="https://www.acmicpc.net/problem/2473" rel="nofollow">2473 - 세 용액</a>](#2473---세-용액)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-15)
    - [2. 코멘트](#2-코멘트-15)
  - [<a href="https://www.acmicpc.net/problem/2110" rel="nofollow">2110 - 공유기 설치</a>](#2110---공유기-설치)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-16)
    - [2. 코멘트](#2-코멘트-16)
  - [<a href="https://www.acmicpc.net/problem/7453" rel="nofollow">7453 - 합이 0인 네 정수</a>](#7453---합이-0인-네-정수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-17)
    - [2. 코멘트](#2-코멘트-17)
  - [<a href="https://www.acmicpc.net/problem/12015" rel="nofollow">12015 - 가장 긴 증가하는 부분 수열 2</a>](#12015---가장-긴-증가하는-부분-수열-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-18)
    - [2. 코멘트](#2-코멘트-18)
  - [<a href="https://www.acmicpc.net/problem/2512" rel="nofollow">2512 - 예산</a>](#2512---예산)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-19)
    - [2. 코멘트](#2-코멘트-19)
  - [<a href="https://www.acmicpc.net/problem/1477" rel="nofollow">1477 - 휴게소 세우기</a>](#1477---휴게소-세우기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-20)
    - [2. 코멘트](#2-코멘트-20)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 11월  3일 목요일 13시 15분 52초 KST -->

<!--te-->

## [1920 - 수 찾기](https://www.acmicpc.net/problem/1920)

### 1. 해결 핵심 아이디어

- 전체 원소를 둘러보는 O(N)의 탐색방법을 이용하면 N과 M의 상한이 모두 십만이기때문에 시간초과를 받는다
- 정렬과 이분탐색을 이용하면 O(NlogN)에 해결 가능하다

### 2. 코멘트

- 정렬하고 이분탐색해주고 있으면 1 없으면 0을 출력한다

## [10816 - 숫자 카드 2](https://www.acmicpc.net/problem/10816)

### 1. 해결 핵심 아이디어

- 배열 내에서 빈도수를 확인할 때 이분탐색이 활용될 수 있는데, 찾고자 하는 원소의 시작 인덱스와 끝 인덱스만 알면 그 차로 몇 개가 있는지 알 수 있는 원리이다
- mid를 시작인덱스라고 두고 a[mid] >= target일 때는 en을 mid로 변경, 반대의 경우는 st = mid + 1로 변경하여 st = en이 될 때까지 수행한다
  - a[mid] >= target일 때 en을 mid로 변경하는 이유는 mid가 오름차순을 유지하고 target을 삽입 가능한 가장 오른쪽 인덱스일 수도 있기 때문이다
  - a[mid] < target일 때 st로 mid + 1로 변경하는 이유는 mid가 오름차순을 유지하고 target을 삽입가능한 가장 왼쪽 인덱스일 수도 있기 때문이다
  - 오름차순을 유지하면서 삽입 가능한 가장 왼쪽 인덱스에 위치한 원소는 target과 같거나 커야한다 target이 연속되고 있는 구간의 아무데나 삽입해도 순서를 유지할 수 있기때문임
  - st가 target의 연속 구간 중간에 있으면 어쩌냐고 생각할 수 있는데 애초에 그런 상황이 발생하지 않는게 a[mid] < target일 때만 1씩 이동시키기때문에 st가 연속 구간의 중간에 있을 일은 없다
  - 시작 인덱스를 구한 방법과 마찬가지로 끝 인덱스로 구할 수 있음, 이번에는 mid가 끝 인덱스로 두고 st = en 전까지 a[mid] <= target일 때는 st = mid + 1로 두고, 반대의 경우는 en = mid로 두면서 st와 en을 갱신해주면된다 마찬가지로 en이 연속 구간 중간에 올 일은 발생하지 않는다

### 2. 코멘트

- 위에서 설명한 방식 곧이 곧대로 시작 인덱스를 구하는 함수와 마지막 인덱스를 구하는 함수를 각각 구현한 다음 그 차이를 계산해주면 된다
- STL에도 lower_bound(target이 등장하는 최초 위치), upper_bound(target이 등장하는 마지막 위치)라는 함수가 있어서 이것들을 활용해도 된다
  - 이것들의 원리가 이분탐색이라는 것만 알고있자
- 빈도수 배열로 풀리기는 한데, only 이분 탐색으로만 빈도수를 구해야하는 상황은 메모리 제한이 넉넉치 못한 문제일 때임

## [18870 - 좌표 압축](https://www.acmicpc.net/problem/18870)

### 1. 해결 핵심 아이디어

- 이 문제는 어떤 원소보다 작은 원소의 갯수를 알아내는 문제임
- 출력을 위해 원래 순서를 기억할 필요가 있음
- 10816번 숫자 카드 2에서 사용했던 아이디어를 활용할 수 있는데, 어떤 원소 target보다 작은 원소의 수는 배열의 크기에서 최초 등장 위치로 알 수 있다 만약 최초 등장 위치가 4였으면 target보다 작은 원소의 수는 3개이다

### 2. 코멘트

- 배열의 중복 원소를 제거한 다음 이분 탐색 코드에서 mid를 반환하게 하는 방법도 있음

## [2295 - 세 수의 합](https://www.acmicpc.net/problem/2295)

### 1. 해결 핵심 아이디어

- 이 문제를 가장 간단하게 해결할 수 있는 솔루션은 4중 반복문으로 세 수를 선택하고, 그 합이 배열 내에 있는지 탐색하는 방법이다
  - 이 방법은 N의 상한이 1,000이므로 시간 제한을 통과하지 못한다
- 시간 제한을 통과하려면 적어도 O($N^{2}logN$)의 시간복잡도를 갖는 알고리즘을 설계해야한다
- 내가 생각했던 방법은 반복문을 최소 2번만 허용하니까 두 수의 합을 미리 구해놓고, 원소 u[i] - u[j]를 했을 때 이 합 배열 내에 그 결과가 있으면 되는 거니까 최대 O($N^{2}logN$)의 시간복잡도를 갖기때문에 통과 가능한 것이었다
- 이 문제와 같이 세 쌍 이상의 조합을 묶고 어느 한 값을 이분탐색으로 찾아 시간복잡도를 낮추는 아이디어는 이분탐색 유형의 핵심 아이디어이다, 뭔가 묶어서 있는지 검사하는 문제 유형의 경우 이분탐색을 고려해볼 수 있다

### 2. 코멘트

- 같은 원소가 여러번 뽑힐 수 있음에 유의하자
- 정렬이 된 상태이므로 i는 n-1부터 시작하여 줄이고, j는 0부터 시작하게 하여 더 빨리 찾을 수 있도록 하는 소소한 최적화도 적용했음

## [1654 - 랜선 자르기](https://www.acmicpc.net/problem/1654)

### 1. 해결 핵심 아이디어

- 이 문제를 관찰하다보면 다음과 같은 통찰을 얻을 수 있음
  - 랜선의 길이와 개수는 반비례 관계임(개수가 많아질수록 분할이 많아지기에 길이가 짧아짐)
  - 탐색 범위가 굉장히 크다 N의 상한은 백만이고, 랜선의 길이는 $2^{31} - 1$ 가 상한이다
  - 랜선의 길이가 x이 되도록 분할했을 때 N개 이상을 만들 수 있는가 결정하는 문제로 환원가능하다
- 만약 n개 미만의 랜선을 만들 수 있다면, en을 mid-1로 갱신하고, n개 이상을 만들 수 있다면, 정답 후보이지만 더 긴 것이 존재하나 살펴봐야하기에 st를 mid로 갱신한다

### 2. 코멘트

- 주의할 것이 있는데 기존의 이분탐색처럼 mid를 st + en / 2로 두면 무한루프에 빠질 수 있는데, 이유는 st가 en-1이 됬을 때 갱신이 더 이상 안 되기 때문인데, 이를 회피하기 위해 mid를 st + en + 1 / 2로 두어 탈출이 가능하게 만들어준다

## [10815 - 숫자 카드](https://www.acmicpc.net/problem/10815)

### 1. 해결 핵심 아이디어

- 배열 내의 원소의 존재를 확인하는 문제
- 이분탐색으로 찾아주자

### 2. 코멘트

- 간단해서 스킵

## [1822 - 차집합](https://www.acmicpc.net/problem/1822)

### 1. 해결 핵심 아이디어

- a의 원소가 b에도 있난 존재를 탐색하는 문제
- 이분탐색으로 간단히 해결할 수 있음

### 2. 코멘트

- 간단해서 스킵

## [16401 - 과자 나눠주기](https://www.acmicpc.net/problem/16401)

### 1. 해결 핵심 아이디어

- 1654번 랜선 자르기와 동일한 아이디어
- 모든 조카에게 같은 길이의 막대과자를 나눠줄 수 없는 경우가 있는 이를테면 조카는 2명인데 길이 1인 과자는 1개일 때는 같은 길이로 나눠줄 수 없기때문에, st가 갱신되지 않을 것임

### 2. 코멘트

- 1654번 랜선 자르기와 동일한 풀이어서 딱히 코멘트 남길 게 없음

## [2805 - 나무 자르기](https://www.acmicpc.net/problem/2805)

### 1. 해결 핵심 아이디어

- 1654번 랜선 자르기와 동일한 아이디어
- 현재 살펴보는 길이 x보다 긴 나무만 선택해서 잘랐을 때 m을 넘는가?를 확인하는 결정문제로 환원

### 2. 코멘트

- 1654번 랜선 자르기와 거의 동일한 풀이어서 딱히 코멘트 남길 게 없음

## [18869 - 멀티버스 Ⅱ](https://www.acmicpc.net/problem/18869)

### 1. 해결 핵심 아이디어

- 두 배열의 증감관계가 같은지 판단하는 문제
- 내가 접근한 방식은 두 원소쌍을 일일이 검사하는 방법은 시간초과가 나니, 각 원소를 크기 순으로 나타냈을 때 그 크기 순 배열의 원소의 값이 같으면 두 배열의 증감은 똑같으므로 각 원소들을 복사한다음 정렬하고 lower_bound로 크기 순으로 나타낸 뒤 m개의 쌍에 대해서 각각 크기 순 배열이 같은지 비교해줬다
- 정답코드를 보니 이것을 좌표압축이라고 하더라(18870번 문제랑 같은 원리인지는 간파하지 못함)

### 2. 코멘트

- 배열 a를 벡터로 그대로 복제하는 법 `vector<int> tmp(a, a + n);`

## [2467 - 용액](https://www.acmicpc.net/problem/2467)

### 1. 해결 핵심 아이디어

- 이 문제를 처음 접근할 때는 부호가 다르고 두 용액을 합한 값의 절댓값이 작으면 갱신해주고 아니면 패스하고 다음 탐색 진행하는 것으로 생각을 하고, 다음 탐색은 오른쪽과 왼쪽의 mid를 살펴보고 더 최적인 경우를 따라갔는데(-1000000 -99 99 100 101 102 103 104 105와 같이 한쪽으로 치우쳐져있는 케이스가 있음), 고려 못한 경우는 cur(현재 가리키고 있는 원소)와 왼쪽 mid의 합이 오른쪽 mid와의 합보다 더 최적이어서 탐색범위를 왼쪽으로 설정했는데, 정작 답은 오른쪽 근처에 있을 수도 있기 때문이다
- 맞왜틀만 5시간은 한 것 같다.. 이거 적으면서 안되는게 생각나버렸음
- 오기때문에 스스로 결판짓고 싶었지만 결국에는 정답코드를 참고하였다
- 솔루션
  - lower_bound를 이용하여 -cur과 같거나 큰 원소 중 가장 작은 원소를 찾는다
  - lower_bound로 나온 인덱스를 idx라 할 때, cur과 더해서 값이 가장 작은 원소는 a[idx + 1], a[idx], a[idx - 1] 중 하나이고, 같은 용액을 두 번쓸 수 없기때문에 idx와 cur의 위치는 같으면 안됨에 주의하자

### 2. 코멘트

- lower_bound랑 upper_bound를 아직 잘 활용못하는 것 같다, 정진하자

## [3151 - 합이 0](https://www.acmicpc.net/problem/3151)

### 1. 해결 핵심 아이디어

- 2295번 세 수의 합 문제의 응용인줄 알고 동일하게 접근했다가 낭패를 봤다, 일단 내 실수는 원소의 중복을 고려하지 않았다는 점과 같은 케이스를 중복으로 카운트했다는 점이다
- i, j 두 수를 선택하고 합을 만드는 나머지 하나 즉, -i-j를 찾는데, 원소의 중복을 고려해주기위해 해당 원소가 몇 번나오는지 계산해줄 필요가 있다 이 때 원소가 몇번 등장하는지는 upper_bound와 lower_bound를 이용하여 계산한다, 단순히 binary_search를 쓰면 한 번만 찾고 끝내기 때문에 원소의 중복을 고려하지 않게된다
- 같은 케이스를 중복으로 세지 않기 위해 i와 j이후만 검사해야한다 즉, j+1 ~ n에서 -i-j가 몇 번 등장하는지를 세야한다는 것이다

### 2. 코멘트

- 원소가 중복되는 자료구조에서 몇 개인지 셀 때 upper_bound와 lower_bound의 차를 이용하는 점을 배우고간다

## [14921 - 용액 합성하기](https://www.acmicpc.net/problem/14921)

### 1. 해결 핵심 아이디어

- 2467번 용액과 같은 문제
- 특성값만 기억하면 돼서 더 간단한 문제

### 2. 코멘트

- duplicated 2467

## [1253 - 좋다](https://www.acmicpc.net/problem/1253)

### 1. 해결 핵심 아이디어

- lower_bound와 upper_bound를 이용하여 합이 몇 번이나 등장하는지 체크하였고, is_used라는 배열을 두어 이전에 카운트됬던 좋은 수는 중복 체크 안되게하였다
- 모든 수가 0으로 이뤄진 특별한 경우 내 코드는 시간복잡도가 O($N^3$)이라 시간초과가 나지만 이 경우만 예외로 처리해주면 AC를 받을 수 있고, 이 경우를 제외하고 시간초과를 내는 테스트 케이스가 있을지도 생각해봤는데 딱히 떠오르진 않는다
- 매번 lb와 ub를 체크해줘야되어 좀 비효율적인 방식이라 다른 정답코드도 찾아보았음, 서로 다른 두 수 i, j의 차를 lower_bound로 찾아서 이 값이 i또는 j인 경우를 제외하고, lb의 값이 i-j가 맞을 경우 정답을 카운트하고 break시켜서 다음 i를 살펴보게하는 방식이었음, 내 방식보다 효율적이긴 하지만 이 방식은 문제가 하나 있는데 모든 숫자가 0으로 이루어졌을 때는 올바른 정답을 낼 수가 없다는 것임 그래서 내 방식은 좀 비효율적이지만 올바른 정답을 내는 알고리즘이고, 참고한 방식은 효율적이긴하지만 모든 경우에서 올바른 정답을 내는 알고리즘이 아니라 뭐가 더 옳은 것인지 모르겠다

### 2. 코멘트

- 문제 제목 그대로 좋은 문제였음 특히 0이 섞여서 매우 골치아픔

## [2143 - 두 배열의 합](https://www.acmicpc.net/problem/2143)

### 1. 해결 핵심 아이디어

- 이 문제는 처음에 이해를 잘못해서 너무 어렵게 생각했었다, 문제의 정의에 따르면 부배열의 합은 연속 구간 내의 원소의 합이지 연속되지 않은 원소끼리의 합으로 구성될 수 없다는 것이다, 처음에는 후자도 된다고 생각하였는데, 이게 아니라고 생각하니까 문제가 단순해졌다
- a배열과 b배열의 모든 부 배열의 합을 구한다, 각각 n(n-1) / 2, m(m-1) / 2개가 생기기때문에 메모리 제한과 시간 제한 내에 들어올 수 있다
- a배열의 부배열의 합의 모든 원소(sub)를 돌면서 b배열의 부배열의 합에 t - sub가 몇 개 존재하는지 살펴본다(원소의 중복이 있을 수 있기 때문)

### 2. 코멘트

- 문제 이해를 잘하자

## [2473 - 세 용액](https://www.acmicpc.net/problem/2473)

### 1. 해결 핵심 아이디어

- 처음에는 두 용액을 합을 미리 구해놓고 하나를 찾을까 생각해봤는데, 좀 비효율적인 것 같아 두 수의 합의 절댓값은 같지만 부호는 다른 수와 같거나 그보다 큰 수의 위치를 찾고나서(lb), lb의 좌로 2, 우로 2까지가 값의 후보이므로 최적을 찾아주면된다
- 2467번 용액문제 처럼 lb의 좌로 1, 우로 1까지만 탐색해도 통과는 할 수 있지만, 2467번이나 이 문제에서나 답이 sol[a], sol[b], sol[c]이라고 하면 i = a, j = b 혹은 i = b, j = c일 때 "lb-1, lb, lb+1" 위치만 확인할 경우 k를 잘못 구할 수 있지만, 적어도 i = a, j = c일 때에는 k = b를 잘 찾을 수 있기 때문이다.

### 2. 코멘트

- 이렇게 세 개 이상의 조합을 구해야하는 문제에서는 미리 두 개의 합을 구하고 들어가거나 아니면 두개를 합한 값을 찾거나 하는 유형 두 가지로 분류된다 문제에 따라 어떤 방식이 더 적합할지 고민하자

## [2110 - 공유기 설치](https://www.acmicpc.net/problem/2110)

### 1. 해결 핵심 아이디어

- 이 문제를 관찰하다보니 다음과 같은 솔루션이 떠올랐음, 거리 x를 미리 정하고, 이것을 만족하는 두 집의 조합이 c-1개 이상인지를 살펴보는 것이었음
- 첫 번째 집부터 시작하여 거리가 x이상인 집의 좌표를 lower_bound를 이용해서 찾고, 한 구간 내에 다른 집이 들어가는 것을 방지하기 위해 다음 살펴볼 좌표를 lower_bound로 두었음
- 거리 x를 만족하는 쌍이 c-1개 이상이면 가능한 거리임
- 처음에 취했던 방식은 극단적인 케이스를 고려안했었는데 2개의 집이 각각 0과 십억에 위치하면 거리를 1씩 늘려가면서 살펴보는 방식은 시간초과를 맞았고(살펴봤어야했는데 안 살펴봤음..) 이 거리 또한 이분탐색으로 정해줬어야함 가능한 거리면 탐색 위치를 오른쪽으로 불가능하면 거리를 줄여야하므로 탐색위치를 왼쪽으로 설정해서 x를 설정하는 것 또한 이분탐색으로 해결해야함

### 2. 코멘트

- 문제를 완벽히 이해했나 확인하고 풀이를 시작할 것

## [7453 - 합이 0인 네 정수](https://www.acmicpc.net/problem/7453)

### 1. 해결 핵심 아이디어

- 이 문제는 입력이 어떻게 들어오는지 제대로 보지않아 계속 틀리던 중 문제를 잘못이해하나 싶어서 질문탭의 글을 봤는데, 스포당해버렸다
- 내가 처음 시도했던 방식은 a, b, c를 다 더하여 저장한 다음, -d를 합 배열에서 찾아주는 방식으로 했는데 이 방식은 메모리 초과를 맞는다, 일단 무지성으로 들이박았는데 안되는건 당연지사 세 배열의 합을 저장하기 위해서는 $n^3$ 크기가 필요하고 n의 상한이 4000이기때문에 640억이 필요함, 4byte \* 640억이면 당연히 안되겠죠?
- 그래서 이것을 해결하기 위해 생각을 했어야하는데 본의아니게 스포당해버렸음..
- 정답의 풀이 방식은 두 개씩 나눠서 해결하는 방식이었음 a와 b의 합과 c와 d의 합을 각각 따로 저장한 다음 둘 중 하나를 정렬하고 0을 만들기 위해 -를 붙여서 해당 원소가 있는지 upper_bound와 lower_bound를 통해 개수를 찾아준다

### 2. 코멘트

- 정답코드를 보다가 최적화 관련된 기법을 하나 발견했음
- 논리상으로는 이분탐색의 대상이 될 배열만 정렬해주면되지만, 속도를 높이기위해서는 탐색 대상이 될 배열도 정렬해줘야하는데, 이유는 cache hit이 높아지기 때문이다 이유는 이분탐색할 때 연속적으로 이전에 봤던 위치들을 중심으로 다시 탐색하게 될 확률이 높아지기 때문(spartial locality)
- [링크](https://www.acmicpc.net/board/view/74585)

## [12015 - 가장 긴 증가하는 부분 수열 2](https://www.acmicpc.net/problem/12015)

### 1. 해결 핵심 아이디어

- 이 문제는 30분 이상 고민해봤지만 동적계획법 풀이에 얽매여서 솔루션 근처에 가지도 못했음, 매우 어려웠다
- 어떻게하면 가장 많은 값을 넣을 수 있겠느냐?의 문제가 제일 긴 수열을 만들 수 있는가? 문제와 일맥상통한다
- lis란 무엇인가? 가장 긴 부분수열이고, 키포인트는 증가한다는 특징과 가장 길다는 특징이다
- 증가는 선행 원소보다 후행 원소가 커야한다는 것이고, 가장 길다는 것은 제한된 수의 범위 내 볼 때 상호 원소간 값의 차이가 적어야 더 많은 것을 우겨넣을 수 있다는 의미이다
- 이제 수열을 돌면서 lis를 만들어보자
  - lis배열이 비었거나 현재 원소보다 큰 값이 없다면 lis에 현재 원소를 추가한다
  - lis배열 내에 현재 원소보다 큰 값이 한 개이상 있을 때, 이것보다 크면서 제일 작은 값을 찾아 현재원소와 대치한다
  - 간단한 예시를 하나 살펴보자
    - {10, 20, 30, 15, 20, 30, 50, 40, 45, 60}
    - lis의 초기값은 빈 배열이다
    - 10을 살펴본다, 배열이 비었으니 추가 / {10}
    - 20을 살펴본다, 20보다 큰 값이 없으니 추가 / {10, 20}
    - 30을 살펴본다, 30보다 큰 값이 없으니 추가 / / {10, 20, 30}
    - 15를 살펴본다, 15보다 큰 값은 20과 30이 있는데 그 중 가장 작은 값인 20이 15로 대치된다 / {10, 15, 30}
    - 이 과정을 마지막 원소까지 반복한다
  - 근데 이상한 점이 있다 15가 교체될 때 왜 20과 30이 빠지지 않고, 15와 대치를 시켜줘야하는 것일까? {10, 20, 30, 15}를 보자 위 과정과 동일하게 진행하지 않고 즉, 대치를 하지않고 큰 원소를 모두 삭제한다고 할 때 15가 나오면 답이 2로 갱신된다 "그럼 대치하지말고 큰 원소 다 없애는 방식으로 lis를 만들었을 때 그 길이를 가지고 계속 최대값을 갱신해나갈 수 있지 않느냐?" 라는 질문을 스스로 던져봤는데, 만약 {10, 20, 30, 15, `9`, 20, 30, 50, 40, 45, 60} (위 예시에서 중간에 9 추가)라는 예시에서 9가 나올 때 이거보다 큰 원소를 다 없애버리면 정답인 {10, 15, 20, 30, 40, 45, 45, 60}을 만들 수 없다
  - 즉 이분탐색을 이용하면 lis의 원소를 정확히 못구할 수도 있다, 하지만 길이를 구하는 문제에 한정해서는 대치이기 때문에 길이가 변화하지 않아서 올바른 정답을 낼 수 있다, 결론은 lis의 길이를 구하는 문제는 이분탐색이 동적계획법보다 더 효율적인 알고리즘이다

### 2. 코멘트

- [참고한 블로그](https://st-lab.tistory.com/285)

## [2512 - 예산](https://www.acmicpc.net/problem/2512)

### 1. 해결 핵심 아이디어

- 전형적인 parametric search 문제
- st를 0, en을 10억으로 두고 이분탐색을 진행한다, 만약 mid로 정한 상한이 모든 정부에 나눠줄 수 있을때는 가능하니까 최대를 찾기위해 st를 mid로 설정하여 오른쪽 탐색, 불가능할 때는 en을 mid-1로 설정하여 이 상한보다 낮춰서 왼쪽 탐색
- 상한이 예산 요청치의 최대보다 클 필요는 없으니 이 경우에는 왼쪽을 탐색시킨다

### 2. 코멘트

- 응용문제라 뭔가 트릭이 숨어있을 줄 알았는데 없었음..

## [1477 - 휴게소 세우기](https://www.acmicpc.net/problem/1477)

### 1. 해결 핵심 아이디어

- 첫 시도한 알고리즘은 그리디하게 현재 설치되어있는 구간 중 제일 넓은 구간을 선택하여 그것을 이분할하면서 m개가 될 때까지 반복하는 것이었다
- 그런데 이 그리디 풀이가 항상 정해를 내주지 않는다 아래를 보자
  ![반례](https://user-images.githubusercontent.com/48282185/198218063-41117967-ab8f-416d-81b6-cf9b7316a8ea.png)

- 이처럼 무조건 이분할하면 안되는 경우들이 생긴다
- 거리의 최대를 정해주고 그것이 들어맞는지 보는 결정문제로 환원해야한다, parametric search
- 두 휴게소 간의 거리 차를 보고 정해준 거리의 최대로 나눴을 때 주유소가 m개 생길 수 있는지를 봐야한다
- 구간을 정해진 거리 차로 등분해주면 몇 개가 필요한지 나오는데 예시를 보자
- 어떤 구간의 차가 7이고 정해준 거리가 2라고 했을 때 필요한 휴게소의 개수는 3개이다(2, 2, 2, 1)
- 어떤 구간의 차가 8이고 정해준 거리가 2라고 했을 때 필요한 휴게소의 개수는 3개이다(2, 2, 2, 2)
- 정해준 거리 차보다 짧은 구간에서는 등분이 안될테니 거기는 정답에 포함되지않고, 등분이 가능한 구간에서 휴게소를 건설한다
- 모든 휴게소 사이를 살펴보고 난 뒤, 건설된 휴게소의 개수가 m개를 초과하면 불가능하므로 거리 차를 벌려야한다
- 반대로 m개와 같거나 적은 경우는 다 건설하지 못한 경우이니 거리 차를 좁혀야한다

### 2. 코멘트

- 그리디 단원 강의 때, 잘못된 그리디로 나왔던 예시인데.. 어쩐지 문제가 응용문제치곤 너무 쉽게 느껴져서 이상했다
