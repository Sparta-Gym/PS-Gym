# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/1753" rel="nofollow">1753 - 최단경로</a>](#1753---최단경로)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 코멘트](#2-코멘트)
  - [<a href="https://www.acmicpc.net/problem/11779" rel="nofollow">11779 - 최소비용 구하기 2</a>](#11779---최소비용-구하기-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 코멘트](#2-코멘트-1)
  - [<a href="https://www.acmicpc.net/problem/1238" rel="nofollow">1238 - 파티</a>](#1238---파티)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 코멘트](#2-코멘트-2)
  - [<a href="https://www.acmicpc.net/problem/1504" rel="nofollow">1504 - 특정한 최단 경로</a>](#1504---특정한-최단-경로)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 코멘트](#2-코멘트-3)
  - [<a href="https://www.acmicpc.net/problem/1916" rel="nofollow">1916 - 최소비용 구하기</a>](#1916---최소비용-구하기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 코멘트](#2-코멘트-4)
  - [<a href="https://www.acmicpc.net/problem/1261" rel="nofollow">1261 - 알고스팟</a>](#1261---알고스팟)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 코멘트](#2-코멘트-5)
  - [<a href="https://www.acmicpc.net/problem/17835" rel="nofollow">17835 - 면접보는 승범이네</a>](#17835---면접보는-승범이네)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 코멘트](#2-코멘트-6)
  - [<a href="https://www.acmicpc.net/problem/20183" rel="nofollow">20183 - 골목 대장 호석 - 효율성 2</a>](#20183---골목-대장-호석---효율성-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 코멘트](#2-코멘트-7)
  - [<a href="https://www.acmicpc.net/problem/24042" rel="nofollow">24042 - 횡단보도</a>](#24042---횡단보도)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
    - [2. 코멘트](#2-코멘트-8)
  - [<a href="https://www.acmicpc.net/problem/1162" rel="nofollow">1162 - 도로포장</a>](#1162---도로포장)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-9)
    - [2. 코멘트](#2-코멘트-9)
  - [<a href="https://www.acmicpc.net/problem/1854" rel="nofollow">1854 - K번째 최단경로 찾기</a>](#1854---k번째-최단경로-찾기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-10)
    - [2. 코멘트](#2-코멘트-10)
  - [<a href="https://www.acmicpc.net/problem/5719" rel="nofollow">5719 - 거의 최단 경로</a>](#5719---거의-최단-경로)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-11)
    - [2. 코멘트](#2-코멘트-11)
  - [<a href="https://www.acmicpc.net/problem/13907" rel="nofollow">13907 - 세금</a>](#13907---세금)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-12)
    - [2. 코멘트](#2-코멘트-12)
  - [<a href="https://www.acmicpc.net/problem/22870" rel="nofollow">22870 - 산책 (large)</a>](#22870---산책-large)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-13)
    - [2. 코멘트](#2-코멘트-13)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 12월 10일 토요일 09시 28분 01초 KST -->

<!--te-->

## [1753 - 최단경로](https://www.acmicpc.net/problem/1753)

### 1. 해결 핵심 아이디어

- 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구해라 => 하나의 정점에서 다른 모든 정점으로의 최단 거리를 구해라 => 다익스트라 쓸 수 있다
- 모든 간선의 가중치는 10 이하의 자연수이다 => 음수 가중치를 갖는 간선이 없다 => 다익스트라 써라

### 2. 코멘트

- 패스

## [11779 - 최소비용 구하기 2](https://www.acmicpc.net/problem/11779)

### 1. 해결 핵심 아이디어

- 다익스트라 알고리즘을 사용하여 임의의 한 점에서 다른 임의의 한 점으로 가는 최단 경로 구하는 문제
- 다익스트라 알고리즘을 수행하면서 경로 복원 테이블을 이용하여 경로 복원을 할 수 있다

### 2. 코멘트

- 패스

## [1238 - 파티](https://www.acmicpc.net/problem/1238)

### 1. 해결 핵심 아이디어

- 모든 시작점에서 x까지의 최단거리, x에서 다른 모든 정점까지의 거리가 필요해서 모든 정점 간의 최단거리를 구하는 알고리즘인 플로이드를 이용할 수도 있겠지만 정점 n의 상한이 1000이라 플로이드로는 시간 초과를 피할 수 없게된다
- 그래서 모든 정점을 시작점으로 하여 다익스트라 알고리즘을 수행하여 모든 정점까지의 최단 거리를 각각 계산해주고, 왕복 거리 중 최대값을 출력해주자
- 시간 복잡도는 우선 순위 큐를 이용한 다익스트라 알고리즘은 O(ElogE)이고 그것을 모든 정점에 대해 수행하므로 O(VElogE)이므로 통과하는데 지장이 없기 때문이다

### 2. 코멘트

- 패스

## [1504 - 특정한 최단 경로](https://www.acmicpc.net/problem/1504)

### 1. 해결 핵심 아이디어

- 어려울 줄 알았는데 의외로 해법이 간단했던 문제
- 그냥 단순하게 생각해서 min{(시작, u) + (u, v) + (v, n), (시작, v) + (v, u) + (u, n)}이 정답이다
- 간선의 가중치를 더하다가 오버플로가 날 것을 생각하지 못하고(중복해서 탈 수 있다) int로 했다가 한참을 해맸다..(쪽팔린 줄 알아라)
- 시작점을 각각 1, u, v로 하여 다익스트라 알고리즘을 수행한 후 위 식을 출력해주면 정답, 최단거리가 INF와 같거나 크면 도달 불가능

### 2. 코멘트

- 패스

## [1916 - 최소비용 구하기](https://www.acmicpc.net/problem/1916)

### 1. 해결 핵심 아이디어

- 시간 제한이 0.5초이긴 하지만 간선의 상한이 십만이고, 우선순위 큐를 이용한 다익스트라 알고리즘의 시간복잡도는 O(ElogE)이므로 시간 제한 내에 들어올 수 있다
- 이 문제의 함정? 은 한 도시에서 출발하여 다른 도시에 도착하는 M개의 버스가 있다는 조건 밖에 없어 임의의 두 도시 u, v사이를 여러 버스가 오갈 수 있다는 것이다(두 정점 사이에 간선이 여러 개 일 수 있다)
- 두 도시를 연결하는 버스가 1대 밖에 없다고하는 말이 없는데 왜 한 개라고 생각했는지.. 조건이 없으면 어떤 모양의 그래프가 될 지 모른다
- 여러 개의 간선을 처리하기 위해 입력을 인접 행렬을 통해서 받았고(최소 값으로 대치하기 위해, 인접 리스트는 그 간선이 있는지 검색하는 과정이 필요) 입력을 모두 받고, 인접리스트에 최종 값을 저장해주었다
- 간선의 가중치의 상한이 십만이고, 간선의 개수의 상한이 십만이라 long long을 사용해야 오버플로를 방지할 수 있다

### 2. 코멘트

- 패스

## [1261 - 알고스팟](https://www.acmicpc.net/problem/1261)

### 1. 해결 핵심 아이디어

- 이 문제는 새로운 차원 개념을 도입하여 BFS로만 해결 가능했던 문제
- 다익스트라 알고리즘으로도 이 문제를 해결할 수 있는데, 플로이드 단원에서 봤던 백양로 브레이크 문제의 아이디어를 사용하였다
- 격자형 그래프에서 한 정점에서 다음 정점으로 갈 때, 그 다음 정점이 벽이라면(1) 가중치를 1로 두고, 반대로 빈 공간이라면 가중치를 0으로 두어 시작점 (1, 1)에서 끝 점(n, m)까지의 최단 거리를 구해주면, 최소 몇 개의 벽을 뚫어야하는지 구할 수 있다

### 2. 코멘트

- 처음에 구현할 때 인접 리스트를 따로 만들어야하나 생각했었는데, 굳이 그럴 필욘 없다

## [17835 - 면접보는 승범이네](https://www.acmicpc.net/problem/17835)

### 1. 해결 핵심 아이디어

- 한 시작점에서 다른 모든 정점으로 최단거리를 구하는 방법으로는 시간초과를 받게된다 => O(VElgE), V, E 상한이 각각 십만, 오십만
- 해결책이 떠오르지 않아서 정답코드를 참조하였다
- 면접장들과 각 도시 사이의 최단거리를 구하는 풀이로 접근
- 풀이에선 문제의 조건과는 반대로 면접장에서 도시로 가야하기 때문에 간선을 입력받을 때 시작 정점과 끝 정점을 반대로 받는다
- 면접장이 있는 도시들은 거리를 0으로 설정하고 우선순위 큐에 넣는다 => 시작점이 여러개인 다익스트라
  - 이렇게 해도 안 꼬이나 생각해봤는데(시작점이 여러 개이므로 각 정점까지의 거리가 각자 다 다를 건데 정확한 결과가 나오는지), 이 문제라서 상관없는 것 같다
  - 면접장까지의 거리가 가장 먼 도시와 그 거리를 구하는 것이다
  - 살펴보는 면접장의 순서에 상관없이 도시 a에서 가장 가까운 면접장이 결정된다 => 최소가 갱신되면 갱신한다
  - 모든 면접장에서 제일 먼 도시 X는 모든 면접장과 X사이의 거리의 최솟값이다
  - 만약 한 정점에서 다른 모든 정점까지의 정확한 거리를 구하라고 했을 때는 이렇게하면 안된다
- multigraph라 인접 행렬을 사용해서 입력받으려했는데, 메모리 초과가 난다, 그냥 인접리스트로 모두 입력받았다

### 2. 코멘트

- 시간복잡도 틀리게 계산하고 삽질할 뻔 했다..

## [20183 - 골목 대장 호석 - 효율성 2](https://www.acmicpc.net/problem/20183)

### 1. 해결 핵심 아이디어

- 이 문제는 어떻게 해결해야할 지 감이 잡히지 않아 정답코드를 참조하였다
- 최대 요금의 최솟값을 구하는 것인데, 이는 이분탐색을 이용하는 parametric search에서 하는 최대의 최소화와 같은 결이다
  - 매개변수탐색은 눈치 못 챌 확률이 높다고 했는데 진짜 쉽지 않네
- 문제 풀이 과정
  1. '최대 요금 상한이 x원일 때, 시작점에서 도착점까지 c원 이하로 갈 수 있는가?'를 판별하는 결정문제로 환원
  2. 최대 상한 요금이 되는 후보들은 실제 통해 요금(간선의 가중치), 이 값들을 바탕으로 매개변수탐색을 진행한다
  3. 시작점에서 도착점까지 가는 경로에 x원을 초과하는 간선이 있으면 더 이상 진행하지 못하고 끝난다 => 매개변수 감소
  4. 시작점에서 도착점까지 가는 경로에 x원을 초과하는 간선이 없으면 더 큰 가중치가 있어도 목적지에 도달할 수 있는지 본다(최대의 최소를 찾는게 목적이기 때문) => 매개변수 증가

### 2. 코멘트

- 근거 없는 논리는 틀린 것이다(어 될 거 같은데? 절대 금물, 데이터로 확인)
- 이 문제가 골드 2밖에 안되다니, 플레급은 되보이는데 well-known 인가 보다..

## [24042 - 횡단보도](https://www.acmicpc.net/problem/24042)

### 1. 해결 핵심 아이디어

- 처음에는 주기마다 간선이 있다고 생각하려했는데 그러면 너무 경우의 수가 커진다, 그래서 생각했던게 한 노드에서 다른 노드로 건너갈 때 간선의 신호가 파랑이 될 때까지 딜레이가 있을 수 있다는 것이었고, 이것은 공차 M을 갖는 등차수열임을 인지하였다
- 그리고 현재 시간에서 갈 수 있다고해서 무조건 가버리면 최적의 정답이 아닐 수 있다, 기다렸다가 다른 정점으로 가는게 이득일 수 있다(예시 참조)
- 위 정보만으로 문제를 풀려고 했는데 도저히 어떻게 풀어야할 지 감을 못 잡았다 딜레이는 어떻게 구현할 것이며 기타 등등 좀 복잡했다
- 그래서 결국은 정답코드를 참조하였다
- 문제 풀이 과정
  1. 다음 이동할 횡단보도 신호의 시작 시간이 현재 시간보다 이전의 시간이라면 다음 신호시작 시간으로 교체하여 딜레이를 구현할 수 있다
  2. 현재 시간을 c라하고, 다음으로 갈 정점의 신호 주기는 $T_{k}$ = a(초기항) + (k-1) \* m의 수열을 이루고 있다
  3. c <= a + (k-1) \* m을 만족해야한다
  4. 식을 정리하면 c - a가 m으로 나눠떨어지면, (c - a) / m 번 째 항이 다음 신호 시작이고, 나눠떨어지지 않으면 다음 항인 (c - a) / m + 1 항이 다음 신호 시작이 된다
  5. 이 시작 시간 + 1(횡단보도 건너는 시간 1분)을 다음 정점으로 가는 비용으로 계산하여 최단 거리를 구해주면된다(딜레이 + 간선 가중치 == 이동 가중치)

### 2. 코멘트

- 오늘은 두 문제 모두 다 못 풀었다.. 이런 날도 있어야겠지? 부족한 점을 알게되서 다행이라고 생각하자

## [1162 - 도로포장](https://www.acmicpc.net/problem/1162)

### 1. 해결 핵심 아이디어

- 조합을 만들어내는 경우의 수에서(이 경우 최대 5만개의 간선 중 20개의 포장할 도로 선택)를 조합하여 경로를 만들어낸다 => 어디서 많이 보지 않았니? => 다이나믹 프로그래밍이잖아!!
- 내가 생각했던 아이디어는 다익스트라에 갇혀서 20183번 골목대장 호석 - 효율성 2문제랑 비슷하게 어떤 경로를 통해 1에서 N으로 가는 가중치가 x이하로 가능한지를 판별하는 매개변수 탐색 풀이를 생각했었다, 이 풀이를 할려면 가중치가 미리 바뀌어있어야했고, 문제가 다시 원점으로 어느 도로를 포장시킬 것인가로 돌아와야했다
- 가중치가 큰 상위 k개의 간선의 가중치를 0으로 만드는 방법은 옳지 않다, 왜냐하면 1에서 N으로 가는 경로 중에 이 상위 k개의 간선이 있을지 없을지 모르기 때문에 무조건 1에서 N으로 가는 간선을 골라서 포장을 시켜줘야한다(포장을 시키는 것이 무조건 이득임은 자명하다)

### 2. 코멘트

- 조합의 경우의 수로 뭔가 문제를 풀어야할 때는 다이나믹 프로그래밍을 고려해봅시다
- 뭘 뽑고 뭘 안뽑아서 최대 최소를 만드는 무언가?

## [1854 - K번째 최단경로 찾기](https://www.acmicpc.net/problem/1854)

### 1. 해결 핵심 아이디어

- k번째 최대, 최소 => 우선 순위 큐 사이즈 k 유지
- 처음 접근했던 방식은 경로가 발견되면 모두 저장했다가 k번째로 큰 거 찾아서 출력해주거나 찾은 경로의 개수가 k개 미만일 경우 -1을 출력해주면된다고 생각했었는데, 어찌보면 정답코드하고 결이 같은 것 같다
- 다익스트라 알고리즘을 수행하면서 갱신될 때만 큐에 넣었던 것과는 달리 나온 경로들을 모두 넣는다
- 발견되는 경로가 k개 이상되었을 경우는 제일 긴 경로를 빼버린다, 왜냐하면 작은 거(최단 거리)부터 k번째를 찾는 것이기 때문

### 2. 코멘트

- 이 문제도 푸는데 실패했다, 다익스트라 응용문제 왜 이렇게 다 어렵지?? 했더니 플레 4였구남

## [5719 - 거의 최단 경로](https://www.acmicpc.net/problem/5719)

### 1. 해결 핵심 아이디어

- 거의 최단 경로 => 최단 경로에 포함되지 않는 도로로만 이뤄진 경로 중 최단 경로
- 해결책
  - 1. 최단경로를 찾는 다익스트라 알고리즘을 한 번 수행한 뒤에, 모든 최단 경로를 찾고 저장(최단 경로가 여러개 있을 수 있음, 경로 복원 리스트이용)
  - 2. 그래프 탐색 알고리즘을 통해(BFS, DFS) 찾은 최단 거리를 구성하는 간선의 비용을 모두 INF로 갱신한다(간선을 실제로 없애는 대신, 못가게 만들어 놓으면 된다!)
  - 3. 다시 한 번 다익스트라 알고리즘을 수행하여 최단거리가 있는지 살펴본다
- 경로 복원이 왜 순방향(시작 -> 끝)에서 이뤄지지않고 역방향(끝 -> 시작)으로 이뤄지는지 다시 한 번 생각해보는 계기가 되었다
  - 순방향으로 탐색하면, 최단거리를 추적할 수 없다
  - 즉 a에서 b로 가는 간선이 최단 경로에 포함되어있다고 할 때 순방향으로 저장하면, a를 거쳐가는 다른 정점들도 포함되어있기에 어느 정점이 목적지까지 가기 위한 것인지 알 수 없게된다

### 2. 코멘트

- 패스

## [13907 - 세금](https://www.acmicpc.net/problem/13907)

### 1. 해결 핵심 아이디어

- 이 문제는 매 쿼리에 대해 다익스트라 알고리즘을 수행하면 시간초과가 난다 => O(KElogV), K와 E의 상한이 모두 3만
- 처음에 생각해봤던 아이디어는 세금을 미리 적용하여 간선을 만들고 다익스트라를 한 번 돌려서 최단 거리를 계산해보는 것이었다, 그러기엔 k의 상한때문에 너무 많은 간선이 생겨 메모리 제한을 넘기지 못한다
- 문제를 풀기위해서 관찰했어야하는 점은 세금 적용 전과 세금 적용 후의 값이 어떤 관계를 이루는지였다
- 세금을 적용한다고해서 최단 경로가 바뀌지 않는다, 이유는 각 간선에 같은 상수값이 더해지는 것이고, 다익스트라 알고리즘에서 매번 선택되는 간선은 상수 값을 더한다고 변하지 않기 때문이다
- 결과적으로 해당 경로를 이루는 간선의 개수를 x라할 때, 세금이 더해지면 dist[d] + x \* tax가 된다, 이 값을 구하기 위해선 시작점에서 각 정점에 도달했을 때 몇 개의 간선을 거쳐왔는지 기억할 필요가 있고, 이는 다이나믹 프로그래밍 기법을 적용해야함을 암시한다
- 1. 테이블 정의
  - dist[i][j] = j개의 간선을 거쳐 i번 정점에 도달하는 최단 거리
- 2. 점화식 정의
  - dist[i][j] = dist[k][j-1] + cost (if cost + dist[k][j-1] < dist[i][j])

### 2. 코멘트

- 다익스트라 알고리즘에서 간선에 무엇을 더하거나 곱해도 경로는 변하지 않는다!!
- 다익스트라 알고리즘에 대해 한층 더 깊은 이해를 할 수 있었던 문제

## [22870 - 산책 (large)](https://www.acmicpc.net/problem/22870)

### 1. 해결 핵심 아이디어

- 사전순 방문을 위한 정렬과 경로 (s, e)에 대한 다익스트라, 경로 (e, s)에 대한 다익스트라, 경로 복원 테이블을 이용해서 해결해보려했는데, 우선순위 큐에 너무 많은 데이터가 쌓여 런타임에러가 났다.. [원인](https://www.acmicpc.net/board/view/82543)

- 이를 해결할 마땅한 대안이 생각나지 않아서 정답코드를 참조하기로 했다
- 정답 코드의 방식
  - 1. 시작점을 s로 하여 다익스트라 알고리즘을 수행하고 거리 배열은 dist_s[]을 사용
  - 2. 시작점을 e로 하여 다익스트라 알고리즘을 수행하고 거리 배열은 dist_e[]을 사용
  - 3. 경로 (s, e)를 dist_s[e]를 정답에 합한다
  - 4. 이제 dist_s와 dist_e를 이용해서 최단 경로를 추적하면서 가능한 여러 개의 경로 중 사전순으로 앞선 경로를 찾을 것이다
    - 1. s에서 시작하여 s와 연결된 다음 노드를 nxt라 하고 s에서 nxt로 가는 비용을 cost라 할 때, dist_s[s] + cost + dist_e[nxt] = dist_s[e]라면, nxt는 최단 경로에 포함된 정점이다, 중간에서 만나는 기법인데, 양방향 간선이므로 s에서 e로 가는 방향의 최단 경로와 e에서 s로 가는 최단 경로는 같기때문이다, 그리고 dist_s[nxt]대신 dist_s[s] + cost를 하는 이유는 dist_s[nxt]는 중간에 어느 정점을 거쳤을 수도 있기 때문이다
    - 2. nxt가 여러개라면 더 작은 번호를 갖는 정점이 우선되야하므로 발견될 경우 값을 갱신해준다, mn에 저장
    - 3. s와 연결된 모든 정점을 돌고 s를 mn으로 교체하고 s가 e가 될 때까지 4번 과정을 반복한다
  - 5. 4번 과정에서 발견된 노드들은 e에서 s로 돌아오는 최단 경로에 사용되면 안되므로 다익스트라 알고리즘에 이를 반영해준다

### 2. 코멘트

- 실패한 코드 첨부, 나중에 기회되면 이 방식으로 풀어봐야지

```cpp

    #include <bits/stdc++.h>

  using namespace std;

  typedef long long ll;

  #define pil pair<int, ll>
  #define tlii tuple<ll, int, int>

  const int range = 200'005;
  const ll INF = 0x7f7f7f7f7f7f;

  class cmp {
  public:
    bool operator()(tlii a, tlii b) {
      // 일반적인 sort와는 다르게 순서가 거꾸로감
      auto [cost_a, nxt_a, prev_a] = a;
      auto [cost_b, nxt_b, prev_b] = b;
      if (cost_a == cost_b) return nxt_a < nxt_b;
      return cost_a > cost_b;
    }
  };

  int n, m, s, e;

  vector<pil> adj[range];
  int p[range];
  ll dist[range];
  int vis[range];

  ll dijkstra(int st, int en) {
    priority_queue<tlii, vector<tlii>, cmp> pq;
    fill(dist, dist + n + 1, INF);
    dist[st] = 0;
    pq.push({0, st, 0});
    while (!pq.empty()) {
      auto [cur_dist, cur, prev] = pq.top();
      pq.pop();
      if (dist[cur] != cur_dist) continue;
      for (auto [nxt, cost] : adj[cur]) {
        if (nxt == prev) continue;
        if (nxt != s && nxt != e && vis[nxt]) continue;
        ll nxt_dist = dist[cur] + cost;
        if (nxt_dist <= dist[nxt]) {
          dist[nxt] = nxt_dist;
          p[nxt] = cur;
          pq.push({nxt_dist, nxt, cur});
        }
      }
    }
    return dist[en];
  }

  int main(void) {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
      int u, v, cost;
      cin >> u >> v >> cost;
      adj[u].push_back({v, cost});
      adj[v].push_back({u, cost});
    }
    for (int i = 1; i <= n; ++i) sort(adj[i].begin(), adj[i].end());
    cin >> s >> e;
    ll ans = 0;
    ans += dijkstra(s, e);
    int cur = e;
    while (cur != 0) {
      vis[cur] = true;
      cur = p[cur];
    }
    ans += dijkstra(e, s);
    cout << ans;
    return 0;
  }

```
