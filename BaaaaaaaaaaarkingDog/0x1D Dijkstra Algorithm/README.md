# 0x1D 다익스트라 알고리즘

## 0x00 알고리즘 설명

- 방향 그래프 또는 무방향 그래프에서 하나의 시작점으로부터 다른 모든 정점까지의 최단 거리를 구하는 알고리즘
- 음수 가중치를 갖는 간선이 있을 때는 사용할 수 없다
  - 플로이드 알고리즘은 음수 가중치를 갖는 간선이 있는 것은 상관없는데, 음수인 사이클이 있을 때만 문제였음
  - 음수 가중치를 갖는 간선이 있는 경우 하나의 시작점으로부터 다른 모든 정점까지의 최단 거리를 구할 때는 벨만 포드 알고리즘을 사용해야함
- A \* 알고리즘은 네비게이션 처럼 정확한 최단 거리를 내지 않아도 되고, 정점이 너무 많아서 현실적으로 다익스트라 알고리즘을 사용하기 어려울 때 근사적으로 사용할 수 있는 방법

## 0x01 구현

- 매 단계마다 도달할 수 있는 정점 중에서 시작점으로부터의 거리가 가장 가까운 정점을 구해서 그 거리를 확정하는 방식으로 동작
- 그림으로 보는 과정

  - 노란 테두리는 거리가 확정된 정점

    ![1](https://user-images.githubusercontent.com/48282185/180637502-90004681-bbef-4305-ae51-208152d46747.png)

  - 1번 정점을 시작점으로 설정하고 초기값을 설정
  - 1번 정점 즉, 자기 자신으로의 거리는 0으로 확정

    ![2](https://user-images.githubusercontent.com/48282185/180637501-9e3aa35c-6315-43b5-9f67-9459086fd32d.png)

  - 1번 정점에서 갈 수 있는 정점들은 2, 3, 4번 정점이고 이 중 가장 가까운 정점은 3번 정점이므로, 3번 정점까지의 거리를 2로 확정 짓는다

    - 1 → 3, 가중치 2 ⇒ 선택
    - 1 → 2, 가중치 3
    - 1 → 4, 가중치 5

    ![3](https://user-images.githubusercontent.com/48282185/180637500-075cde64-9ad9-4a12-ac91-500e5a9c7436.png)

  - 1번 정점과 3번 정점에서 갈 수 있는 정점은 2, 4번 정점이고, 이들 중 시작점에서 가까운 정점은 2번 정점이고, 1번 정점에서 2번 정점까지의 최단 거리를 3으로 확정짓는다

    - 1 → 2, 가중치 3 ⇒ 선택
    - 1 → 3 → 4, 가중치 4
    - 1 → 4, 가중치 5

    ![4](https://user-images.githubusercontent.com/48282185/180637499-2b6e22c8-f613-481a-a29f-261eb72cbb4c.png)

  - 1, 2, 3번 정점에서 갈 수 있는 정점은 4, 5번 정점이고, 이들 중 시작점에서 가까운 정점은 4번 정점이고, 1번 정점에서 4번 정점까지의 최단 거리를 4로 확정짓는다

    - 1 → 3 → 4, 가중치 4 ⇒ 선택
    - 1 → 4, 가중치 5
    - 1 → 2 → 5, 가중치 11

    ![5](https://user-images.githubusercontent.com/48282185/180637498-20b40306-ebcd-4b3f-9071-09a842ddae77.png)

  - 1, 2, 3, 4번 정점에서 갈 수 있는 정점은 5번 정점 하나 뿐이고, 선택의 여지가 없어 시작점에서 가장 가까운 정점은 5번 정점이되고, 1번 정점에서 5번 정점까지의 최단 거리를 10으로 확정짓는다

    - 1 → 3 → 4 → 5, 가중치 10 ⇒ 선택
    - 1 → 2 → 5, 가중치 11
    - 1 → 4 → 5, 가중치 11
    - 1 → 2 → 3 → 4 → 5, 가중치 13

    ![6](https://user-images.githubusercontent.com/48282185/180637496-3710351c-13ce-4e7e-b537-6d46a049efa2.png)

  - 1, 2, 3, 4, 5번 정점에서 갈 수 있는 정점은 6번 정점 하나 뿐이고, 선택의 여지가 없어 시작점에서 가장 가까운 정점은 6번 정점이 되고, 1번 정점에서 6번 정점까지의 최단 거리를 11로 확정짓는다
    - 1 → 3 → 4 → 5 → 6, 가중치 11 ⇒ 선택
    - 1 → 2 → 5 → 6, 가중치 12
    - 1 → 4 → 5 → 6, 가중치 12
    - 1 → 2 → 3 → 4 → 5 → 6, 가중치 14
  - 시작점으로 부터 모든 정점까지의 거리를 모두 구했으므로 알고리즘 종료

- 구현

  - 위 과정을 곧이 곧대로 구현하면 최악의 경우 매 단계마다 모든 간선을 확인해야하므로 O(VE)가 되는데, 최단거리를 미리 계산해 놓는다면 O$V^2$ + E)가 되고, 일반적으로 V << E이기 때문에 후자가 더 효율적인 방법이다
  - 그러면 최단 거리를 미리 어떻게 구해놓느냐?

    ![7](https://user-images.githubusercontent.com/48282185/180637494-1567f7c8-4380-434b-ae91-a387506b932e.png)

    - 최단 거리 테이블을 d라 할 때, d[2] ~ d[6]의 최솟값을 보면 현재 1번 정점에서 최단 거리로 갈 수 있는 정점을 알 수 있다, 위 경우에는 3번 정점이고, 최단 거리를 확정한다

    ![8](https://user-images.githubusercontent.com/48282185/180637492-883d506d-8f85-4ad3-96d1-2ce0bc00efe8.png)

    - 이제 1번 정점에서 나가는 간선들은 모두 확인했기 때문에 3번 정점에서 나가는 간선만 확인하면 되고, 3번 정점에서는 4번 정점으로 밖에 갈 수 없기 때문에 4번 정점까지의 거리를 보는데 원래있던 5보다 새로 갱신되는 값인 4가 더 작으므로 거리를 갱신해주고, 최단 거리를 확정한다
    - 이렇게 매 단계 마다 확정 되는 정점에서 뻗어나가는 정점만 확인해주면되고, 최단 거리가 갱신될 수 있는 상황일 경우 갱신해주면된다

- 정당성
  - 매 단계 거리가 아직 확정되지 않은 정점들 중에서 가장 가까운 정점을 찾아 거리를 확정한다 ⇒ 그리디 알고리즘
  - 그리디 알고리즘이기에 이 방법이 정말 정답인지 증명을 해야함
  - 귀류법으로 간단히 증명, A에서 B로 가는게 최단이 아니고, 중간의 어떤 정점 u을 거쳐가야 최단이라고, 가정하자, w(u, v)를 u에서 v까지 가는데 드는 가중치라고 정의한다, 그러면 w(A, B) ≥ w(A, u) + w(u, B)이고, w(A, B) > w(A, u)이기 때문에 B가 뽑히는게아니라 u가 뽑혔어야된다 따라서 모순이다(단 w(u, B)가 음수였다면 가능한 경우임, 그래서 다익스트라 알고리즘에서는 음수 가중치 간선이 있으면 안됨)
- 우선순위 큐를 이용한 구현

  1. 우선순위 큐에 (0, 시작점)을 추가
  2. 우선순위 큐에서 거리가 가장 작은 원소를 선택, 해당 거리가 최단 거리 테이블에 있는 값과 다를 경우 넘어감
  3. 원소가 가리키는 정점을 v라고 할 때, v와 이웃한 정점들에 대해 최단 거리 테이블 값보다 v를 거쳐가는 것이 더 작은 값을 가질 경우 최단 거리 테이블의 값을 갱신하고 우선순위 큐에 (거리, 이웃 정점)을 추가
  4. 우선순위 큐가 빌 때 까지 2, 3번 과정을 반복

  - 거리가 확정되었는지 별도로 관리할 필요가 없다
  - 우선순위 큐에 추가될 수 있는 원소의 수는 최대 E개이고, 이들의 삽입 삭제가 일어나므로 → O(ElogE)
  - 그림으로 보자

    - 시작점 1번 정점이고, 자기 자신으로 거리를 0으로 설정

      ![9](https://user-images.githubusercontent.com/48282185/180637491-7d305536-3793-4f74-a430-8087623d47eb.png)

    - 초기값을 위와 같이 설정하고 시작

      ![10](https://user-images.githubusercontent.com/48282185/180637489-add884ac-9572-46d4-907c-bdbaba8853c1.png)

    - 1번 정점의 이웃 정점들을 확인한다, 최단 거리 테이블에 있는 값보다 1번 정점에서 곧바로 가는 것이 더 비용이 적으므로 최단 거리 테이블을 갱신하고, 우선순위 큐에 간선들을 넣는다

      ![11](https://user-images.githubusercontent.com/48282185/180637488-5578367c-3e38-48cb-8584-dd25a53b5aec.png)

    - 우선순위 큐가 비지 않았기에 다음 단계를 진행한다
    - 우선순위 큐에서 (1, 3) 간선이 pop되고, 최단 거리 테이블에 있는 값과 우선순위 큐에서 나온 간선의 가중치가 같은지 확인한다, 같으므로 계속 진행한다
    - 3번 정점에서 갈 수 있는 정점은 4번 정점이고, 현재 1번 정점에서 4번 정점으로 바로가는 비용 5보다 3번 정점을 거쳐서 가는 비용 4가 더 낮으므로, 최단 거리 테이블을 갱신하고, (3, 4) 간선을 우선순위 큐에 넣는다

      ![12](https://user-images.githubusercontent.com/48282185/180637486-ffd691a5-d43e-468b-8dc2-aa2b62226d24.png)

    - 우선순위 큐가 비지 않았기에 다음 단계를 진행한다
    - 우선순위 큐에서 (1, 2) 간선이 pop되고, 최단 거리 테이블에 있는 값과 우선순위 큐에서 나온 간선의 가중치가 같은지 확인한다, 같으므로 계속 진행한다
    - 2번 정점에서 갈 수 있는 정점들은 3, 5번 정점이고, 최단 거리 테이블을 참조하여 갱신되는지 살펴본다, 3번 정점의 경우 다익스트라 알고리즘에서는 원래 최단 거리 테이블에 한 번 쓰이면 확정되는데, 우선순위 큐를 이용하는 방법에서는 특정 정점으로의 거리 확정 여부를 저장하지 않기 때문에 확인하는 절차가 이뤄진다(확인은 하지만 이미 확정된 것임), 3번 정점으로의 거리는 갱신되지 않고, 5번 정점으로의 거리는 갱신되므로, (2, 5) 간선을 우선순위 큐에 삽입한다

      ![13](https://user-images.githubusercontent.com/48282185/180637485-8653bfd7-577d-448d-be7a-9117c1b4179e.png)

    - 우선순위 큐가 비지 않았기에 다음 단계를 진행한다
    - 우선순위 큐에서 (3, 4) 간선이 pop되고, 최단 거리 테이블에 있는 값과 우선순위 큐에서 나온 간선의 가중치가 같은지 확인한다, 같으므로 계속 진행한다
    - 4번 정점에서 갈 수 있는 정점은 5번 정점이고, 최단 거리 테이블을 참조하여 갱신되는지 살펴본다, 갱신가능하므로, 최단 거리 테이블을 갱신하고, (4, 5) 간선을 우선순위 큐에 삽입한다

      ![14](https://user-images.githubusercontent.com/48282185/180637484-85888d37-bb5c-4137-8ab4-e181476326a6.png)

    - 우선순위 큐가 비지 않았기에 다음 단계를 진행한다
    - 우선순위 큐에서 (1, 4) 간선이 pop되고, 최단 거리 테이블에 있는 값과 우선순위 큐에서 나온 간선의 가중치가 같은지 확인한다, 값이 다르다, 이전 과정에서 삽입했던 간선인데, 최단 경로에 포함되지 않는 간선이므로 건너 뛴다

      ![15](https://user-images.githubusercontent.com/48282185/180637483-f3c4d1b9-f519-4fd9-b0ba-99c61fb82bb6.png)

    - 우선순위 큐가 비지 않았기에 다음 단계를 진행한다
    - 우선순위 큐에서 (4, 5) 간선이 pop되고, 최단 거리 테이블에 있는 값과 우선순위 큐에서 나온 간선의 가중치가 같은지 확인한다, 같으므로 계속 진행한다
    - 5번 정점에서 갈 수 있는 정점은 6번 정점이고, 단 거리 테이블을 참조하여 갱신되는지 살펴본다, 갱신가능하므로, 최단 거리 테이블을 갱신하고, (5, 6) 간선을 우선순위 큐에 삽입한다

      ![16](https://user-images.githubusercontent.com/48282185/180637481-6797105b-e28e-43d1-9770-a00d2f3442d0.png)

    - 우선순위 큐가 비지 않았기에 다음 단계를 진행한다
    - 우선순위 큐에서 (2, 5) 간선이 pop되고, 최단 거리 테이블에 있는 값과 우선순위 큐에서 나온 간선의 가중치가 같은지 확인한다, 값이 다르다, 이전 과정에서 삽입했던 간선인데, 최단 경로에 포함되지 않는 간선이므로 건너 뛴다

      ![17](https://user-images.githubusercontent.com/48282185/180637479-5b2d1c75-b967-4cfe-807d-edf54a013d0e.png)

    - 6번 정점에서 갈 수 있는 정점은 없고, 우선순위 큐가 비었으므로 알고리즘을 종료한다

  - 1753 - 최단 경로

    - 문제에서 서로 다른 정점 사이의 간선이 여러 개 일 수 있다는 조건이 있는데, 어차피 큐에 들어가도 제일 가중치가 작은게 나오기 때문에 따로 처리하지 않아도 됨

      ```cpp
      #include <bits/stdc++.h>

      using namespace std;

      #define cost first
      #define nxt second

      vector<pair<int, int>> adj[20005];

      const int INF = 0x3f3f3f3f;

      int main(void) {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        int v, e, start;
        cin >> v >> e >> start;
        for (int i = 0; i < e; ++i) {
          int from, to, cost;
          cin >> from >> to >> cost;
          adj[from].push_back({cost, to});
        }

        int dist[v + 1];
        priority_queue<pair<int, int>, vector<pair<int, int>>,
                       greater<pair<int, int>>>
            pq;
        fill(dist + 1, dist + v + 1, INF);
        pq.push({0, start});
        dist[start] = 0;
        while (!pq.empty()) {
          auto cur = pq.top();
          pq.pop();
          if (dist[cur.nxt] != cur.cost) continue;
          for (auto edge : adj[cur.nxt]) {
            if (dist[edge.nxt] > dist[cur.nxt] + edge.cost) {
              dist[edge.nxt] = dist[cur.nxt] + edge.cost;
              pq.push({dist[edge.nxt], edge.nxt});
            }
          }
        }
        for (int i = 1; i <= v; ++i) {
          if (dist[i] == INF)
            cout << "INF";
          else
            cout << dist[i];
          cout << '\n';
        }
        return 0;
      }
      ```

## 0x02 최소 신장 트리 vs 최단 거리

- 최소 신장 트리

  ![18](https://user-images.githubusercontent.com/48282185/180637476-478fe421-ca32-42a6-9a6b-fee26574261b.png)

- 최단 거리

  ![19](https://user-images.githubusercontent.com/48282185/180637471-54422066-9ea3-4867-8a7f-0f06a10424b6.png)

- 1번 정점에서 3번 정점으로 갈 때, 최소 신장 트리에서는 가중치 합이 3이지만 다익스트라에서는 2이다
- 모든 노드를 최소 비용으로 이어주는게 최소 신장 트리
- 한 노드에서 다른 노드로 가는 경로를 구하는 것은 최단 거리
- 최소 신장 트리에서는 임의의 두 노드 사이의 거리가 최단임을 보장 할 수 없다 but, 인접 정점 간에는 최단 거리임을 보장 할 수 있음

## 0x03 경로 복원 방법

- 시작점에서 현재 위치까지 올 때 직전에 어디를 방문했는지 기록하는 테이블 pre를 둔다
- 최단 거리 테이블 갱신할 때 pre도 같이 갱신해주면 됨
- 11779 - 최소비용 구하기 2

  - 하나의 정점에서 다른 모든 정점까지의 최단 거리를 구하는 경우뿐 만 아니라, 하나의 정점에서 다른 하나의 정점으로의 최단 거리를 구할 때도 다익스트라를 사용할 수 있다

    ```cpp
    #include <bits/stdc++.h>

    using namespace std;

    #define cost first
    #define node second

    vector<pair<int, int>> adj[1005];

    const int INF = 10 + 1e9;

    int main(void) {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      int v, e, st, en;
      cin >> v >> e;
      while (e--) {
        int from, to, cost;
        cin >> from >> to >> cost;
        adj[from].push_back({cost, to});
      }
      cin >> st >> en;
      priority_queue<pair<int, int>, vector<pair<int, int>>,
                     greater<pair<int, int>>>
          pq;
      int dist[v + 1];
      int pre[v + 1];
      fill(dist + 1, dist + v + 1, INF);
      dist[st] = 0;
      pre[st] = 0;
      pre[0] = -1;
      pq.push({0, st});
      while (!pq.empty()) {
        auto cur = pq.top();
        pq.pop();
        if (dist[cur.node] != cur.cost) continue;
        for (auto edge : adj[cur.node]) {
          if (dist[edge.node] > dist[cur.node] + edge.cost) {
            dist[edge.node] = dist[cur.node] + edge.cost;
            pre[edge.node] = cur.node;
            pq.push({dist[edge.node], edge.node});
          }
        }
      }
      cout << dist[en] << '\n';
      stack<int> path;
      int cur = en;
      while (pre[cur] != -1) {
        path.push(cur);
        cur = pre[cur];
      }

      cout << (int)path.size() << '\n';
      while (!path.empty()) {
        cout << path.top() << ' ';
        path.pop();
      }
      return 0;
    }
    ```

> 바킹독님 유튜브 강의를 참고하여 제작하였습니다.
