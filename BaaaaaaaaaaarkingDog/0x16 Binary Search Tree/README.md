# 0x16 이진 검색 트리

<!--ts-->

- [0x16 이진 검색 트리](#0x16-이진-검색-트리)
  - [0x00 정의와 성질](#0x00-정의와-성질)
  - [0x01 기능](#0x01-기능)
  - [0x02 자가 균형 트리](#0x02-자가-균형-트리)
  - [0x03 STL](#0x03-stl)
  - [0x04 연습 문제](#0x04-연습-문제)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 7월 16일 토요일 05시 16분 45초 KST -->

<!--te-->

## 0x00 정의와 성질

- 이진트리
  - 각 노드의 자식이 두 개 이하인 트리
- 이진 검색 트리
  - 왼쪽 서브트리의 모든 값은 부모의 값보다 작고 오른쪽 서브트리의 모든 값은 부모의 값보다 큰 이진트리
- insert, erase, find, update를 모두 O(logN)에 처리할 수 있다
  - erase, find, update가 빈번하다면 이진 검색 트리를 활용할 수 있다
  - cf) 해시는 충돌만 안난다면 모든 연산이 O(1)에 일어난다
- 원소가 크기 순으로 정렬된다는 점
  - 연산들이 빈번하면서 원소의 대소와 관련된 성질이 필요할 경우에 이진 검색 트리의 사용을 고려해볼 수 있다

## 0x01 기능

- insert
  - 루트를 제외하고 삽입할 원소는 대소 비교를 통해 삽입될 위치를 정해줘야한다
- find
  - 루트부터 시작해서 대소 비교를 통해 찾아낼 원소의 위치를 파악함
- erase

  - 자식이 없는 경우 그냥 지우면 됨
  - 자식이 한 개인 노드는 지워지는 노드의 위치에 자식을 넣어주고 지운다
  - 자식이 두 개인 노드는 지워지는 노드보다 크면서 가장 작은 노드(오른쪽 서브트리의 가장 왼쪽 노드)로 넣고 지우거나 지워지는 노드보다 작으면서 가장 큰 노드(왼쪽 서브트리의 가장 오른쪽 노드)를 넣고 지우는 방법을 통해 이진 검색 트리의 특성(부모의 왼쪽에는 작은 값이 오른쪽에는 큰 값이 들어가는)을 만족해야한다

    ![1](https://user-images.githubusercontent.com/48282185/179304121-ba85aafd-1247-4560-8d28-fcac274c9c27.png)

    - 32가 올라갔으니 32의 자식인 34도 자리가 바뀜
    - 32의 자식이 두 개인 경우는 있을 수가 없다, 왜냐면 만약 있었다면 그 노드가 25랑 교체되야했기 때문에 이런 상황은 발생할 수 없다
    - 15가 25를 대신해도 문제 없음

## 0x02 자가 균형 트리

- 만약 삽입될 원소들이 크기 순으로 들어오는 경우라면, 트리가 한 쪽으로 편향될 수 있다
- insert, erase, find, update 모두 O(logN)에 해결하기 위해 이진 검색 트리를 쓰는건데, 트리가 편향될 경우 시간복잡도가 O(N)이 되어 사용하는 의미가 없어진다

  ![2](https://user-images.githubusercontent.com/48282185/179304108-513e419b-ef68-4a1a-84ff-ea0e0a2661e1.png)

- 이런 상황을 막기 위해 트리를 균형잡히게 만들어줘야하고, 스스로 균형을 잡는 트리 구조를 자가 균형 트리라고 부르고 대표적으로 AVL 트리, Red Black 트리가 있다
- AVL트리는 구현이 간단한 장점이 있고, Red Black 트리는 성능이 더 좋다는 장점이 있어서 STL의 이진 검색 트리는 Red Black 트리로 구현이 돼있다
- 편향성을 해소해줌으로서 모든 연산이 O(logN) 보장

## 0x03 STL

- set

  - insert, erase, find, lower_bound, next, prev 모두 O(logN)
  - advance(iterator, N)는 자체로 O(NlogN)이다 → 한 칸 움직일 때 O(logN)이므로
  - 원소의 존재여부를 판단하며 정렬이 필요한 경우 set을 사용한다
  - 중복없는 저장을 원할 때도 사용할 수 있다

  ```cpp
  void set_example(){
    set<int> s;
    s.insert(-10); s.insert(100); s.insert(15); // {-10, 15, 100}
    s.insert(-10); // {-10, 15, 100}
    cout << s.erase(100) << '\n'; // {-10, 15}, 1
    cout << s.erase(20) << '\n'; // {-10, 15}, 0
    if(s.find(15) != s.end()) cout << "15 in s\n";
    else cout << "15 not in s\n";
    cout << s.size() << '\n'; // 2
    cout << s.count(50) << '\n'; // 0
    for(auto e : s) cout << e << ' ';
    cout << '\n';
    s.insert(-40); // {-40, -10, 15}
    set<int>::iterator it1 = s.begin(); // {-40(<-it1), -10, 15}
    it1++; // {-40, -10(<-it1), 15}
    auto it2 = prev(it1); // {-40(<-it2), -10, 15}
    it2 = next(it1); // {-40, -10, 15(<-it2)}
    advance(it2, -2); // {-40(<-it2), -10, 15}
    auto it3 = s.lower_bound(-20); // {-40, -10(<-it3), 15}
    auto it4 = s.find(15); // {-40, -10, 15(<-it4)}
    cout << *it1 << '\n'; // -10
    cout << *it2 << '\n'; // -40
    cout << *it3 << '\n'; // -10
    cout << *it4 << '\n'; // 15
  }
  ```

- multiset

  - 원소의 중복이 가능
  - erase의 경우 원소가 중복됬다면 해당하는 모든 원소가 삭제됨
  - find의 경우 표준에서 보면 중복됬다면 아무거나 반환한다고 되어있음 → 첫 번째 등장하는 원소를 가져와야되는 상황이면 lower_bound를 사용하자
  - end()는 끝을 가리키는 게 아니라 끝 + 1을 가리키기 때문에 값 참조하면 런타임에러 발생하니 주의하자

  ```cpp
  void multiset_example(){
    multiset<int> ms;
    // {-10, 15, 100}
    ms.insert(-10); ms.insert(100); ms.insert(15); // {-10, -10, 15, 15, 100}
    ms.insert(-10); ms.insert(15);
    cout << ms.size() << '\n'; // 5
    for(auto e : ms) cout << e << ' ';
    cout << '\n';
    cout << ms.erase(15) << '\n'; // {-10, -10, 100}, 2
    ms.erase(ms.find(-10)); // {-10, 100}
    ms.insert(100); // {-10, 100, 100}
    cout << ms.count(100) << '\n'; // 2
    auto it1 = ms.begin(); // {-10(<-it1), 100, 100}
    auto it2 = ms.upper_bound(100); // {-10, 100, 100} (<-it2)
    auto it3 = ms.find(100); // {-10, 100(<-it3), 100}
    cout << *it1 << '\n'; // -10
    cout << (it2 == ms.end()) << '\n'; // 1
    cout << *it3 << '\n'; // 100
  }
  ```

- map

  - pair형태로 저장됨

  ```cpp
  void map_example(){
    map<string, int> m;
    m["hi"] = 123;
    m["bkd"] = 1000;
    m["gogo"] = 165; // ("bkd", 1000), ("gogo", 165), ("hi", 123)
    cout << m.size() << '\n'; // 3
    m["hi"] = -7;  // ("bkd", 1000), ("gogo", 165), ("hi", -7)
    if(m.find("hi") != m.end()) cout << "hi in m\n";
    else cout << "hi not in m\n";
    m.erase("bkd"); // ("gogo", 165), ("hi", 123)
    for(auto e : m)
      cout << e.first << ' ' << e.second << '\n';
    auto it1 = m.find("gogo");
    cout << it1->first << ' ' << it1->second << '\n'; // gogo 165
  }
  ```

- set, map의 성질을 필요로하면서 특히 lower_bound, prev, next 이런 걸 사용해야만 풀리는 문제라면 꼭 STL set, map으로 해결하고 그냥 key로 value를 찾거나 원소의 삽입 / 검색 / 삭제만 빠르게 처리를 해주어야 할 경우라면 STL unordered_set, unordered_map을 사용해도 무방
- 평균적으로는 해시(unordered 시리즈)가 이진 검색 트리보다 빠르지만 충돌이 계속 일어난다면 O(N)에 수렴하기 때문에 O(logN)이 보장된 이진 검색 트리를 사용하는 경우가 많다
- 이진 검색 트리는 O(logN) 중 에서도 느린 편에 속하는데, 균형 잡는 작업이나 새로운 노드를 동적 할당하는 다소 무거운 작업이 동반되기 때문이다 그래서 N이 백만일 때, N개의 데이터에서 연산을 N번 수행한다고 할 때 이진 탐색은 가볍게 1초 제한 내로 들어오지만 이진 검색 트리는 간당간당할 수 있다, 이런 상황에서 내가 생각한 풀이가 O(NlogN)이면 어떻게 해야할까?
  - unordered_set, unordered_map으로 바꿔본다, 테스트 케이스가 해시 충돌을 유도하게끔 작성되었다면 이도 통하지 않는 방법이다
  - 위 방법이 안 통한다면, 이분 탐색이나 정렬이나 배열의 인덱스를 가지고 다른 풀이를 생각해봐야한다

## 0x04 연습 문제

- 7662 - 이중 우선순위 큐

  - 중복 허용되니 multimap사용
  - 정렬돼있다는 특징만 잘쓰면 해결 가능

- 1202 - 보석 도둑
  - 그리디 풀이를 쉽게 떠올릴 수 있는데 이게 맞는지 증명을 해봐야한다
    - 내가 생각한 풀이는 제일 가격이 높은 보석 순으로 가방에 담되, 이 가방을 선택할 때는 보석의 무게보다 크면서 제일 작은 정수를 선택하자이다
    - 일단 첫 번째로 제일 가격이 높은 순으로 담는게 최적의 답인지 부터 따져봐야하고, 두 번째는 가방을 선택할 때 보석의 무게보다 크면서 제일 작은 정수를 선택하는게 맞는지 봐야한다
    - 가방의 무게부터 보자
      - 귀류법으로 ‘가장 가격이 높은 보석 x를 해당 보석을 담을 수 있는 가방 중 최대 무게가 A보다 큰 가방 B를 이용해 보석을 담는게 더 이득인 경우가 있는가?’ 를 증명해보자
      - A말고 가방 B를 이용해서 더 이득인 경우가 있다고 하자. 만약 그 경우 가방 A에 다른 보석 y가 있다면 가방 A와 가방 B의 내용물을 바꿔도 제한 조건에 위배되지않는다, 가방 A에 다른 보석이 없다면 보석 x를 가방 B에서 A로 옮겨도 제한 조건에 위배되지 않는다. 즉, 가방 B에 x를 담는게 가방 A에 x를 담는 것보다 이득인 경우는 없다
      - 귀류법은 모순을 보이거나 그런 경우가 존재하지 않음을 보이면 된다
    - 제일 가격이 높은 순으로 담는게 최적인가를 보자
      - 귀류법으로 ‘가장 가격이 높은 보석을 담을 수 있는 가방 중 최대 무게가 가장 작은 A가 존재하는데도 불구하고 가방에 넣지 않는게 최적의 답이 될 수 있는가?’를 증명해보자
      - 가장 가격이 높은 보석 x를 담지 않고 최적의 해가 됬다고 가정하자 A에는 다른 보석 y가 담겼을 경우, x와 y를 교체하는 것이 이득이다. 또 A가 비었다고 가정하면 A에 x를 담을 수 있으므로 최적의 답이 아니다. 따라서 가장 가격이 높은 보석을 담을 수 있는 상황이라면 담는 게 최적이다
    - 그러면 왜 이 문제가 이진 검색 트리로 풀면 좋은지를 봐야하는데 가방이 선택됬다는 것은 후보지에서 제외시켜야 하고, 제거를 해야한다는 뜻이다. 제일 최적의 가방을 이진탐색으로 찾을 수 있다고 해도 제거를 해야하니 find도 O(logN), erase도 O(logN)인 이진 검색 트리를 사용하면 좋다
  - 정리
    - N이 커서 O($N^2$)은 통과가 안될 상황이고 원소의 대소 관계가 필요한데 삽입 혹은 삭제가 빈번한 경우
    - 꼭 대소 관계가 아니더라도 그냥 key로 value를 빠르게 찾거나 원소의 삽입 / 검색 / 삭제만 빠르게 처리를 해주어야 할 경우에도 고려해볼 옵션

> 바킹독님 유튜브 강의를 참고하여 제작하였습니다.
