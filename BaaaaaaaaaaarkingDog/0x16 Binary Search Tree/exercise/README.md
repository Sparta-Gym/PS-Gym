# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/7662" rel="nofollow">7662 - 이중 우선순위 큐</a>](#7662---이중-우선순위-큐)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 코멘트](#2-코멘트)
  - [<a href="https://www.acmicpc.net/problem/1202" rel="nofollow">1202 - 보석 도둑</a>](#1202---보석-도둑)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 코멘트](#2-코멘트-1)
  - [<a href="https://www.acmicpc.net/problem/21939" rel="nofollow">21939 - 문제 추천 시스템 Version 1</a>](#21939---문제-추천-시스템-version-1)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 코멘트](#2-코멘트-2)
  - [<a href="https://www.acmicpc.net/problem/23326" rel="nofollow">23326 - 홍익 투어리스트</a>](#23326---홍익-투어리스트)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 코멘트](#2-코멘트-3)
  - [<a href="https://www.acmicpc.net/problem/21944" rel="nofollow">21944 - 문제 추천 시스템 Version 2</a>](#21944---문제-추천-시스템-version-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 코멘트](#2-코멘트-4)
  - [<a href="https://www.acmicpc.net/problem/19700" rel="nofollow">19700 - 수업</a>](#19700---수업)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 코멘트](#2-코멘트-5)
  - [<a href="https://www.acmicpc.net/problem/1539" rel="nofollow">1539 - 이진 검색 트리</a>](#1539---이진-검색-트리)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 코멘트](#2-코멘트-6)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 11월  7일 월요일 17시 14분 43초 KST -->

<!--te-->

## [7662 - 이중 우선순위 큐](https://www.acmicpc.net/problem/7662)

### 1. 해결 핵심 아이디어

- 중복 허용되니 multimap을 사용하자
- 삽입, 삭제가 빈번하고 최대값, 최소값을 매번 찾아주는데 BST는 정렬돼있으므로 begin()이 최소값을, prev(end())가 최대값을 가리키기때문에 삭제도 간단하다

### 2. 코멘트

- STL warm up용 문제

## [1202 - 보석 도둑](https://www.acmicpc.net/problem/1202)

### 1. 해결 핵심 아이디어

- 그리디 풀이를 쉽게 떠올릴 수 있는데 이게 맞는지 증명을 해봐야한다
  - 내가 생각한 풀이는 제일 가격이 높은 보석 순으로 가방에 담되, 이 가방을 선택할 때는 보석의 무게보다 크면서 제일 작은 정수를 선택하자이다
  - 일단 첫 번째로 제일 가격이 높은 순으로 담는게 최적의 답인지 부터 따져봐야하고, 두 번째는 가방을 선택할 때 보석의 무게보다 크면서 제일 작은 정수를 선택하는게 맞는지 봐야한다
  - 가방의 무게부터 보자
    - 귀류법으로 ‘가장 가격이 높은 보석 x를 해당 보석을 담을 수 있는 가방 중 최대 무게가 A보다 큰 가방 B를 이용해 보석을 담는게 더 이득인 경우가 있는가?’ 를 증명해보자
      - A말고 가방 B를 이용해서 더 이득인 경우가 있다고 하자. 만약 그 경우 가방 A에 다른 보석 y가 있다면 가방 A와 가방 B의 내용물을 바꿔도 제한 조건에 위배되지않는다, 가방 A에 다른 보석이 없다면 보석 x를 가방 B에서 A로 옮겨도 제한 조건에 위배되지 않는다. 즉, 가방 B에 x를 담는게 가방 A에 x를 담는 것보다 이득인 경우는 없다
    - 귀류법은 모순을 보이거나 그런 경우가 존재하지 않음을 보이면 된다
  - 제일 가격이 높은 순으로 담는게 최적인가를 보자
    - 귀류법으로 ‘가장 가격이 높은 보석을 담을 수 있는 가방 중 최대 무게가 가장 작은 A가 존재하는데도 불구하고 가방에 넣지 않는게 최적의 답이 될 수 있는가?’를 증명해보자
      - 가장 가격이 높은 보석 x를 담지 않고 최적의 해가 됬다고 가정하자 A에는 다른 보석 y가 담겼을 경우, x와 y를 교체하는 것이 이득이다. 또 A가 비었다고 가정하면 A에 x를 담을 수 있으므로 최적의 답이 아니다. 따라서 가장 가격이 높은 보석을 담을 수 있는 상황이라면 담는 게 최적이다
  - 그러면 왜 이 문제가 이진 검색 트리로 풀면 좋은지를 봐야하는데 가방이 선택됬다는 것은 후보지에서 제외시켜야 하고, 제거를 해야한다는 뜻이다. 제일 최적의 가방을 이진탐색으로 찾을 수 있다고 해도 제거를 해야하니 find도 O(logN), erase도 O(logN)인 이진 검색 트리를 사용하면 좋다

### 2. 코멘트

- N이 커서 O($N^2$)은 통과가 안될 상황이고 원소의 대소 관계가 필요한데 삽입 혹은 삭제가 빈번한 경우
- 꼭 대소 관계가 아니더라도 그냥 key로 value를 빠르게 찾거나 원소의 삽입 / 검색 / 삭제만 빠르게 처리를 해주어야 할 경우에도 고려해볼 옵션

## [21939 - 문제 추천 시스템 Version 1](https://www.acmicpc.net/problem/21939)

### 1. 해결 핵심 아이디어

- 난이도와 문제번호 중 무엇을 key로 둘지 고민했는데, 들어오는 쿼리들을 보면 문제번호와 난이도 모두 한 번에 찾을 수 있어야하기에 <문제 번호, 난이도> 쌍의 BST하나 <난이도, [문제 번호]> 쌍의 BST하나 두 개를 두었다
- <난이도, [문제 번호]> 쌍의 BST의 경우 문제 번호가 항상 정렬되있어햐 하기에 문제 번호들을 담는 컨테이너를 set으로 두었다
- add의 경우 단순히 추가해주면 되고, solved의 경우 두 BST에서 해당되는 데이터를 삭제해주면 되고, recommend의 경우 최대값은 제일 높은 난이도의 경우 마지막 데이터의 마지막 문제 번호를 출력, 최솟값은 제일 낮은 난이도의 경우 처음 데이터의 첫 문제 번호를 출력해주면 된다

### 2. 코멘트

- 문제번호를 삭제하면서 set 컨테이너가 비었을 때, 해당 pair자체를 날려버려야한다, 그렇지 않으면 <키, 빈 set>으로 남아있게돼서, 잘못된 주소를 참조한다

## [23326 - 홍익 투어리스트](https://www.acmicpc.net/problem/23326)

### 1. 해결 핵심 아이디어

- 처음 접근했던 방식은 현재 위치에 변경에 따른 거리 갱신과 제일 가까운 거리를 산출해줘야하기에 <거리, 구역>으로 BST를 두고 알고리즘을 설계했는데, 시간 초과를 받았다
- 생각해보니 첫 접근방식은 현재 위치가 변경될 때 기존에 유지하고있던 BST를 초기화하고 모든 명소에 대해 다시 거리를 계산해줘야하기 때문에 비효율적이고 여기서 시간 초과가 났다
- 다른 방식을 고민해보다가 생각이 안나서 정답코드를 참고하였다
- 명소의 개수가 최대 50만이므로 만약 모든 쿼리가 현재 위치를 바꾸는 쿼리라면 50만 \* 10만 = 5조라서 시간초과가 나고, 결국에는 현재 위치에서 가장 가까운 거리는 lower_bound이되, 원형이므로, 제일 가까운 명소가 현재 위치번호보다 작다면 이를 보정해줘야한다
- 명소의 개수가 굉장히 많을 수 있으므로 BST로 관리하여 명소를 조회할 때 모든 구역을 살펴보는게 아닌 명소만 살펴보게한다

### 2. 코멘트

- 원형에서 두 거리 차이 구할 때 모듈로를 사용하였는데 여기서 1-indexed라서 보정이 필요하여, 원 구역 번호를 1씩 좌로 평행이동 시키고, 모듈로를 적용 후 다시 우로 평행이동 시켰다
- 좀 충격적인게 있는데, 모듈로가 덧셈 / 뺄셈보다 우선순위가 높은 것을 반대로 알고 있어서 여기서 디버깅을 했다, 왜 반대로 알고있었지??

## [21944 - 문제 추천 시스템 Version 2](https://www.acmicpc.net/problem/21944)

### 1. 해결 핵심 아이디어

- 21939번 문제 추천 시스템 Version 1에서 알고리즘 분류 속성이 추가된 버전이다
- 알고리즘 분류에 따라서 제일 어려운 문제와 제일 쉬운문제를 바로 참조할 수 있어야한다
  - <알고리즘 분류, multiset[<난이도, 문제 번호>]> BST로 해결할 수 있다
- 알고리즘 분류와 상관없이 제일 어려운 문제와 제일 쉬운문제를 바로 참조할 수 있어야한다
  - <난이도, set[문제 번호]> BST로 해결할 수 있다
- 알고리즘 분류와 상관없이 난이도가 L보다 작은 문제 중 가장 어려운 문제, L과 같거나 큰 문제 중 가장 쉬운 문제를 바로 참조할 수 있어야한다
  - lower_bound로 해결할 수 있다
- 문제번호만 주어질 때 바로 삭제될 수 있어야한다
  - 앞서 봤던 BST에서 바로 조회하여 삭제할 수 있어야하므로 <문제번호, <난이도, 알고리즘 분류>> BST로 해당 문제가 어떤 난이도와 어떤 알고리즘 분류에 속해있는지 파악하면된다

### 2. 코멘트

- 알고리즘 분류가 포함된 문제들 중 가장 어려운 문제와 가장 쉬운 문제를 출력하라고 했는데 이 조건을 빼먹어서 한참 찾았다 ㅡㅡ, 문제 좀 잘 읽어라 진짜

## [19700 - 수업](https://www.acmicpc.net/problem/19700)

### 1. 해결 핵심 아이디어

- 이 문제를 처음 접근했던 방식은 키가 작은 학생부터 하나씩 뽑아서 최소 등수만큼 키가 큰 학생들을 순서대로 채워줬었다 이렇게 한 이유는 키가 큰 학생부터 뽑아야 팀이 늘어날 확률이 줄어들기 때문이다(키가 작은 학생들은 최소 등수를 고려해서 이후 키가 큰 학생들이 들어오면 들어올 자리가 )
- 접근 방식의 오류는 키만 고려했었던 점인데, 만약 154 3 188 4 180 1과 같은 테스트 케이스에서 180은 1이라 저 팀에 못들어가는데 이 점을 고려안했다는 것이다
- 팀 수가 최소화되려면 한 팀에 최대한 우겨넣어야하고, 해당 그룹에 들어갈 수 있는 학생들을 모두 채워넣어야하기에 최소 등수가 현재있는 팀의 인원 수보다 크다면 넣어도 됨을 의미한다
- 만약 키가 작은 순으로 팀을 구성한다고하면, 생성된 팀의 인원수만 보고 팀을 뽑을 수 없고, 어떤 팀에 어떤 키가 들어있는지 전부 알고있어야한다
- 반면 키가 큰 순으로 팀을 구성한다고하면, 이후 뽑힐 학생은 현재 팀에 있는 학생들보다 키가 작음이 자명하기때문에 인원수와 최소 등수만 보고 팀을 새로 만들어줄지 기존의 팀에 들어갈지 결정할 수 있다

### 2. 코멘트

- 조건을 하나도 놓치지 말아야한다
- 테케만 보고 올바른 알고리즘이라 판단하지말고 다른 테케만들어 내는 연습이 필요하다 이 문제처럼 테케가 1개만 주어진 문제들은 이것만 보고 알고리즘이 올바른지 아닌지 판단이 어렵다

## [1539 - 이진 검색 트리](https://www.acmicpc.net/problem/1539)

### 1. 해결 핵심 아이디어

- 곧이 곧대로 구현하면 편형된 트리의 경우에는 insert를 총 n번하기때문에 O($n^2$)이 되어 시간초과를 받는다
- '들어온 노드가 갈 위치를 바로 알 수 있다면 어떨까?'라는 생각에서 접근해봤음
- bst를 <노드, 레벨>로 설정해놓고 관리한다, 어떤 노드 x가 들어왔을 때는 lower_bound(x)(이하 lb)를 통해서 x가 위치할 곳을 찾아줄 수 있다
- lb가 있는 경우는 lb의 왼쪽으로 가게되고, lb가 없을 경우 오른쪽으로 가게된다(구축된 트리에서 최대값이 들어오는 경우)
- lb가 있는 경우를 자세하게 살펴보자 lb가 bst의 begin이라면 최소값이 들어온 경우이다 이 때는 무조건 lb의 왼쪽으로 가야하고(lb와 x사이의 수는 존재할 수 없고, 트리의 제일 왼쪽에 위치해야하기에 lb보다 level이 무조건 1 클 수 밖에 없다), 그게 아닌 중간 어딘가의 값이라고 하자 이 노드는 lb의 왼쪽 prev(lb)의 오른쪽에 위치할 수 밖에 없다
  - 이 때 두 가지 경우를 나눠서 생각하자
  - x를 제외한 lb와 prev(lb)사이의 수는 존재할 수 없는데 이유는 만약 있었다면 이 수가 prev(lb)가 되었어야하기 때문이다(정렬되있기 때문)
  - 직관적인 이해는 매우 힘들다
  - 1. lb가 prev(lb)보다 먼저들어왔다
    - lb의 높이 < prev(lb)의 높이
    - x는 무조건 prev(lb)의 오른쪽 자식으로 갈 수 밖에없다
    - prev(lb)의 오른자식이 있는 경우는 존재할 수 없다
      - prev(lb)의 왼쪽과 오른쪽 자식 두 개 모두 없음을 귀류법으로 증명해보자
      - lb와 prev(lb)사이에 중간 수가 없기 때문인데 prev(lb)의 오른쪽 자식이 있었다고 가정하면 이 수가 x보다 작을 경우 prev(lb)가 됬어야하고, x보다 크면서 lb보다 작을 경우는 x의 lb로 이 값이 되어야하고 x보다 크면서 lb보다 클 경우는 말이 안되는데 lb의 오른쪽으로 갔을 건데 지금 살펴보고 있는 부분은 lb의 왼쪽이다
  - 2. prev(lb)가 lb보다 먼저들어왔다
    - prev(lb)의 높이 < lb의 높이
    - 1과 비슷한 논리로 lb의 왼쪽 자식이 있는 경우는 없다
      - lb의 왼쪽 자식이 있었다면 이 자식이 x보다 작은 값이므로(중복이 없으므로 같은 경우는 없다) 이것이 prev(lb)가 되었어야한다(prev(lb)가 lb보다 먼저 들어왔으므로 lb의 왼쪽 자식이 prev(lb)일 수는 없다)

### 2. 코멘트

- 풀이를 쓰다보니까 더 깊게 이해하는 거 같아서 좋다
