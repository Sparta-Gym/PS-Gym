# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https:ww.acmicpc.net/problem/11286" rel="nofollow">11286 - 절댓값 힙</a>](#11286---절댓값-힙)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 코멘트](#2-코멘트)
  - [<a href="https:ww.acmicpc.net/problem/1715" rel="nofollow">1715 - 카드 정렬하기</a>](#1715---카드-정렬하기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 코멘트](#2-코멘트-1)
  - [<a href="https:ww.acmicpc.net/problem/1927" rel="nofollow">1927 - 최소 힙</a>](#1927---최소-힙)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 코멘트](#2-코멘트-2)
  - [<a href="https:ww.acmicpc.net/problem/2075" rel="nofollow">2075 - N번째 큰 수</a>](#2075---n번째-큰-수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 코멘트](#2-코멘트-3)
  - [<a href="https:ww.acmicpc.net/problem/11279" rel="nofollow">11279 - 최대 힙</a>](#11279---최대-힙)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 코멘트](#2-코멘트-4)
  - [<a href="https:ww.acmicpc.net/problem/13975" rel="nofollow">13975 - 파일 합치기 3</a>](#13975---파일-합치기-3)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 코멘트](#2-코멘트-5)
  - [<a href="https:ww.acmicpc.net/problem/1655" rel="nofollow">1655 - 가운데를 말해요</a>](#1655---가운데를-말해요)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 코멘트](#2-코멘트-6)
  - [<a href="https:ww.acmicpc.net/problem/1781" rel="nofollow">1781 - 컵라면</a>](#1781---컵라면)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 코멘트](#2-코멘트-7)

<!-- Created by https:ithub.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 11월 11일 금요일 09시 15분 17초 KST -->

<!--te-->

## [11286 - 절댓값 힙](https:ww.acmicpc.net/problem/11286)

### 1. 해결 핵심 아이디어

- 이 문제의 경우 절댓값이 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다. 절댓값이 가장 작은 값이 여러개일 때는, 가장 작은 수를 출력하고, 그 값을 배열에서 제거한다는 조건 때문에 비교 함수를 직접 짜야하는데, priority_queue를 사용해서 해결해보자
- 기존에 알고있던 custom 비교 함수는 보통 함수 형태로 전달했었는데, priority_queue는 컨테이너이다 보니 sort와는 다르게 비교 클래스를 전달해야한다(함수의 비교 → 비교함수, 컨테이너의 비교 → 비교 클래스)

  ```cpp
  class cmp{
   public:
    bool operator() (int a, int b){
     if(abs(a) != abs(b)) return abs(a) > abs(b);
     return a > 0 && b < 0;
    }
  };
  ```

- 비교 함수던 비교 클래스던 정렬이 끝났을 때 a와 b의 위치가 어떻게 되야하는지 생각해보면 된다 a가 앞 원소, b가 뒤 원소니까 만약 내림 차순 정렬한다고 했을 때 정렬이 끝나면 a는 앞 원소, b는 뒤 원소이므로 a가 b보다 뒤에 있어야되므로 return문에 a를 앞 원소, b를 뒤 원소로 가정하고 정렬이 끝나고 만족되어야하는 관계를 작성해주면된다
- 항상 cmp(a,a) = false를 만족해야한다, 아니면 런타임에러남

### 2. 코멘트

- 비교 함수와 비교 클래스 헷갈리기 쉬우니

## [1715 - 카드 정렬하기](https:ww.acmicpc.net/problem/1715)

### 1. 해결 핵심 아이디어

- 허프만 코딩(압축에 쓰이는 알고리즘)에서 이 문제와 똑같이 카드 묶음 중 제일 작은 거와 그 다음 작은거 두 개를 묶어서 새로운 묶음으로 만들고, 또 같은 작업이 반복되서 나온 최종적인 작업의 횟수가 제일 작음이 증명돼있다(그리디)
  - greedy에서 봤던 task scheduling problem
- 이 사실만 알고 있다면, 그냥 끝나는 문제임
- 최소를 반복적으로 꺼내야하므로 heap을 사용하기 매우 좋은 상황

### 2. 코멘트

- 우선순위 큐는 특별하게 응용되는 분야가 있다기 보다 우선 순위 큐가 제공하는 최대값 최소값 빨리 찾기를 요구하는 문제에서 쓰면 된다
- 그리디랑 자주 묶일 가능성 매우 높음

## [1927 - 최소 힙](https:ww.acmicpc.net/problem/1927)

### 1. 해결 핵심 아이디어

- 최소힙 구현하는 문제

### 2. 코멘트

- warm up용 문제

## [2075 - N번째 큰 수](https:ww.acmicpc.net/problem/2075)

### 1. 해결 핵심 아이디어

- 메모리 제한이 12MB이고 n의 상한이 1500이라 최대로 데이터가 들어와도 1500 \* 1500 \* 4Byte = 9MB이기에 제한에 안 걸릴 줄 알았는데 걸린다
- sizeof로 pq사이즈를 뽑아보니 원래는 크기 5일때 기대값으로 20이 나와야하는데 32가 나온다
- 배열을 써서 내림차순으로 정렬을 한 다음 n-1번째 위치하는 원소를 뽑아주는 방식을 취한다면 메모리 제한에 걸리지 않는다, 배열은 n \* n \* 4B 크기를 갖기 때문이다
- 그래서 메모리 줄일 방법이 생각이 안나서 정답코드를 참고하였다
- n번째로 큰 값이 배열에서 어디에 위치할지 모르고, 우선순위 큐에는 최대 n개의 원소가 담겨야 n번째 큰 값을 찾을 수 있다
- 입력 받으면서 우선 순위 큐에 넣되, 사이즈가 n을 넘어간다면 pop시켜서 사이즈 n을 계속 유지시켜준다
- 결과적으로 우선순위큐에는 입력 받으면서 n번째 큰 수보다 작은 수들은 다 pop되었으므로 top이 n번째로 작은 수가 된다

### 2. 코멘트

- 컨테이너 사용 시 메모리 계산방법에 대해 바킹독님 블로그에 질문 남겨두었음 - [질문 링크](https:log.encrypted.gg/1015#comment13980070)
- 이 문제 실버였네? 자존심 상한다

## [11279 - 최대 힙](https:ww.acmicpc.net/problem/11279)

### 1. 해결 핵심 아이디어

- 최대힙으로 알맞은 쿼리처리해주면 되는 문제

### 2. 코멘트

- STL warm up용 문제

## [13975 - 파일 합치기 3](https:ww.acmicpc.net/problem/13975)

### 1. 해결 핵심 아이디어

- 1715번 카드 정렬하기 문제와 동일하게 허프만 코딩 방법으로 해결하면 된다

### 2. 코멘트

- 간단하니 패스

## [1655 - 가운데를 말해요](https:ww.acmicpc.net/problem/1655)

### 1. 해결 핵심 아이디어

- 이 문제는 처음에 2075번 N번째로 큰 수 응용문제인 줄 알았다 왜냐하면 중간값이라는게 사이즈가 n일 때 n이 짝수라면 n/2 - 1번째로 큰 수이고, n이 홀수라면 n/2번째로 큰 수이기 때문이다
- 근데 그 문제의 아이디어를 차용해봤을 대 큐 사이즈가 n이 넘어가면 자동으로 pop이 되기 때문에 이 문제는 중간값의 인덱스를 구하기위해 전체 수의 사이즈를 알아야하는데 그럴 수 없다는게 문제였다
- 결국 못풀어서 정답코드를 참조하였다
- 이 문제를 푸는 아이디어의 핵심은 중간값은 원소의 크기가 n이고 정렬되있다고 할 때, 절반으로 나누면 작은 수 | 큰 수가 되므로 |가 중간값이 되는 것이다
- 그렇다고 이 문제는 원소가 들어올 때마다 정렬해준다면 시간초과를 받게된다(시간 제한 0.1초, n크기 10만)
- 정렬된 것을 흉내내기 위해 두 개의 우선순위 큐를 이용한다
- 하나는 작은 값들이 정렬되있고, 중간값을 살펴보기 위함이므로 최대힙을 사용
- 하나는 큰 값들이 정렬되있고, 중간값을 살펴보기 위함으로 최소힙을 사용
- | 작은 수 최대힙 | 중간값 | 큰 수 최소힙|
- 이것을 구현하기 위해 다음과 같은 규칙으로 두 큐를 관리해준다
  - 1. 최소힙의 모든 원소는 최대힙의 모든 원소보다 항상 크거나 같아야함
  - 2. 런타임에서 최대힙의 크기는 항상 최소힙의 크기보다 1크거나(사이즈 짝수일 때 중간값 뽑기위함), 같아야함(사이즈 홀수일 때 중간값 뽑기위함)
- 주의할 점은 2 1 ... 이런식으로 들어오게되면 최대힙에 2가 들어가고 최소힙에 1이 들어가기때문에 규칙 1에 위반되므로 원소를 넣을 때마다 최소힙의 top이 최대힙의 top보다 작다면 둘을 swap해줘야한다

### 2. 코멘트

- 많은 것을 배울 수 있는 좋은 문제
- 우선순위 큐 2개로 정렬을 흉내내어 중간값 얻는 아이디어

## [1781 - 컵라면](https:ww.acmicpc.net/problem/1781)

### 1. 해결 핵심 아이디어

- 이 문제를 처음 접근했던 방식은 그리디 단원의 회의실 배정문제 처럼 시각을 늘려가면서 해당 시각에 데드라인에 걸리는 것들 중 최대 컵라면을 갖는 문제를 선택하는 알고리즘을 생각했었다
- but, 위 풀이의 반례는 다음과 같은 게 있다

  ```plane text
    3
    1 1
    2 10
    2 20
    시각 1에서 1 1과 2 20이 경쟁, 이후 시각 2에서 2 10이 선택
    정답 10 + 20 = 30
  ```

- 즉 어떤 상황이냐면, 미래에 후보로 거론될 후보가 현재의 최적을 결정할 수 있는 상황이다
- 그리디 단원에서 주식문제가 이와 비슷했다 그 때도 주식이 인접에서 낮아지만 보고 결정했었는데 미래의 최대값에서 팔아야 최대이득이었다
- 이처럼 최적값이 현재의 최적을 결정하는데 있어서 미래에 살펴볼 값으로 결정될 수 있는 경우 거꾸로 살펴서, 미래에서 과거를 결정짓는 방식으로 풀어야한다
- 시간을 역행하지 않는다면 미래의 후보를 살펴볼 수 없기때문이다

### 2. 코멘트

- 응용이란게 쉽지않구나
- 앞에거 거의 까먹었겠구나, 다 돌고 1회독 더 해야겠다
