// 2배 순간이동 하는 것이 가중치가 0이라 우선적으로 처리되어야함
// 왜 우선처리냐? "최단거리"기 때문, 같은 목적지에 도달하기위해 순간이동하는
// 방법과 걸어가는 방법이있는데, 당연히 순간이동하는 것이 비용이 적게 들어가기
// 때문에 정답인 최단경로이다.

// 그러면 다음으로 방문할 노드의 순서를 cur * 2를 먼저해주면 되느냐? 그건 아니다
// 아래 예시를 보자

// 4 -> 6 으로 가는경우 (4, 3, 6) 으로 시간이 1초가 나와야하는데 (4, 5, 6)
// 이런식으로 먼저 방문해버리면 2초가 나와버린다.
// 물론 이건 ( *2, -1, +1) 순으로 검사하면 걸리지 않지만 (*2, +1, -1) 로 하는
// 경우 걸리게 되는 문제이다.
// 만약 (*2, +1, -1)로 BFS의 코드를 작성하신 경우 해당 목표값에 도달했다고 바로
// 값을 출력하지 말고, 방문시간을 계산해서 최소값으로 갱신해주는 방식으로
// 접근해야 합니다.

// 그럼 이런 특수케이스를 어떻게 발견하느냐?
// BFS는 모든 간선의 가중치가 같을 때 최단거리 알고리즘으로 쓸 수 있는 것이다.
// 단순히 생각해보면, BFS에서는 가중치가 낮은 경로를 우선적으로 탐색하라는 법은
// 없다. 단순히 인접노드를 집어넣기때문에 정답이라고 한들 순전히 운이다.
// 그래서 간선의 가중치가 다를 때 최단경로는 다익스트라를 이용하지만, 이
// 문제처럼 가중치가 0과 1로 이루어진 방향그래프의 경우는 0-1 BFS라는 특수
// 알고리즘을 적용할 수 있다.

// 이 문제의 경우 가중치가 0과 1로 이루어진 방향그래프에서의 최단경로를 찾는
// 문제에 해당하는데, 두 가지 솔루션이 있다
// 1. 다익스트라
// 2. 0-1 BFS
// 0-1 BFS는 이 문제처럼 가중치가 0과 1로 이루어진 방향그래프에서 최단경로를
// 찾는 특수 알고리즘이다.
// 시간복잡도가 O(V + E)로 다익스트라보다 효율적이다.

// 번외로, bfs로도 해결할 수는 있다.
// 우선순위 큐를 사용하는 건 BFS라고 할 수 없습니다. 다익스트라에 가까운
// 방법인데, 한 가지 빠진 것이 이미 큐에 넣은 정점이라도 실제로 방문하기 전에
// 거리를 또 갱신할 수 있어야 한다는 점입니다.

// 예시로, 2 6 과 같은 입력에서 2 - 4 - 8 - 7의 경로가 2 - 3의 경로보다 먼저
// 방문하게 되어, 7에서 6으로 내려가는 경로가 먼저 visited[6] 을 true로
// 만들어버리고 이 때의 이동 횟수는 총 2가 됩니다
// 하지만 똑같은 우선순위를 갖는 3에서 2배를 해서 6에 도달하면
// 거리가 갱신될 수 있는데도 이미 visited가 표시되어 있어 큐에 삽입 자체를
// 안 하게 됩니다.

// 이 문제를 BFS로 풀고자 한다면,
// *2를 별도의 간선으로 생각하지 않고, +1이나 -1에 의한 좌표를 큐에 넣을 때 그
// 좌표의 2의 거듭제곱 배인 좌표들을 전부 큐에 넣는 방법으로 해결할 수 있다.
// *2는 이동하는게 아니라 같은 시작점으로 봐도 무방하다 왜냐면, 가중치없이
// 이동이 가능하기에 이유는 2배로 순간이동 하는 것이 가중치 없이 목표에 도달할
// 수 있는 가장 빠른 방법이기에 모든 가능한 2의 거듭제곱을 보고 그 점에서 bfs를
// 시작하는 즉, 시작점이 여러개인 bfs를 응용한다.

#include <bits/stdc++.h>

using namespace std;

#define MX 100000

int n, k;

int dist[MX + 2];

void teleport(queue<int>& q, int cur) {
  if (cur == 0) return;  // 0에 뭘 곱해봤자 0이니 순간이동 불가
  int nxt = cur;
  while (nxt < MX and dist[k] == 0) {
    // 아직 방문 전이라면
    if (dist[nxt] == 0) {
      dist[nxt] = dist[cur];  // 가중치 없음
      q.push(nxt);
      if (nxt == k) return;  // 동생 위치 찾으면 종료
    }
    nxt <<= 1;  // 2배 증가
  }
}

void bfs(queue<int>& q) {
  while (dist[k] == 0) {
    int cur = q.front();
    q.pop();
    for (int nxt : {cur + 1, cur - 1}) {
      if (nxt < 0 or nxt > MX) continue;
      if (dist[nxt] > 0) continue;
      q.push(nxt);
      dist[nxt] = dist[cur] + 1;
      // *2를 별도의 간선으로 생각하지 않고, +1이나 -1에 의한
      // 좌표를 큐에 넣을 때 그
      // 좌표의 2의 거듭제곱 배인 좌표들을 전부 큐에 넣는 방법으로
      // 해결할 수 있음
      teleport(q, nxt);
    }
  }
}

int main(void) {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cin >> n >> k;
  queue<int> q;
  dist[n] = 1;
  q.push(n);
  teleport(q, n);  // 순간이동만으로 가능할 수 있음, bfs돌린다 하더라도 이미
                   // 방문했기에 바로나옴
  bfs(q);
  cout << dist[k] - 1 << '\n';
  return 0;
}