# 0x0D 시뮬레이션

<!--ts-->

- [0x0D 시뮬레이션](#0x0d-시뮬레이션)
  - [0x00 연습 문제 1 - 감시](#0x00-연습-문제-1---감시)
  - [0x01 연습 문제 2 - 스티커 붙이기](#0x01-연습-문제-2---스티커-붙이기)
  - [0x02 연습 문제 3 - 2048(Easy)](#0x02-연습-문제-3---2048easy)
  - [0x03 연습 문제 4 - 치킨 배달](#0x03-연습-문제-4---치킨-배달)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 6월 28일 화요일 12시 58분 56초 KST -->

<!--te-->

주어진 문제 상황을 구현한다

특정 알고리즘에 종속되지 않음

구현이 강조됨

## 0x00 연습 문제 1 - 감시

- 구현해야하는 것들
  - 각 cctv의 방향 정하기
  - 정한 방향에 대해서 사각 지대의 크기 구하기
- 각 cctv의 방향은 cctv의 종류에 따라 1, 2, 4개이다
- 나올 수 있는 모든 조합을 다 시도하면서 사각지대가 최소가 되는 조합을 찾는다
  - 방향의 쌍끼리 `조합`을 할 수 있다 → 백트래킹 시도 가능
  - N과 M(3)에서 해봤음
- 변수들이 가질 수 있는 값이 여러개이고 변수들끼리(각 방향) 서로 독립적일 땐(각 cctv가 상호 간 방향을 정해주는 것이 아님) 백트래킹보다 진법을 이용한 방법이 더 쉬울 수 있다.

  - 이 문제에서 가능한 방향의 종류가 4개(상하좌우)이니 4진법을 사용한다.
  - 예시로 1번 카메라가 3개 있는 경우, 가능한 경우의 수는 $4^3$이다
  - 진수를 이용하기 위해서 0 ~ 63의 가짓 수를 4진수로 바꾸고 각 자릿수를 얻는 방식으로 구현한다
  - cctv가 k개 일 때 0부터 $4^k - 1$까지에 대해 아래 코드와 같이 작성한다
  - 근데 1, 3, 4번 cctv는 가능한 방향이 4개가 맞는데 2번은 상하 2개, 5번은 상하좌우 1개인데 왜 무조건 $4^k$로 계산하는지?

    - 따지고 보면 조합의 수에서 제약조건을 걸어서 특정 조합이 안생기게 하면 되는데 귀찮은 과정이므로 모든 cctv가 4가지 방향이 가능하다고 가정
    - 이로 인해 중복된 계산이 발생 → 시간 내로 통과해서 상관없다

    ```cpp
    for(int i = 0; i < (1 << 6); ++i){
     int cs = i; // i가 바뀌면 안되니 복사본으로
     for(int j = 0; j < 3; ++j){
      cout << cs % 4;
      cs / 4;
     }
     cout << '\n';
    }
    ```

    ![1](https://user-images.githubusercontent.com/48282185/175777653-b621c93c-a839-4504-a0db-b809b41093b9.png)

  - 정한 방향에 대해서 사각 지대의 크기 구하기

    ![2](https://user-images.githubusercontent.com/48282185/175777652-24b9dd19-bad7-4414-8793-7266a038685c.png)

    - 화살표를 따라가면서 벽을 만날때까지 쭉 진행하면서 지나치는 영역에 마크를 남긴다
    - 그 뒤 마크가 없는 영역의 수를 세면 사각지대의 개수가 나옴

- 시간복잡도
  - 시간 제한 내에 들어올 수 없을 것 같은 경우는 최적화를 시도해보거나 아예 다른 방법으로 구현해야한다
  - (방향 검사와 마킹하는 함수의 호출 횟수 _함수의 연산량 + 모든 칸을 확인하는 연산량)_ 총 가짓수
  - 이 문제에서 worst case일 때 20971520이라서 시간 제한에는 문제가 없지만 만약 제한이 더 빡세다면 위에서 말했던 조합의 수를 최적화 하는 과정을 추가해줘야함
    - 최적화 방법 1 - 쓸모없는 경우의 수 줄인다
      - cctv가 2번일 때 dir이 2, 3이면 continue, cctv 5번은 dir ≠ 0이면 continue
      - upd함수에서 마킹할 때마다 전역변수 cnt 값을 1 증가시켜 빈 칸을 확인하는 연산량을 절약, 마킹 개수를 전역변수로 저장해놓고 최대값 갱신할 때 이용

## 0x01 연습 문제 2 - 스티커 붙이기

- 구현해야하는 것들

  - 스티커를 특정 영역에 붙일 수 있는지 확인하고 붙이기

    - 겹치는 칸이 있는지 확인
    - 큰 배열에서 일부분의 영역을 확인할 때 아래와 같이 할 수 있다

    ```cpp
    bool check(int x, int y) {
      for (int row = 0; row < r; ++row) {
        for (int col = 0; col < c; ++col) {
          if (laptop[x + row][y + col] == 1 and sticker[row][col] == 1)
            return false;
        }
      }
      return true;
    }
    ```

  - 스티커를 회전하기

    - 행렬을 90도회전하면 어떻게 되는지 종이에다 그려보니 아래와 같은 규칙을 찾음
    - A를 90도 회전하면 B라할 때 아래와 같은 규칙을 찾을 수 있다.

      - B의 행이 A의 열이고 B의 열이 A의 행으로 갔다
      - 배열 A가 r × c였다면 B[x][y] = A[r-1-y][x]가 된다

        ![3](https://user-images.githubusercontent.com/48282185/175777650-0293607d-a0b3-49a9-ac17-5bd5a6b865ab.png)

- 시간복잡도
  - 각 모눈종이에 대해 노트북에 놓을 수 있는지 확인하는 위치의 개수 4 _40_ 40
  - 모눈종이를 특정 위치에 놓을 수 있는지 확인하기 위해 필요한 연산 10 \* 10
  - 스티커 최대 100
  - 위의 곱사건이므로 worst case는 6천4백만, 2초 내에 가능한 연산량

## 0x02 연습 문제 3 - 2048(Easy)

- 구현해야하는 것
  - 게임판을 상하좌우로 기울이기
  - 5번 기울이는 각각의 방향을 정하기(앞서봤던 감시와 동일)
- 게임판을 상하좌우로 기울이기

  - 왼쪽으로만 기울이는 simplecase
  - 내가 짜본 코드

  ```cpp
  int a[8] = {0, 2, 0, 2, 8, 8, 0, 16};
  bool merged[8] = { false, };
  for (int i = 1; i < 8; ++i) {
    if (a[i] != 0) {
      int start = i;
      int elem = a[i];
      while (start >= 1 && a[start - 1] == 0) a[start--] = 0;
      a[start] = elem;
      if (start >= 1 && !merged[start - 1] && elem == a[start - 1]) {
        a[start - 1] *= 2;
        merged[start - 1] = true;
        a[start] = 0;
      }
    }
  }
  ```

  - 갓킹독 선생님 코드

  ```cpp
  int arr[8] = {0, 2, 0, 2, 8, 8, 0, 16};
  int tited[8] = {}; // 복사본
  bool merged[8] = {}; // 합친적 있는지 체크
  for(int i = 0; i < 8; ++i){
   if(arr[i] == 0) continue;
   if(tilted[0] == 0){
    tilted[0] = arr[i];
    continue;
   }
   int idx = i;
   while(tilted[idx] == 0) idx--;
   if(!merged[idx] && tilted[idx] == arr[i]){
    merged[idx] = true;
    tilted[idx] *= 2;
   }
   else tilted[idx + 1] = arr[i];
  }
  ```

  - 차이라고 하면 기울여진 상태를 나타내기위해 새로운 배열을 만들었다는 점인데, 이게 구현이 훨씬 간단하네, 앞으로 배열의 요소 이동이 있을 때 새로 만들어보는 것은 어떨까?
  - 위의 코드의 시간복잡도는 O($N^2$)이다.
  - 근데 요소의 이동을 위처럼 O(N)에 하지않고 O(1)에 할 수 있다. 위의 코드에서 tilted배열의 원소의 개수를 알고있으면 이동할 위치를 알 수 있다.

    ```cpp
    int arr[8] = {0, 2, 0, 2, 8, 8, 0, 16};
    int tited[8] = {}; // 복사본
    int idx = 0; // 합친적 있는지 알 수 있음과 동시에 다음번 놓을 위치 확인
    for(int i = 0; i < 8; ++i){
     if(arr[i] == 0) continue;
     if(tilted[idx] == 0) tilted[idx] = arr[i];
     else if(tilted[idx] == arr[i]) tilted[idx++] *= 2;
     else tilted[++idx] = arr[i];
    }
    ```

  - 이 문제는 기가막힌 아이디어로 해결될 수 있는데, 나는 상하좌우 네 방향에 대해 각각 위처럼 로직을 구현해야한다고 생각했는데, `보드 자체를 회전시킴으로써` 좌 이동만 가지고 네 방향이 모두 커버 가능하다.

    ![4](https://user-images.githubusercontent.com/48282185/175777646-c9b8bf30-7b30-4397-8f90-4b4af21b7b11.png)

  - 시간복잡도
    - 기울임 처리 연산 횟수 → 20 \* 20
    - 기울이는 횟수는 최대 5번
    - 가능한 방향의 개수 → $4^5$
    - 곱사건이므로 2048000

## 0x03 연습 문제 4 - 치킨 배달

- M개 이하의 경우도 뽑히는 것을 생각해볼 수 있는데 치킨집이 많으면 많을 수록 치킨 거리는 줄어든다, 그래서 그냥 M개를 뽑는 조합의 수를 생각하면 됨
- 구현해야할 것
  - 폐업시키지 않을 M개의 치킨집 고르기
  - 치킨 거리 계산
- 시간복잡도
  - 도시의 치킨 거리를 구하기 위한 연산 횟수 → 100 \* 13
  - 폐업시키지 않을 치킨집을 뽑는 경우의 수 → $13 \choose 6$
  - 곱사건이므로 2230800

> 바킹독님 유튜브 강의를 참고하여 제작하였습니다.
