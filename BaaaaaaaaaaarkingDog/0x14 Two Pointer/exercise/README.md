# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/2230" rel="nofollow">2230 - 수 고르기</a>](#2230---수-고르기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 코멘트](#2-코멘트)
  - [<a href="https://www.acmicpc.net/problem/1806" rel="nofollow">1806 - 부분합</a>](#1806---부분합)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 코멘트](#2-코멘트-1)
  - [<a href="https://www.acmicpc.net/problem/1644" rel="nofollow">1644 - 소수의 연속합</a>](#1644---소수의-연속합)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 코멘트](#2-코멘트-2)
  - [<a href="https://www.acmicpc.net/problem/2003" rel="nofollow">2003 - 수들의 합 2</a>](#2003---수들의-합-2)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 코멘트](#2-코멘트-3)
  - [<a href="https://www.acmicpc.net/problem/13144" rel="nofollow">13144 - List of Unique Numbers</a>](#13144---list-of-unique-numbers)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 코멘트](#2-코멘트-4)
  - [<a href="https://www.acmicpc.net/problem/22862" rel="nofollow">22862 - 가장 긴 짝수 연속한 부분 수열 (large)</a>](#22862---가장-긴-짝수-연속한-부분-수열-large)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 코멘트](#2-코멘트-5)
  - [<a href="https://www.acmicpc.net/problem/2531" rel="nofollow">2531 - 회전 초밥</a>](#2531---회전-초밥)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 코멘트](#2-코멘트-6)
  - [<a href="https://www.acmicpc.net/problem/20922" rel="nofollow">20922 - 겹치는 건 싫어</a>](#20922---겹치는-건-싫어)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 코멘트](#2-코멘트-7)
  - [<a href="https://www.acmicpc.net/problem/2461" rel="nofollow">2461 - 대표 선수</a>](#2461---대표-선수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
    - [2. 코멘트](#2-코멘트-8)
  - [<a href="https://www.acmicpc.net/problem/2283" rel="nofollow">2283 - 구간 자르기</a>](#2283---구간-자르기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-9)
    - [2. 코멘트](#2-코멘트-9)
  - [<a href="https://www.acmicpc.net/problem/20366" rel="nofollow">20366 - 같이 눈사람 만들래?</a>](#20366---같이-눈사람-만들래)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-10)
    - [2. 코멘트](#2-코멘트-10)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 11월  3일 목요일 13시 16분 19초 KST -->

<!--te-->

## [2230 - 수 고르기](https://www.acmicpc.net/problem/2230)

### 1. 해결 핵심 아이디어

- 가장 단순하게 떠올릴 수 있는 이중 반복문을 통한 풀이를 생각해보자

  ```cpp

  for(int i=0; i<n; ++i){
   for(int j=i j<n; ++j){
    if(a[j] - a[i] >= m) ans = min(ans, a[j] - a[i]);
   }
  }

  ```

- 이 풀이에서 불필요한 작업이 무엇인지 생각해보자
- a를 정렬했다고 가정하자
- i가 증가함에 따라 a[j] - a[i] ≥ m을 만족하는 최초의 지점 j 또한 증가하는데, 무조건 i부터 검사함
- 각 i에 대해 a[j] - a[i] ≥ m을 만족하는 최초의 지점 j를 찾은 이후에는 a[j+1], a[j+2], …를 확인할 필요가 없음에도 n-1까지 확인함
- 각각의 원소에 대하여 두 개의 포인터 st(i의 역할)와 en(j의 역할)을 두고 en - st >= m을 만족하는 en을 찾는다, 만약 min이 갱신될 수 있으면 갱신한다
- 정렬과 투 포인터를 통해 굳이 확인안해도 되는 원소의 쌍을 확인하지 않게되었다

### 2. 코멘트

- 투 포인터 문제들은 인덱스 에러를 내기 쉽다, out of index
- 포인터가 배열 내에서만 동작하도록 꼼꼼히 구현해야한다
- 이분탐색으로도 풀 수 있음, 자세한 풀이는 [2230_Another.cpp](./2230_Another.cpp)참조

## [1806 - 부분합](https://www.acmicpc.net/problem/1806)

### 1. 해결 핵심 아이디어

- 가장 단순하게 풀 수 있는 이중 반복문 풀이

  ```cpp
    for(int i=0; i<n; ++i)
      int sum = i;
      for(int j = i+1; j<n; ++j)
        if(sum + a[j] > s) break;
        sum += a[j];
  ```

- 이 풀이에서 불필요한 작업이 무엇인지 생각해보자
- 부분합을 구하는 구간이 겹치는 부분이 많다 예를 들어 [1,5]와 [2,6]이 각각 S이상을 만족한다고 할 때 [2,5]의 합이 지속적으로 구해지고 있다
- 하지만 한 번만 구해놓고 다음 후보를 찾을 때 쓸 수 있다
- [1,5]의 부분합에서 a[1]을 빼면 [2,5]의 부분합이 나오기 때문에 [2,6]의 부분합을 구할 때 여기다 a[6]만 더해주면 되기 때문이다
- 위 방법으로 문제를 풀면 O(N)에 해결가능하고, N의 상한이 십만이고, 시간 제한은 0.5초 이기때문에 최대 5천만번의 연산이 가능하므로 통과가능하다
- st가 i의 역할을 en이 j의 역할을 하는 투포인터를 이용한 풀이로 변경하면, en이 n을 넘지않을 때까지 하나씩 이동시켜가면서 합이 s를 넘는지 확인한다
- st를 1증기시키고 구해놓은 부분합에서 a[st]를 빼고 a[st+1]부터 시작하는 연속된 부분합 중에 S가 넘는게 있을 때까지 en을 이동시키면서 반복한다

### 2. 코멘트

- 이분탐색으로도 문제 풀 수 있다 자세한 풀이는 [1806_Another.cpp](./1806_Another.cpp) 참조

## [1644 - 소수의 연속합](https://www.acmicpc.net/problem/1644)

### 1. 해결 핵심 아이디어

- 1806 부분합 문제와 동일한 아이디어

### 2. 코멘트

- 소수 구할 때 에라토스테네스의 체를 활용했음

## [2003 - 수들의 합 2](https://www.acmicpc.net/problem/2003)

### 1. 해결 핵심 아이디어

- 2230번 수 고르기 문제와 동일한 아이디어로 해결가능

### 2. 코멘트

- 인덱스 실수 안하게 주의하자

## [13144 - List of Unique Numbers](https://www.acmicpc.net/problem/13144)

### 1. 해결 핵심 아이디어

- 이 문제를 못 푼 것에 대해서는 반성해야한다
- 단순히 등장했는지 안 했는지만 체크하면되는데 이 간단한 것을 생각해내지 못하다니 진짜 분하다
- 두 개의 포인터를 두는데, st와 en은 각각 살펴보고 있는 구간의 시작과 끝이다
- 어떤 수를 추가할 때 이 수가 나왔었는지 확인하기 위해 is_used배열을 활용하여 flag로 표시해준다
  - 백트래킹이나 다른데서 많이 썼던 아이디어인데 왜 왜 왜 응용을 못하니...
- 어떤 구간에서 가능한 경우의 수는 구간의 길이와 같다 예시로 1 2 3 4 5에서 생기는 경우는 15인데 st가 1을 가리키고 en이 5를 가리킬 때 가능한 경우는 5가지인데 이것은 구간의 길이와 같다

### 2. 코멘트

- 빈도수배열까지 생각했는데 이걸 왜 생각못했지? 머리가 나쁜건 진짜 힘드네

## [22862 - 가장 긴 짝수 연속한 부분 수열 (large)](https://www.acmicpc.net/problem/22862)

### 1. 해결 핵심 아이디어

- st와 en으로 구간을 만들고 만들어진 구간에 홀수가 등장할 때마다 카운트를 1씩 증가시켜서 cnt > k가 되는 순간이나 en이 n-1보다 커지는 경우 탈출하여 연속되는 짝수의 개수를 세줬음
- 만들어진 구간에서 최장 연속 짝수의 개수는 en - st - cnt임

### 2. 코멘트

- 삭제시킬 수 있다고해서 곧이곧대로 삭제했으면 매우 어려워졌을 것임

## [2531 - 회전 초밥](https://www.acmicpc.net/problem/2531)

### 1. 해결 핵심 아이디어

- 연속하여 k개가 될 때까지 en을 이동시킨다
- uniq는 연속된 k개로 이뤄진 초밥들 중 유일한 초밥 종류의 수이다
- 만약 이전에 나왔던 거라면 uniq를 증가시키지 않고, 처음나오면 것이면 uniq를 증가시킨다
- 이전에 구간에서 구했던 uniq의 개수를 활용한다
- 다 구하고나서 쿠폰이 안 쓰인 경우, 추가해준다
- st를 1 이동시킬 때, 이전 st가 유일한 번호였다면 uniq를 1 감소시킨다

### 2. 코멘트

- 구현이 까다로웠던 문제

## [20922 - 겹치는 건 싫어](https://www.acmicpc.net/problem/20922)

### 1. 해결 핵심 아이디어

- st와 en을 연속 수열의 시작과 끝으로 두고 원소를 추가해나가는데, 빈도수 배열을 활용해서 추가할 원소가 k번 이상쓰였는지 확인한다
- 만약 k번 미만으로 사용되었다면 추가하고 사용된 횟수가 k번 이상일 때는 추가할 수 없으므로 en의 이동을 멈춘다

### 2. 코멘트

- while문에 is_used[s[en]] + 1 <= k를 하면되는 간단한 문제였는데, +1을 할 생각을 좀 늦게했음, 구현력이 너무 안좋다 진짜

## [2461 - 대표 선수](https://www.acmicpc.net/problem/2461)

### 1. 해결 핵심 아이디어

- 모든 반을 합쳐볼까 생각은 해봤는데, 하빛면 반 번호로 구분을 못하기때문에 패스했던 방법인데, 반 번호로 구분이 안되면 변수를 추가해서 구분시켜주면 될 일을 왜 일차원적으로만 생각했을까?
- 결국 데드라인을 못넘기고 정답을 참고하였다
- 모든 반의 학생들에 대해 한 배열에 각각 능력치와 반 번호를 입력받고 정렬한다
  - 정렬하는 이유는 당연하게도 랜덤 배치인 경우 절댓값 차이가 제일 작게 나는것끼리 비슷한 위치에 없을 수 있다
- 정렬 후 두 개의 포인터를 이용하여 구간을 표현할 것이다, st와 en은 각각 구간의 시작과 끝을 가리킨다
- 구간을 설정하고 계산이 가능하기위한 조건이 있는데, 구간 내에 모든 학급의 학생들이 포진해있어야한다
- 만약 모든 학급의 학생들이 구간 내에 들어온 경우 최소와 최대를 찾아서(정렬했으니 구간 시작(st)이 최소이고 구간 끝(en)이 최대이다) 이 둘의 차이를 구하고 갱신 가능하면 최소를 갱신해준다

### 2. 코멘트

- 앞으로는 합치면 구분이 안가는 경우 변수를 추가하여 구분지어서 풀이가 가능해진다면 그 방법을 이용해보도록 하자

## [2283 - 구간 자르기](https://www.acmicpc.net/problem/2283)

### 1. 해결 핵심 아이디어

- 처음 시도했던 방식은 시작점 중 가장 작은 것과 끝점 중 가장 큰 것을 각각 st와 en으로 놓고 구간을 줄여가면서 잘라내야하는 길이(총 길이 - k)를 찾아보는 방식이었는데, 이 방식의 문제점은 st와 en 중 어떤 것을 어떤 조건에서 이동시켜야할지가 명확하지 않아서 st와 en을 모두 이동시켜보고 잘라내야하는 길이를 초과한다면 st나 en 중 하나를 물러야하는데, 어떤 것을 무를지도 정하기 어려웠고, 이런방식으로하면 시간초과가 날 것 같았다
- 결국에 해결하지 못함, 골드 3까지는 어찌저찌하겠는데 골드 2부터는 진짜 어려운 것 같다, 골드 2 필터링 너무 잘되는거 아닌가?
- 투포인터 특성 자체가 특정 범위에서 조건을 만족 하는지 안하는지에 따라 범위가 넓어지느냐 좁아지느냐 인데 앞서 봤던 문제들처럼 st와 en을 0으로 두고, 합이 k보다 작은 경우는 en을 증가시켜서 구간을 늘리고 합을 크게 만들어준다, 반대로 합이 k를 초과하면 구간을 좁혀야하는 것이므로 st를 증가시켜서 구간을 줄이고 합을 작게 만들어준다
- 합이 k를 만족하면 바로 출력해주고 종료시키는데 답이 여러개일 수도 있는데 종료를 왜시키냐 할 수 있는데, 답이 여러 개인 경우 A가 가장 작은 경우를 출력하고 그것도 여러개 존재할 때는 B가 가장 작은 경우를 출력하라는 문제에 조건이 있는데, 위 논리에서 en과 st모두 증가하면서 구간을 탐색하기때문에 제일 처음 발견되는 케이스가 가장 작은 A와 가장 작은 B를 만나는 것임

### 2. 코멘트

- 조건을 만족하지 않는다면 구간을 늘리고 줄이고 해야하는데, 투 포인터의 시작점을 둘 다 0으로 둬서 구간을 늘리고 줄이고하는 방식을 고려해봅시다
- 논리 흐름이 어 조건 만족못하니? -> 구간 변경해줄게 -> 구간을 늘려줘야하는 조건일까? 구간을 줄여줘야하는 조건일까? -> 늘려줘야하는 조건이면 늘려주고 줄여줘야하는 조건이면 줄여준다 -> 늘리고 줄일 때 포인터들은 왔던 길을 다시 가지 않아야한다, 왜냐하면 다시 탐색한다는 거 자체가 탐색을 잘못하고 있다는 얘기임

## [20366 - 같이 눈사람 만들래?](https://www.acmicpc.net/problem/20366)

### 1. 해결 핵심 아이디어

- 서로 다른 인덱스를 갖는 네 쌍의 원소 조합을 만들어 두 개씩 그룹지은 뒤 합하여 두 그룹의 차이의 절댓값을 최소로하게 만드는 문제
- 완탐으로 보면 조합을 만들기 위해 4중 반복문이 필요하고 시간 제한을 넘길 수 없다
- 처음에는 단순히 window size를 4로하는 슬라이딩 윈도우 방식으로 그 안에서 조합을 검사하려했는데 `1 2 1000 2000 10001 10002`같은 예외가 있다
- 반례가 있다는 것은 윈도우의 크기가 서로 다른 네 개의 조합을 뽑기위해 4 `이상`이여야 한다는 것을 의미한다
- 그래서 두 번째 방식을 시도했는데, 3중 반복문으로 i와 j를 각각 눈사람의 머리로 두고 몸통 두 개를 투포인터로 정해주는 방식이었다
  - 이 방법은 4중 반복문으로 완전탐색하는 것에서 투 포인터를 이용해서 3중반복문으로 줄인 방식이다
  - i, j, st, en의 인덱스는 모두 달라야하고, s[i], s[j] <= s[st], s[en]을 만족해야하기에 구현이 좀 더러워진다
  - 어찌저찌 구현하면 통과는 하겠지만, 더 좋은 솔루션이 있을 것 같아서 찾아봤고 아래에 정리하겠다
- 처음 시도했던 방식을 확장한다, 윈도우 크기가 최소 4부터 시작하여 최대 n까지 전부 살펴봐야한다
- 구간의 양 끝을 정해두고 그 사이에서 투 포인터를 이용하여 두 원소쌍의 조합을 생성하여 구간의 양 끝 두 원소로 이루어진 조합과 그 차이를 비교한다
  - diff = (s[st] + s[en]) - (s[i] + s[j])
- 차이의 절댓값을 0에 가깝게 만드는 것이 목표이므로 diff가 음수라면 st를 오른쪽으로(s[st] + s[en]을 더 크게 만들어야 함), 양수라면 en을 왼쪽으로 움직여서(s[st] + s[en]을 더 작게 만들어야 함) 차이의 절댓값이 더 작아질 수 있는지 확인한다
  - 가능한 이유는 정렬이 되있기때문에 각 포인터의 이동이 합을 증가시키고 감소시킴이 보장되있기 때문

### 2. 코멘트

- 두 번째 시도했던 방식과 정답과 조합을 어떻게 구성하느냐의 차이인데 구현과 효율성에 있어서 큰 차이가 났다, 난 왜 자꾸 이상한 방향으로 흘러가는걸까?
- 조합 문제는 풀기 전에 어떻게 조합시키는게 가장 효율적일지 생각을 해보는 게 좋겠다
