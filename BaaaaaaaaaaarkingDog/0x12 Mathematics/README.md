# 0x12 수학

<!--ts-->

- [0x12 수학](#0x12-수학)
  - [0x00 소수](#0x00-소수)
  - [0x01 최대공약수](#0x01-최대공약수)
  - [0x02 연립합동방정식](#0x02-연립합동방정식)
  - [0x04 이항계수](#0x04-이항계수)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 7월 11일 월요일 02시 35분 42초 KST -->

<!--te-->

## 0x00 소수

- 소수는 1과 자기 자신으로만 나누어지는 수, 약수가 2개인 수
- 합성수는 1과 자기 자신을 제외한 다른 약수를 가지고 있는 수
- 1은 소수도 합성수도 아니다
- 소수 판정법

  - 2부터 N-1까지의 수로 나누어지지 않는 수를 찾는다 → O(N)

    ```cpp
    if(n==1) return 0;
    for(int i = 2; i < n; ++i) if(n % i == 0) return 0;
    return 1;
    ```

  - 합성수 N에서 1을 제외한 가장 작은 약수는 $\sqrt{N}$이하이다
    - 증명 - 합성수 N에서 1을 제외한 가장 작은 약수를 x라하자, $N \over X$ 또한 1이 아닌 N의 약수이기 때문에 x ≤ $N \over X$ 이다. 우변의 분모 x를 좌변으로 옮기면 $X^2 \leq N$ 이므로 양변에 루트를 씌우면 성립하는 것을 알 수 있다
  - 위의 사실을 이용하여 2부터 $\sqrt{N}$까지의 수로 나눠지지 않으면 소수이다라는 것을 추론할 수 있다, 합성수라면 2 이후로 처음에 도달하는 약수가 $\sqrt{N}$이하에 무조건 존재하기때문에 그렇다 → O($\sqrt{N}$)

    ```cpp
    if(n==1) return 0;
    // math의 sqrt는 실수형이기에 오차발생할 수 있어서 잘모르면 쓰지말자
    for(int i = 2; i*i <= n; ++i) if(n % i == 0) return 0;
    return 1;
    ```

  - 2 ~ N까지 소수의 개수를 구하는 문제를 마주쳤을 때 어떻게 해결할 수 있을까?

    - 사실 위에서 봤던 2 ~ $\sqrt{N}$사이의 모든 정수에 대해 일일이 확인해보지 않아도 된다
    - 1이 아닌 최소 약수는 소수이기때문이다, 만약 1제외 최소 약수가 소수가 아니라 했을 때 귀류법으로 증명해보면, 소수가 아니므로 그 수도 어떤 수로 나눠떨어짐을 의미하고, 이는 최소가 아니다로 쉽게 증명가능하다
    - 정리해보자면 2 ~ $\sqrt{N}$사이의 모든 소수에 대해서 검사해보면 된다는 것이다, 이를 이용해서 최적화 한 코드는 아래와 같다

    ```cpp
    vector<int> primes;

    for(int i=2; i<=n; ++i){
     bool is_prime = true;
     for(int prime: primes){
      if(prime * prime > i) break;
      if(i % prime == 0){
       is_prime = false;
       break;
      }
     }
     if(is_prime) primes.push_back(i);
    }
    ```

  - 범위 내에서 위의 방법들보다 더 효율적인 알고리즘이 있는데 바로 에라토스테네스의 체이다
  - 에라토스테네스의 체

    - 어떤 수의 배수는 소수가 아니다라는 명제에 입각한 알고리즘
    - 2부터 시작하여 2의 배수를 제거, 다음 3을 가리키고, 3의 배수를 제거하고, …, n까지 진행한다
    - 근데 여기서 최적화를 더 해볼 수 있다.
    - 만약 현재 5를 가리키고 있고, 5의 배수들을 제거할 차례라고 했을 때, 이미 2와 3의 배수는 걸러진 상태이다. 5의 배수라하면, 5 x 2, 5 x 3, 5 x 4, … 인데 5를 가리고보면 2, 3, 4 즉 5의 배수이기도 하면서 각각 2의 배수, 3의 배수, 4의 배수이기도 하다. 근데 이미 걸러졌으므로 5 x 5 이상의 5의 배수부터 체로 거르면 된다는 사실을 알 수 있다 → O(Nlog(logN))

    ```cpp
    vector<int> primes;
    vector<bool> state(n+1, true);
    state[1] = false; // 사실 필요없지만 명시적으로 해줌
    for(int i=2; i*i <= n; ++i){
     if(!state[i]) continue;
     for(int j=i*i; j <=n; j += i) state[j] = false;
    }
    for(int i=2; i<=2; ++i) if(state[i]) primes.push_back(i);
    ```

    - vector<bool> vs bool []
      - bool형의 크기는 1byte
      - vector<bool>은 각 원소가 1bit만 차지하게 최적화가 이루어짐, 공간 8배 적게쓴다
      - cache hit rate도 올라가서 응답시간도 빠르다
      - 앞으로 bool형 연속 자료구조는 vector를 쓰자

- 소인수분해
  - 정수를 소수들의 곱으로 나타내는 방법
  - 각 자연수를 소수들의 곱으로 표현하는 방법은 유일하다(산술의 기본정리)
  - 에라토스테네스의 체로 소수들을 미리 구한다음 하나씩 대입하며 나눠떨어질 때까지 해보는 방법이 있겠지만 이 보다 더 간단한 알고리즘이 있다
  - 결론부터 말하면 굳이 소수를 미리 안구해도 된다
  - i를 2부터 시작해서 N을 나누기 시작한다 더이상 i로 나눠떨어지지 않으면 i를 1증가시킨다
  - 나눠떨어지기 전까지 i를 계속 소인수 목록 배열에 추가시켜준다
  - 그렇다면 소인수 목록에 들어가는 숫자들은 소수라고 확신할 수 있는가? 정답은 yes, 왜냐하면, 에라토스테네스의 체를 최적화했던 것이랑 같은 맥락인데 2부터 시작하여 각 수에서 나누어 떨어지지 않을 때까지 계속 나눴기 때문에 그 과정에서 i의 배수들은 이미 등장한 것과 다름없다. 따라서 i가 증가하다가 소인수 목록에 들어가 있는 소인수의 배수가 되면, 나누어 떨어지지 않으므로, 소인수 목록에 들어갈 수 있는 수는 반드시 소수이다
  - 최적화를 진행할 수 있는데, N이 1이 될 때까지 계속 나눠보는 대신, i x i가 N보다 커지면 더 이상 진행하지 않아도 계속 나눠지던 N은 $\sqrt{N}$이하의 소인수로 분해될 수 없다는 것을 알 수 있다, 만약 N이 합성수 였다면 소수판별법에서 봤던 것 처럼 $\sqrt{N}$이하의 소인수를 가져야하고, $\sqrt{N}$이하의 소인수는 지나왔으므로 이미 소인수목록에 포함되있다. 즉, N은 소수이다 → O($\sqrt{N}$)
- 요약
  - 소수판정
    - 어떤 수가 소수인지 판정하는 것은 O($\sqrt{N}$)에 가능하기 때문에 N이 $10^{12}$정도 되더라도 괜찮다
    - 범위 내의 있는 소수들의 목록을 구하는 것은 에라토스테네스의 체
  - 소인수분해
    - 어떤 수를 소인수분해 하는 것은 O($\sqrt{N}$)에 가능하기 때문에 N이 $10^{12}$정도 되더라도 괜찮다

## 0x01 최대공약수

- 약수
  - 어떤 수를 나누어떨어지게 하는 수
- 구현

  - 약수를 구하는 것은 1부터 N까지 나눠보면 O(N)에 해결가능하지만, 약수끼리 쌍을 이뤄서 N이 된다는 사실을 이용하면 O($\sqrt{N}$)에 구현가능하다
  - 쌍에서 작은 수는 $\sqrt{N}$이하라는 사실을 이용하여 구현해보자

  ```cpp
  vector<int> divs;
  for(int i=1; i*i <= n; ++i){
   if(n % i == 0){
    divs.push_back(i);
    if(i*i != n)divs.push_back(n / i);
   }
  }
  ```

- 최대공약수(Greatest Common Dicisor, GCD)

  - 두 자연수의 공통된 약수 중에서 가장 큰 수

- 유클리드 호제법

  - 두 수 A, B에 대해 A를 B로 나눈 나머지를 r이라 할 때, GCD(A, B) = GCD(B, r)이다
  - 구현

    - 시간 복잡도 O(log(max(a,b)))

    ```cpp
    int gcd(int a, int b) {
      while (true) {
        int r = b > a ? b % a : a % b;
        b = a;
        a = r;
        if (r == 0) break;
      }
      return b;
    }
    ```

  - C++17기준으로 numeric헤더에 GCD구하는 함수가 포함되있음

    ```cpp
    #include <numeric>

    // 템플릿, a와 b의 타입만 같으면 리턴값도 a와 b의 타입을 따라감
    gcd(a,b);
    ```

- 최소공배수(Least Common Multiple)

  - A x B = GCD(A, B) x LCM(A, B)
  - 곱을 최대공약수로 나누면 최소공배수가 나옴
  - 이 또한 numeric헤더 내에 포함되있음

  ```cpp
  int lcm(int a, int b){
   // int overflow 방지를 위해 먼저 나눠준다
   // a랑 b랑 10^9일 때 생각해보자
   return a / gcd(a,b) * b;
  }
  ```

## 0x02 연립합동방정식

- 연립합동방정식이 어디서 쓰이는지 예시를 하나 보고가자
  - 6명씩 조편성을 하면 3명이 남는다
  - 5명씩 조편성을 하면 2명이 남는다
  - 학생은 30명 미만이다
  - x % 6 = 3, x % 5 = 2, x < 30
- 6064 - 카잉달력
  - <M:N>이 되는 해는 LCM(M, N)번 째 해이다
    - M과 N으로 다 나눠서 떨어져야하고, 그것을 만족하는 최소 수이므로
  - 유효하지 않은 <x:y>가 있을 수 있다
    - M=10, N=12일 때, <7:2>로 표현되는해는 없다 왜냐면, M과 N 모두 짝수인데 특정 수를 짝수로 나눈 나머지가 홀수라면 특정 수는 홀수이고, 나머지가 짝수라면 특정 수는 짝수인데 이를 동시에 만족하는 수가 없다
  - 구하고자 하는 해 - Y라 할 때
  - Y % m = x
  - Y % n = y
  - 연립합동방정식을 푸는 문제
- 대회에서는 연립합동방정식을 중국인의 나머지 정리를 이용하여 푸는데 모듈로 역수, 확장된 유클리드 호제법을 알아야 정리를 이용할 수 있기때문에 혹시나 필요한 상황이 오면 찾아보자

## 0x04 이항계수

![1](https://user-images.githubusercontent.com/48282185/178155742-2b5f5d87-88c0-49b7-b5a5-d92419bdb089.png)

- 경우의 수를 따질 때, 어떤 집합에서 원소를 뽑는 상황에서 뽑혀서 나온 원소들의 순서가 문제를 푸는데 있어서 의미있는 순서일 때는 순열로 계산, 순서가 의미없으면 조합으로 계산한다
- 경우의 수를 계산하거나 시뮬레이션이나 백트래킹에서 시간복잡도를 가늠할 때 필요한 경우 있음
- 팩토리얼 계산은 자료형의 범위초과를 쉽게 유발한다 그래서 N과 K가 작을 때만 반복문을 이용하여 계산할 수 있다
- ${n \choose k} = {n-1 \choose k} + {n-1 \choose k-1}$ 성질과 dynamic programming을 이용하여 이항계수를 쉽게 구할 수 있다
  - 1개를 선택했는데 그것이 뽑힐 경우의 수와 안 뽑힐 경우의 수를 더하면 총 경우의 수라는 사실을 통해 위 성질을 유추 가능하다
  - dp[i][j]를 $i \choose j$라고 두자
  - dp[i][j] = dp[i-1][j] + dp[i-1][j-1]

> 바킹독님 유튜브 강의를 참고하여 제작하였습니다.
