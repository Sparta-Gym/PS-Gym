# Learning About

<!--ts-->
* [Learning About](#learning-about)
   * [<a href="https://www.acmicpc.net/problem/11047" rel="nofollow">11047 - 동전 0</a>](#11047---동전-0)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
      * [2. 코멘트](#2-코멘트)
   * [<a href="https://www.acmicpc.net/problem/1931" rel="nofollow">1931 - 회의실 배정</a>](#1931---회의실-배정)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
      * [2. 코멘트](#2-코멘트-1)
   * [<a href="https://www.acmicpc.net/problem/2217" rel="nofollow">2217 - 로프</a>](#2217---로프)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
      * [2. 코멘트](#2-코멘트-2)
   * [<a href="https://www.acmicpc.net/problem/1026" rel="nofollow">1026 - 보물</a>](#1026---보물)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
      * [2. 코멘트](#2-코멘트-3)
   * [<a href="https://www.acmicpc.net/problem/11399" rel="nofollow">11399 - ATM</a>](#11399---atm)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
      * [2. 코멘트](#2-코멘트-4)
   * [<a href="https://www.acmicpc.net/problem/2457" rel="nofollow">2457 - 공주님의 정원</a>](#2457---공주님의-정원)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
      * [2. 코멘트](#2-코멘트-5)
   * [<a href="https://www.acmicpc.net/problem/1541" rel="nofollow">1541 - 잃어버린 괄호</a>](#1541---잃어버린-괄호)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
      * [2. 코멘트](#2-코멘트-6)
   * [<a href="https://www.acmicpc.net/problem/11501" rel="nofollow">11501 - 주식</a>](#11501---주식)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
      * [2. 코멘트](#2-코멘트-7)
   * [<a href="https://www.acmicpc.net/problem/1744" rel="nofollow">1744 - 수 묶기</a>](#1744---수-묶기)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
      * [2. 코멘트](#2-코멘트-8)
   * [<a href="https://www.acmicpc.net/problem/2847" rel="nofollow">2847 - 게임을 만든 동준이</a>](#2847---게임을-만든-동준이)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-9)
      * [2. 코멘트](#2-코멘트-9)
   * [<a href="https://www.acmicpc.net/problem/1439" rel="nofollow">1439 - 뒤집기</a>](#1439---뒤집기)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-10)
      * [2. 코멘트](#2-코멘트-10)
   * [<a href="https://www.acmicpc.net/problem/11000" rel="nofollow">11000 - 강의실 배정</a>](#11000---강의실-배정)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-11)
      * [2. 코멘트](#2-코멘트-11)
   * [<a href="https://www.acmicpc.net/problem/15903" rel="nofollow">15903 - 카드 합체 놀이</a>](#15903---카드-합체-놀이)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-12)
      * [2. 코멘트](#2-코멘트-12)
   * [<a href="https://www.acmicpc.net/problem/2170" rel="nofollow">2170 - 선 긋기</a>](#2170---선-긋기)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-13)
      * [2. 코멘트](#2-코멘트-13)
   * [<a href="https://www.acmicpc.net/problem/1700" rel="nofollow">1700 - 멀티탭 스케줄링</a>](#1700---멀티탭-스케줄링)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-14)
      * [2. 코멘트](#2-코멘트-14)
   * [<a href="https://www.acmicpc.net/problem/8980" rel="nofollow">8980 - 택배</a>](#8980---택배)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-15)
      * [2. 코멘트](#2-코멘트-15)
   * [<a href="https://www.acmicpc.net/problem/7570" rel="nofollow">7570 - 줄 세우기</a>](#7570---줄-세우기)
      * [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-16)
      * [2. 코멘트](#2-코멘트-16)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 11월  3일 목요일 13시 15분 25초 KST -->

<!--te-->

## [11047 - 동전 0](https://www.acmicpc.net/problem/11047)

### 1. 해결 핵심 아이디어

- n의 상한이 10, k의 상한이 천만인데, 이 문제를 완전탐색이나 동적계획법을 이용해서 풀면, O(nk)이라 시간초과에 걸릴 수 있다
- 문제에서 주어지는 동전들의 관계는 약수와 배수관계이다
- 따라서 그리디를 이용한 풀이를 생각해볼 수 있음
- 그리디 기준: 가장 큰 동전을 제일 많이 소모하는 것이 개수의 최소이다
- 보조정리 1
  - 동전을 최소로 소모하면서 물건값을 지불하려면 10/100원 동전은 4개 이하, 50원 동전은 1개 이하로 사용해야 한다
- 귀류법으로 증명 가능, 귀류법이란 명제가 거짓이라고 가정할 때 모순이 발생함을 보이는 증명법
- 증명을 해보자
  - 10 / 100원 동전을 5개 이상 사용 → 50 / 500원 동전으로 대체
  - 50원 동전을 2개 이상 사용 → 100원 동전으로 대체
  - 보조정리 1이 거짓이라고 가정했을 때, 10 / 100원 동전을 5개 이상, 50원 동전을 2개 이상 사용해서 동전의 개수를 최소화 할 수 있다는 건데, 위처럼 대체되면서 소모한 동전의 수를 더 줄일 수 있다. 따라서 보조정리 1은 참이다
  - 10, 50, 100원 동전으로는 물건값을 최대 10 _4 + 50_ 1 + 100 \* 4 = 490원만 감당 가능(보조 정리 1에 따라 사용할 수 있는 최대 개수로 만들어낸 최대합)하고, 500원을 다 사용하지 않을 경우 10, 50, 100원 동전으로 500원 이상 감당해야함
- 동전들 간의 관계가 약수-배수가 아니라면 그리디 알고리즘으로 항상 올바른 답을 낼 수 없다. 반례로는 1, 9, 10원으로 18원 만들기

### 2. 코멘트

- 동전을 정렬한 다음 최대값부터 차례대로 나누기를 해서 몫과 나머지를 구한다, 몫은 사용한 동전의 개수, 나머지는 현재 동전으로는 만들 수 없는 값이므로 다음으로 큰 수로 넘어가서 과정을 반복한다

## [1931 - 회의실 배정](https://www.acmicpc.net/problem/1931)

### 1. 해결 핵심 아이디어

- n의 상한이 십만이라 완전탐색으로 이 문제를 풀려고하면 O($2^n$)이기에 불가능하다
- 동적 계획법풀이도 생각해볼 수 있는데, 자신의 시작 시간보다 더 일찍 끝나는 회의들 중 회의 수의 최대를 구할 수 있음, 이 방법도 O($N^2$)이라 시간초과가 난다
- 시간 t를 축으로하는 수직 선 위에 각각의 회의를 표현하면, 가장 먼저 끝나는 회의를 택하는 것이 최적의 해를 나타내는 것을 볼 수 있는데, 이유는 끝나는 시각이 작다는 것은 그만큼 회의가 일찍 끝났다는 이야기이고, 다음에 진행할 수 있는 회의의 가짓수가 늘어남을 의미하기 때문이다
- 이 문제는 task scheduling problem이라는 대표적인 그리디 문제로, 가장 먼저 끝나는 task를 선택하면서 가장 많은 task가 스케줄될 수 있도록 하는 문제이다
- 귀류법으로 이 풀이가 정당한지 증명해보자
- 회의 A의 종료 시각이 회의 B의 종료 시각보다 빠르다
- 회의 A대신 회의 B를 선택했을 때 더 많은 회의를 배정할 수 있다고 가정
- 회의 B를 회의 A로 변경했을 때 문제가 없다. 왜냐하면 A는 남아있는 회의 중에서 가장 먼저 끝나는 회의이니 A가 B보다 먼저 끝난다. 그러면 회의 A말고 B를 선택했을 경우 더 많은 스케줄을 선택할 수 있다고 했는데, B를 A로 바꾸는 것이 가능하고, A를 선택하는 방법이 B를 선택했을 때 적어도 B를 선택했을 때 만큼의 회의 수는 보장이 된다. 그래서 모순이다
- 이 증명은 지금 최선의 선택을 하지 않았을 경우 최선의 선택을 했을 때 보다 더 결과가 좋아질 수 없음을 보인거고 내가 떠올린 그리디 알고리즘이 올바른지 확인할 때 지금 당장 손해를 보더라도 나중 가서는 이득인 경우가 있을 수는 없는지 고민해보면 정당성을 증명하거나 반례를 찾을 때 도움이 된다

### 2. 코멘트

- 종료시각을 기준으로 오름차순 정렬하고, 종료시각이 같으면 시작시간을 기준으로 오름차순 정렬해준다
- (1, 2), (2, 2) 두 개가 있다고 할 때 시작시간을 빠른 순으로 정렬해주지 않는다면 (2, 2)가 선택될 수 있고 회의 두 개가 진행될 수 있음에도 불구하고 (2, 2)가 선택되면 한 개의 회의만 가능하기때문임
- 종료시각이 가장빠른 회의를 선택하고, 이 회의의 종료 시각보다 시작 시각이 크거나 같은 회의 중 가장 빠른 시작 시각을 택한다

## [2217 - 로프](https://www.acmicpc.net/problem/2217)

### 1. 해결 핵심 아이디어

- 이 문제의 완전탐색 솔루션은 로프 하나 당 선택하고 안하고 2가지, 로프가 n개 있을 때 O($2^n$)
- n의 상한이 십만이기 때문에 완전탐색으로는 이 문제를 해결할 수 없다
- 최대 중량을 구하는 것이기 때문에, 제일 적은 중량을 버틸 수 있는 로프와 제일 큰 중량을 버틸 수 있는 로프 중 후자가 선택되야하는 것은 자명하다
- 생각을 조금만 비틀어서 최적의 솔루션을 만족하는 로프의 개수가 정해져있다고 생각해보자, 만약 3개라고 한다면, 가장 높은 중량을 버틸 수 있는 것 3개로 해야지 다른 로프가 3개 중 하나가 되면 최적이 안되는 것은 귀류법으로 증명할 수 있다
- 그리디 풀이를 생각해보자
  - 탐욕 기준: 가장 높은 중량을 버틸 수 있는 로프
  - 구현: 로프를 정렬 후 큰 순서부터 하나씩 추가시키며 얼만큼의 중량을 버틸 수 있는지 계산한다
  - 로프 i를 선택했을 때 버틸 수 있는 무게 w = 제일 적은 중량을 버티는 로프 rope[i] \* 선택된 로프의 개수 i, 최소 rope[i]를 버틸 수 있다, 다른 로프들은 rope[i]보다 큰 무게를 버틸 수 있음
  - 큰 무게부터 선택해나가면, 건너뛰어서 선택이런게 없다는 것을 증명했기에 선택된 로프들은 반드시 연속하게 되어있기에 그리디가 가능한 것

### 2. 코멘트

- 실버 4인데도 불구하고 난이도가 높다, 이게 그리디임을 증명해야되는 과정이 필요해서 그럼

## [1026 - 보물](https://www.acmicpc.net/problem/1026)

### 1. 해결 핵심 아이디어

- 이 문제는 증명하기에는 조금 어렵다, [재배열 부등식](https://pkjung.tistory.com/155)이라는 개념을 알고 있어야 A를 오름차순, B를 내림차순(A, B 서로 스위치도 가능)을 하고 곱한 값이 최소임을 알 수 있다
- B를 재배열하면 안 된다 그랬는데 정렬해도 상관없다, 최소를 만족하기 위해 재배열 부등식을 만족하는 서로의 짝이 있음 그래서 B의 각 원소에 알맞는 A의 원소가 곱해지면되는데 이것을 구하는 과정에서 굳이 일일히 B를 정렬하지 않고 찾아줄 필요가 없다
- 탐욕 기준: 어느 수열 x, y의 곱의 최소는 x를 오름차순, y를 내림차순하여 곱한 값의 합
- 구현: sort써서 해결

### 2. 코멘트

- 재배열 부등식이란 것을 몰랐더라면 이 문제 못 풀었을건데, 추측은 가능하다

## [11399 - ATM](https://www.acmicpc.net/problem/11399)

### 1. 해결 핵심 아이디어

- 이 문제를 완전탐색으로 풀기위해서는 모든 수열을 다 만들어 봐야하는데, n의 상한이 1000이라 O(1000!)이 걸리고, 내 일생동안 해결 못한다
- 이 문제는 운영체제의 스케줄링 알고리즘 중 sjf라는 방식을 다른 도메인에 적용시켜놓은 것이고, sjf보다 모든 작업의 wait time이 짧은 방법은 없다 즉, 최적이다

### 2. 코멘트

- 정렬을 해놓고, 계속 누적해서 더해준다
- 각 원소가 N번 씩 등장하니, 빈도수를 각 원소에 곱해줘도되고, 누적합으로 풀어도된다, 나는 누적합으로 풀었음

## [2457 - 공주님의 정원](https://www.acmicpc.net/problem/2457)

### 1. 해결 핵심 아이디어

- 이 문제를 완전탐색으로 풀기위해서는 모든 꽃을 선택하고 안하고 해서 모든 경우를 살펴봐야하는데 n의 상한이 십만이라 O($2^n$)이 걸리고, 해결 못한다
- 문제 조건에 따르면, 3월 1일부터 11월 30일까지 꽃이 피어있기만 하면되므로 사용되는 꽃의 개수를 최소화한다는 것은 저 기간동안 꽃이 끊기지 않고 피어있는데, 서로 다른 꽃이 같은 기간 내에 피어있을 필요가 없다
- 선택할 수 있는 꽃들 중(현재 꽃의 지는 일보다 선택 꽃의 피는 일이 빠르거나 같아야 함) 가장 길게 피는 것을 선택하는 것이 최적이다(귀류법으로 증명 가능)
- task scheduling problem의 응용버전

### 2. 코멘트

- 이 문제는 실제로 날짜 차이를 계산할 필요가 없다, 제일 긴 기간 동안 피는 꽃이라면 지는 일이 제일 느린 꽃이므로 날짜를 파싱할 필요가 없이 그냥 정수로 나타내면 된다

## [1541 - 잃어버린 괄호](https://www.acmicpc.net/problem/1541)

### 1. 해결 핵심 아이디어

- 이 문제를 완전탐색으로 풀기위해서는 괄호가 들어갈 수 있는 모든 자리에 괄호를 배치해보는 것이다 괄호가 들어갈 수 있는 자리는 $n^2$ (앞에서부터 차례대로 하나씩 괄호에 포함하면 n(맨 앞이 만들 수 있는 괄호) + n-1(두번째가 만들 수 있는 괄호) + n-2 + ...) 이게 괄호를 넣고 안 넣고의 경우이므로 $2^{n^2}$ 가 되고, n의 상한이 50이기때문에 해결 못한다
- 어떤 경우가 최소일지 생각해보자, 식에서 `-`가 나타났을 때, 뒤의 식이 어떻든 `-`가 나타나기 이전 누적 값에서 뺄 수 있는데, 괄호를 넣을 수 있기 때문이다

### 2. 코멘트

- 식에서 `-`가 나오면 그 이후로 나오는 숫자는 모두 빼버리고, 안나오면 모두 더한다
- 구현을 너무 복잡하는 경향이 있는데, 정확히 필요한 부분만 구현하자
- [이 문제의 정답코드를 보면 얼마나 간결하게 구현되는지 알 수 있음](https://github.com/encrypted-def/basic-algo-lecture/blob/master/0x11/solutions/1541.cpp)

## [11501 - 주식](https://www.acmicpc.net/problem/11501)

### 1. 해결 핵심 아이디어

- 이 문제를 완전탐색으로 풀기위해서는 각 주식을 사고 안사고를 살펴봐야하기에 $2^n$ 이 소요되는데, n의 상한이 백만이라 시간 내에 해결할 수 없다
- 처음 시도했던 아이디어는 비감소 구간에서는 더하고 감소되는 순간 최대값 - 누적값이 최적인 줄 알았으나 2 2 1 3과 반례가 있었다 저 논리대로하면 답은 2이지만, 정답은 4이다
- 최적의 답을 내는 것은 현재에서 미래에 만날 수 있는 최대값(이 이후 미래에서 이 값보다 큰 값이 없다)까지 기다렸다가 팔고, 그 최대값 이후로 다시 같은 과정을 반복한다
- 현재에서 만날 수 있는 최대를 구하는 과정을 순차 탐색하게되면, O($N^2$)이 소요되는데 최대를 뒤에서부터 탐색한다면, 각 요일에서 만날 수 있는 최대를 O(N)에 구해줄 수 있다
- 증명은 이거보다 최대가 나올 수 없다를 증명하면됨

### 2. 코멘트

- 반례를 만들어본다고 만들어봤지만, 너무 주어진 테스트케이스와 비슷하게 만드는 것 같다 진짜 별의별거 다 만들어봐야되는데, 그 능력이 딸린다
- 수열에서 각 항에서 자신 이후 만날 수 있는 최대를 찾아줄 때 거꾸로 탐색하는 아이디어를 활용하면 효율적이다
- 정답코드보니까 훨씬 간단하게 구현했음, 구현해야될 것을 쓰고, 어떻게하면 제일 효율적일지 생각해보고 구현에 들어가자

## [1744 - 수 묶기](https://www.acmicpc.net/problem/1744)

### 1. 해결 핵심 아이디어

- 이 문제를 완전탐색으로 해결하기 위해서는 모든 부분집합을 다 만들어봐야한다 부분집합을 만드는데 드는 시간복잡도는 O($2^n$)이고 n의 상한이 50이라 아슬아슬하게 가능은 할 것 같다
- 이 문제를 그리디로 풀어보자
- 내가 접근한 방법은 어느 위치에 있던 간에 두 수를 묶을 수 있다고 했으니, 임의의 두 수가 묶였을 때 가장 크게되는 케이스는 두 원소의 절댓값이 배열에서 최대와 최대 다음으로 큰 수보다 크게 되는 경우는 없으니 정렬 후에 하나씩 묶되, 안 묶는게 더 좋은 경우는 1 -1같은 경우가 있다 음수와 양수의 곱은 결과가 더 안좋아지기 때문에 이런 경우를 제외하고, 모두 묶었다
- 구현 방식은 아래 풀이에 적겠다

### 2. 코멘트

- 이 문제부터는 테스트케이스 다 맞았지만 뭔가 쎄해서 바로 제출하지 않고, 질문게시판에서 반례를 대입해봤는데 아니나 다를까 안되는 경우가 나왔음
- 처음에는 오름차순 정렬 후에 묶을지 말지를 seq[cur] + seq[cur - 1] < seq[cur] \* seq[cur - 1]로 결정했는데 음수들만 있다고 생각하면 틀린다
- 그래서 원소가 0보다 같거나 작은 양수일 때는 왼쪽에서부터 포인터를 두고 묶었고, 양수일 때는 오른쪽에서부터 포인터를 두고 묶었다

## [2847 - 게임을 만든 동준이](https://www.acmicpc.net/problem/2847)

### 1. 해결 핵심 아이디어

- 입력으로 주어지는 수열을 순서를 변경하지 않고 증가수열을 만들어야할 때 필요한 연산의 최소횟수이다
- i번 원소는 i+1번 원소보다 반드시 작아야하는데, i+1번 원소보다 작은 수는 여러개이지만 s[i+1] -1이 작은 수 중 제일 큰 수이고, s[i] > s[i+1]인 상황에서 s[i]를 s[i+1] + 1로 만드는데 필요한 연산의 회수보다 더 적은 연산을 필요로하는 s[i]는 존재하지 않는다
- 마지막 원소부터 봐야한다, 이유는 앞에서 볼 경우 0부터 현재까지 모든 경우를 다 체크해줘야하는 불편함이 있다

### 2. 코멘트

- s[i] > s[i+1]일 때 s[i]를 s[i+1] - 1로 만들기 위한 연산의 수를 정답에 누적해주고 s[i-1]이 조건에 맞지 않는 경우도 봐줘야하니까 s[i]를 s[i+1] + 1로 바꿔줘야한다

## [1439 - 뒤집기](https://www.acmicpc.net/problem/1439)

### 1. 해결 핵심 아이디어

- 0의 연속 구간이 많은가 1의 연속 구간이 많은가 체크한 다음 더 적게 존재하는 게 정답

### 2. 코멘트

- 각 구간의 시작을 체크해주고 포인트 이동시키면서 문자열 끝까지 간 다음 어느 구간의 개수가 더 적은지를 출력해주면 끝
- 정답코드보니까 달라지는 포인트만 체크해서 구간의 수 셌네, 이게 더 간결해서 좋은 방법인듯

## [11000 - 강의실 배정](https://www.acmicpc.net/problem/11000)

### 1. 해결 핵심 아이디어

- 처음 시도했던 방식은 1931번 회의실 배정문제와 동일하게 끝 시간이 빠른 순, 끝 시간이 같다면 시작시간이 빠른 순으로 정렬한 다음 모든 방이 선택될 때까지 한 방에 최대한 몰아넣고 다음 방 시작하고, 이래서 모든 강의가 다 골라질 때까지 반복하는 로직으로 짰는데, N의 상한이 O($N^2$)이라 시간초과가 났다
- 또 위와 같은 방식으로하면, (1, 2), (1, 4), (2, 6), (4, 5)같은 케이스에서 (1, 2)다음 (2,6)이 선택되야하는데 (4, 5)가 되어 정답은 2이지만 3이 나온다
- 그럼 이런 의문이 드는데, 그럼 '회의실 배정문제도 틀린거 아닌가?' 그건 아니다, 가장 빨리 끝나는 것을 골라야 더 많은 회의를 집어넣을 수 있기 때문이다
- 이 문제와 회의실 배정문제의 차이는 이 문제에서는 끝나는 시간이 작은거보다 강의 간의 시간 간격이 더 짧은게 더 우선순위가 크다 위의 예시가 그 방증인데, 모든 강의를 다 해야하기 때문에 이런 차이가 생긴다
- 이 문제의 정답은 가장 많은 수업이 열리는 시간에서의 수업의 개수이고, 시간의 상한이 10억이기 때문에 모든 시간을 일일이 볼 수는 없다
- 그래서 주어지는 시간을 시작 시간, 끝 시간 각각 저장하고, 이것들을 하나씩 꺼내서 같은 수업이 몇 개 있는지 살펴본다

### 2. 코멘트

- 특정 시각 t에 수업 중이라면 1을 더해주고, 끝나면 1을 빼준다, 두 수업이 겹친다면, 늦게 시작한 강의의 시작 시각 t에 일찍 시작한 강의도 아직 끝나지 않았으니 t에 진행 중이므로 t에 진행 중인 수업은 2개가 된다, 그리고 강의가 끝나면 1을 빼줘서 t에 강의가 없어졌음을 반영해줘야한다
- 구현이 경이로웠다! 이런 류의 문제가 나오면 쏠쏠하게 써먹을 수 있을 것 같다
- 우선순위 큐로도 풀 수 있는데, 그건 우선순위 큐 단원 문제 풀고 다시 보자

## [15903 - 카드 합체 놀이](https://www.acmicpc.net/problem/15903)

### 1. 해결 핵심 아이디어

- 이 문제는 sjf의 응용 버전이다
- 정렬을 하고 앞의 두 수를 더하고 덮어씌워주고를 m번 반복해주면된다

### 2. 코멘트

- accumulate를 사용했는데, 처음에 누적합의 초기값을 설정할 때 사용한 컨테이너의 타입으로 캐스팅해줘야한다 그냥 0으로 써넣으면 int형으로 인식하고 리턴값도 int로 정해지기때문에 오버플로가 경고가 안떠서 뭐가 원인인지 몰랐었다

## [2170 - 선 긋기](https://www.acmicpc.net/problem/2170)

### 1. 해결 핵심 아이디어

- 시작점을 작은 순으로 정렬하고, 시작점이 같을 때 끝점이 길건 말건 상관없다
- 현재의 선이 다음 선과 겹쳐지고, 선택된 다음 선의 끝이 현재 선보다 큰 경우 끝 점을 갱신해줬다
- 겹치지 않으면 새로운 선으로 간주하고 위의 과정을 반복한다

### 2. 코멘트

- 정답코드를 보니 11000번 강의실 배정 문제처럼 시작점과 끝점을 각각 입력받고, 현재 위치 t에 선이 있을 경우 더하고 선이 끝나면 빼주고 하는 식으로 겹치는 문제를 해결할 수도 있다, 강의실 배정 문제 풀 때 강의 겹치는 케이스봤는데도 응용이 안됬네 반성해야겠다

## [1700 - 멀티탭 스케줄링](https://www.acmicpc.net/problem/1700)

### 1. 해결 핵심 아이디어

- 이 문제는 운영체제 공부하다가 캐시 교체 알고리즘 중 가장 최소의 교체횟수를 갖는 알고리즘인 LFU이 떠올라서 풀 수 있었음
- cache fault가 나면, 캐시에 있는 것들 중 교체될 것을 선택해야하는데, 이후 스케줄 리스트를 보고 제일 늦게 사용되는 것이 교체되어야한다
- 만약 현재 캐시 내에 있는 원소들이 교체 이후로 안쓰이면 아무거나 버려도 상관없다
- 캐시 알고리즘 공부 안 했으면 못 풀었을듯

### 2. 코멘트

- 중간 삭제가 빠른 자료구조인 리스트를 사용했다, 오랜만에 사용하니 가물가물해서 도큐보면서 구현했다

## [8980 - 택배](https://www.acmicpc.net/problem/8980)

### 1. 해결 핵심 아이디어

- 처음에 접근했던 아이디어는 거리가 멀리 떨어져 있을수록 적게 싣는 것이었다, 이유는 멀수록 계속 가지고 있어야해서 중간에 다른 것들을 못 싣는 경우가 생기기 때문이다
- 그래서 위 방식대로 했는데, 가까울수록 많이 싣고, 멀수록 적게 싣는 로직을 짰는데, 자리가 남는다고 무조건 실으면 안 됬다, 여기서 더 나아기지 못해 정답코드를 참고하였다
- 도착 마을 번호를 기준으로 오름 차순으로 정렬하여, 가까울수록 제일 많이 배달되게하는 로직으로 구성해야했다
- from과 to - 1(to에서 내리므로 고려대상 x) 사이의 어떤 마을에서 제일 적게 실을 수 있는 최소 용량이 10이라고하면, from에서 실을 수 있는 용량은 10이다
- 싣고 나서는 from에서 to - 1까지의 적재 용량이 변하므로 실은 만큼 적재용량에서 빼준다
- [참고한 블로그](https://steadev.tistory.com/15)

### 2. 코멘트

- 풀이를 읽어도 이해가 잘 안가서 여러번 본 문제이다, 어려웠다..
- 카카오 공채에서 비슷한 문제가 나왔는데, 그 문제는 트럭이 왔다갔다 하는 것이었음

## [7570 - 줄 세우기](https://www.acmicpc.net/problem/7570)

### 1. 해결 핵심 아이디어

- 이 문제를 처음 접근한 방식은 N - LIS의 길이가 교체 횟수임을 관찰로 발견하고, 구하려고 보니, N의 상한이 백만이라 기존에 알고있던 동적계획법을 이용해서 LIS를 구하는 방법은 O($N^2$)이라 시간초과가 날 것이 뻔해서 다른 풀이를 생각해 봤는데, 도무지 떠오르질 않았다
- 이 문제에서의 LIS는 특이한 점이 있는데, LIS를 이루는 원소 간에는 서로 1차이가 나아한다는 점이다, 이 특이점으로 인해서 기존의 O($N^2$)의 시간복잡도를 갖는 동적계획법을 이용한 LIS 구하는 방법 대신, 인접한 원소의 위치가 현재 내 위치보다 뒤에 있으면 LIS의 길이가 증가하는 것으로 보고, 최장 인접 증가수열길이를 찾아서 n에서 빼주면 된다

### 2. 코멘트

- 동적계획법으로 풀면 dp[i] = i번 학생까지의 최장 인접 증가수열의 길이로 두고, dp[i] = dp[i-1] + 1 점화식을 세울 수 있는데, 자신 보다 1작은 원소가 이전에 나왔으면 dp[i-1]이 1이상일 것이므로 가능한 논리이다
- LIS까지 생각했는데 좀 아쉽다... 왜 확장이 안될까?
