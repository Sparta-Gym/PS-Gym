# 1차 리뷰

<!--ts-->

- [1차 리뷰](#1차-리뷰)
  - [1. 배열](#1-배열)
    - [1. 10807 - 개수 세기](#1-10807---개수-세기)
    - [2. 10808 - 알파벳 개수](#2-10808---알파벳-개수)
    - [3. 11328 - Strfry](#3-11328---strfry)
    - [4. 13300 - 방 배정](#4-13300---방-배정)
    - [5. 1475 - 방 번호](#5-1475---방-번호)
    - [6. 1919 - 애너그램 만들기](#6-1919---애너그램-만들기)
    - [7. 2577 - 숫자의 개수](#7-2577---숫자의-개수)
    - [8. 3273 - 두 수의 합](#8-3273---두-수의-합)
  - [2. 링크드 리스트](#2-링크드-리스트)
    - [1. 1158 - 요세푸스 문제](#1-1158---요세푸스-문제)
    - [2. 1406 - 에디터](#2-1406---에디터)
    - [3. 5397 - 키로거](#3-5397---키로거)
  - [3. 스택](#3-스택)
    - [1. 10828 - 스택](#1-10828---스택)
    - [2. 10773 - 제로](#2-10773---제로)
    - [3. 1874 - 스택 수열](#3-1874---스택-수열)
    - [4. 2493 - 탑](#4-2493---탑)
    - [5. 6198 - 옥상 정원 꾸미기](#5-6198---옥상-정원-꾸미기)
    - [6. 17298 - 오큰수](#6-17298---오큰수)
    - [7. 3015 - 오아시스 재결합](#7-3015---오아시스-재결합)
    - [8. 6549 - <strong>히스토그램에서 가장 큰 직사각형</strong>](#8-6549---히스토그램에서-가장-큰-직사각형)
  - [4. 큐](#4-큐)
    - [1. 10845 - 큐](#1-10845---큐)
    - [2. 18258 - 큐 2](#2-18258---큐-2)
    - [3. 2164 - 카드2](#3-2164---카드2)
  - [5. 덱](#5-덱)
    - [1. 1021 - 회전하는 큐](#1-1021---회전하는-큐)
    - [2. 10866 - 덱](#2-10866---덱)
    - [3. 5430 - AC](#3-5430---ac)
    - [4. 11003 - 최솟값 찾기](#4-11003---최솟값-찾기)
  - [6. 스택의 활용(올바른 괄호쌍)](#6-스택의-활용올바른-괄호쌍)
    - [1. 4949 - 균형잡힌 세상](#1-4949---균형잡힌-세상)
    - [2. 3986 - 좋은 단어](#2-3986---좋은-단어)
    - [3. 9012 - 괄호](#3-9012---괄호)
    - [4. 10799 - 쇠막대기](#4-10799---쇠막대기)
    - [5. 2504 - 괄호의 값](#5-2504---괄호의-값)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2023년 3월 23일 목요일 09시 56분 18초 KST -->

<!--te-->

## 1. 배열

### 1. 10807 - 개수 세기

[10807번: 개수 세기](http://boj.kr/10807)

- 빈도수 배열을 활용하는 문제
- 배열은 random access가 가능한 구조로 어떤 원소의 존재 확인에 O(1)의 시간복잡도를 갖기에 어떤 원소가 몇 개있는지 세는 이 문제에 제일 적합한 자료구조임

### 2. 10808 - 알파벳 개수

[10808번: 알파벳 개수](http://boj.kr/10808)

- 빈도수 배열을 활용하는 문제
- 배열은 random access가 가능한 구조로 어떤 원소의 존재 확인에 O(1)의 시간복잡도를 갖기에 어떤 원소가 몇 개있는지 세는 이 문제에 제일 적합한 자료구조임

### 3. 11328 - Strfry

[11328번: Strfry](http://boj.kr/11328)

- **strfry** 함수는 입력된 문자열을 무작위로 재배열하여 새로운 문자열을 만들어낸다
- 두 개의 문자열에 대해, 2번째 문자열이 1번째 문자열에 **strfry** 함수를 적용하여 얻어질 수 있는지 판단
- 두 문자열이 같은지는 각 문자가 몇 번 등장했는지 확인하여 그 수가 같으면 된다 ⇒ 빈도수 배열
- 배열은 random access가 가능한 구조로 어떤 원소의 존재 확인에 O(1)의 시간복잡도를 갖기에 어떤 원소가 몇 개있는지 세는 이 문제에 제일 적합한 자료구조임

### 4. 13300 - 방 배정

[13300번: 방 배정](http://boj.kr/13300)

- 1학년부터 6학년까지 학생들이 묵을 방을 배정해야 한다. 남학생은 남학생끼리, 여학생은 여학생끼리 방을 배정해야 한다. 또한 한 방에는 같은 학년의 학생들을 배정해야 한다.
- 그룹화의 기준이 두 가지이다 ⇒ 이차원 배열을 이용해서 변수 두 개(학년, 성별)을 구분지어서 각 그룹에 몇 명이 있는지 빈도수를 센다
- 입력을 모두 받은 후 빈도수를 방의 최대 수용 수인 k로 나눠서 몇 개의 방이 필요한지 본다, 배수라면 그 만큼만 할당하면되고 나머지가 있다면 여분의 방이 필요한 것이므로 필요방 수 + 1 해준다
- 배열은 random access가 가능한 구조로 어떤 원소의 존재 확인에 O(1)의 시간복잡도를 갖기에 어떤 원소가 몇 개있는지 세는 이 문제에 제일 적합한 자료구조임

### 5. 1475 - 방 번호

[1475번: 방 번호](http://boj.kr/1475)

- 정답은 임의의 숫자의 최대 빈도수이다
- 특이한 점은 6과 9는 서로 교체가 가능하다는 점인데 이 문제를 나는 이렇게 해결했다
  - 6이나 9가 들어올 때마다 서로의 빈도수를 비교하고 가져다 쓸 수있으면 가져다 쓰는 것이다
  - 만약 9999라는 입력이 들어왔다고 하자 단순히 빈도수만 세면 9의 빈도수가 4이므로 정답은 4가 출력될 것이다 하지만 2세트만으로 방번호를 만들 수 있는데 2세트를 사면 6도 2개, 9도 2개이기 때문이다
  - 9가 들어왔을 때 6을 쓸 수 있는 상태라는 것은 어떻게 알 수 있을까?
    - freq[6] < freq[9]라면 9가 더 많이 쓰인 것이므로 6을 가져다 쓸 수 있다
    - freq[6] ≥ freq[9]라면 6이 더 많이 쓰였거나 같게쓰였으므로 6을 가져다 쓸 수 없다
    - 6의 경우도 마찬가지다
- 서로 교체가 가능할 때 최소 몇 개가 필요한가?에 대한 문제에 이런 로드밸런싱 기법을 적용하면 좋을 것 같다
- 배열은 random access가 가능한 구조로 어떤 원소의 존재 확인에 O(1)의 시간복잡도를 갖기에 어떤 원소가 몇 개있는지 세는 이 문제에 제일 적합한 자료구조임

### 6. 1919 - 애너그램 만들기

[1919번: 애너그램 만들기](http://boj.kr/1919)

- 서로 몇 개의 원소가 다른지 세는 문제
- 각 문자열의 빈도수를 각각 센 다음 빈도수 배열을 돌면서 abs(freq_string_a[i] - freq_string_b[i]) 해주면 정답이 나온다
- 두 문자열에서 서로 다른 문자의 개수 ⇒ 빈도수
- 배열은 random access가 가능한 구조로 어떤 원소의 존재 확인에 O(1)의 시간복잡도를 갖기에 어떤 원소가 몇 개있는지 세는 이 문제에 제일 적합한 자료구조임

### 7. 2577 - 숫자의 개수

[2577번: 숫자의 개수](http://boj.kr/2577)

- 세 개의 자연수 A, B, C가 주어질 때 A × B × C를 계산한 결과에 0부터 9까지 각각의 숫자가 몇 번씩 쓰였는지를 구하라
- 곱셈 후에 10으로 나눈 나머지를 봐가면서 각 숫자가 몇 개쓰였는지 파악해주면 끝
- A, B, C의 상한이 모두 1000이라 곱셈의 결과의 최대는 10억이므로 int형으로 가능하다

### 8. 3273 - 두 수의 합

[3273번: 두 수의 합](http://boj.kr/3273)

- n개의 서로 다른 양의 정수 a1, a2, ..., an으로 이루어진 수열이 있다. ai 의 값은 1보다 크거나 같고, 1,000,000 보다 작거나 같은 자연수이다. 자연수 x가 주어졌을 때, ai+ aj = x (1 ≤ i < j ≤ n)을 만족하는 (ai, aj)쌍의 수를 구하라
- n의 상한이 백만이므로 이중 for문으로 브루트포스를 돌리면 시간초과가 난다
- 똑똑하게 쌍이 있는지 판별하는 방법은 무엇일까?
  - ai의 쌍인 aj가 있는지 어떻게 빠르게 찾을 수 있나 ⇒ 어떤 수가 존재하는지 확인 ⇒ 배열
  - aj = x - ai로 정의된다 그래서 ai가 쌍을 이룰 수 있는지 확인하려면 원소를 보면서 x - ai가 수열에 있는지 보는 것이다
  - 그리고 같은 쌍은 2개씩 생긴다 (ai, aj), (aj, ai) 그래서 모두 카운트하고 2로 나눠준다

## 2. 링크드 리스트

### 1. 1158 - 요세푸스 문제

[1158번: 요세푸스 문제](http://boj.kr/1158)

- 1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고 ⇒ 원형으로 순서가 있음
- 순서대로 K번째 사람을 제거 ⇒ 중간 원소 제거
- 순서가 있고 원형이고 중간 원소가 삭제되야한다 ⇒ 더블 링크드 리스트가 제일 적합

### 2. 1406 - 에디터

[1406번: 에디터](http://boj.kr/1406)

- 중간 원소 삽입, 삭제가 일어난다 ⇒ 제일 적합한 자료구조는 링크드 리스트
- 이런 커서의 이동이 있는 문제들은 iterator가 begin에 있을 때 -1을 하는 것과 end에 있을 때 +1을 하는 것에 대해 예외를 잘 처리해줘야함
- 제한 시간이 0.3초라 최대 3천만번의 연산이 가능하다
  - 이 문제에서 요구하는 연산
    - 커서의 이동 ⇒ O(1)
    - 커서 왼쪽 문자 삭제(중간 원소 삭제) ⇒ O(1)
    - 커서 왼쪽에 문자 추가(중간 원소 삽입) ⇒ O(1)
  - 입력으로 최대 오십만 번의 연산이 주어지므로 3천만번보다는 아득히 적다

### 3. 5397 - 키로거

[5397번: 키로거](http://boj.kr/5397)

- 중간 원소 삽입, 삭제가 일어난다 ⇒ 제일 적합한 자료구조는 링크드 리스트
- 이런 커서의 이동이 있는 문제들은 iterator가 begin에 있을 때 -1을 하는 것과 end에 있을 때 +1을 하는 것에 대해 예외를 잘 처리해줘야함

## 3. 스택

### 1. 10828 - 스택

[10828번: 스택](http://boj.kr/10828)

- 스택에 가능한 연산들 push, pop, size, empty, top을 구현하는 문제

### 2. 10773 - 제로

[10773번: 제로](http://boj.kr/10773)

- 가장 최근에 재민이가 쓴 수를 지우게 시킨다. ⇒ 가장 최근 것을 참조해야한다 ⇒ 스택이 제일 적합하다

### 3. 1874 - 스택 수열

[1874번: 스택 수열](http://boj.kr/1874)

- 스택에 push하는 순서는 반드시 오름차순을 지키도록 한다고 하자
  - 스택 내에서 오름차순을 항상 유지해야함
  - 어떤 원소가 나왔을 때 그 원소 이전까지는 모두 push가 돼있어야함
- 불가능한 경우?
  - top 보다 작은 수가 입력으로 들어오면 불가능한 경우라 할 수 있다
  - 오름차순에 맞춰서 push가 된 것인데 top 보다 작은 원소가 pop 됐어야하므로 불가능한 경우라 할 수 있다
  - 출력되는 원소도 부분적으로 내림차순을 이뤄야한다(불연속되는 원소가 나온다면 구간이 나눠짐을 의미)

### 4. 2493 - 탑

[2493번: 탑](http://boj.kr/2493)

- 이 문제는 다시 풀어서 틀렸음
  - 틀렸던 솔루션
    - 스택에 입력 순서대로 받아서 하나씩 보면서 현재 탑보다(top) 큰 탑 나올 때까지 pop하면서 그 개수를 카운트하고 멈췄을 때 멈춘 포인트가 pop했던 탑들의 신호를 받는 것으로 처리했음
    - 이러면 문제가 뭐나면 10 2 3 11같은 입력이 들어오면 2와 3은 10이 받을 수 있음에도 불구하고 받는 탑이 없게 처리됨
    - 앞으로는 데이터를 만들어서 이럴 때는 문제없는지 점검할 것 ⇒ 테케로만 확인해보고 솔루션이라고 단정 짓지마라!!
  - 올바른 솔루션
    - 입력대로 스택에 쌓되 스택의 top보다 작은게 들어오면 top이 신호를 받을 수 있음을 의미한다 이렇게 top보다 작은 게 들어오면 pop해준다(스택에 쌓지 않는다) pop을 모두 다 한 후에 top의 index를 출력해주고 top보다 큰 게 들어오면 top을 교체해주고 이 top이 받을 원소들을 다시 체크하기 시작한다
  - 깨달은 점
    - 현재 원소보다 이후에 작은게 몇 개 나오는가? == 이후에 나오는 원소들에 대해서 이것보다 큰 제일 가까운 왼쪽 인덱스는 어디인가?에 대한 문제에 스택을 사용할 수 있다

### 5. 6198 - 옥상 정원 꾸미기

[6198번: 옥상 정원 꾸미기](http://boj.kr/6198)

- 2493번 탑 문제와 동일하게 현재 가리키는(top) 원소 이후에 이것보다 작은게 몇 개 있는지 세는 문제였음
- 솔루션
  - s.top() ≤ input이면 top()은 의미 없어지므로(더 이상 볼 필요 x) pop시켜버린다
  - pop을 모두 시킨 후 결과에 스택의 사이즈를 누적시킨다 스택 사이즈는 input보다 큰 게 스택에 몇 개 쌓여 있는지 알려주는 것이므로 이전에 나왔던 원소들 중에 자기보다 큰 게 몇 개 있었는지를 알려준다
    - input보다 큰 게 스택에 몇 개 쌓여 있는지 알려주는 것 == input을 벤치마킹할 수 있는 건물 수를 뜻함
  - 이 문제에서 첫 번째 탑이 벤치 마킹 가능한게 80000, 두 번째 탑이 벤치 마킹 가능한게 79999, …이런식으로 입력이 주어지면 int형의 범위를 초과하게 되어 long long 형을 쓰는게 맞다

### 6. 17298 - 오큰수

[17298번: 오큰수](http://boj.kr/17298)

- 6198번 옥상 정원 꾸미기 문제와 동일하게 현재 가리키는(top) 이후에 이것보다 작은게 몇 개 있는지 세는 문제였음
- 솔루션
  - s.top() < input이면 input이 s.top()의 오큰수가 된다
  - pop시키면서 현재 입력된 원소가 이것의 오큰수이므로 배열에 저장해놓는다
  - 출력에서 순서대로 오큰수를 출력해줘야하므로 인덱스를 기억해놓을 필요가 있다
  - 이 과정을 거치고 스택 내부에 남아있는 원소들은 오큰수를 발견 못한 것이므로 -1이 오큰수가 된다

### 7. 3015 - 오아시스 재결합

[3015번: 오아시스 재결합](http://boj.kr/3015)

- 배열의 임의의 두 원소 A와 B가 쌍을 이룬다 ⇒ A와 B 사이에 A 또는 B보다 큰 원소가 없어야함
- 임의의 원소 x의 좌우로 자기자신과 같거나 보다 작은 원소의 갯수를 구할 때 스택을 쓸 수 있다
- s.top()을 보면서 쌍을 몇 개 이루는지 보면서 진행됨
- 솔루션
  - s.top() ≤ input이면 input이 자기 오른쪽에서 크거나 같은게 나온 것이므로 쌍의 수를 그만세야한다
  - pop 시킨다
    - s.top() == input
      - input의 쌍의 수를 초기화할 때(자기보다 왼쪽에서 자기보다 작은 수들) 사용하기 위해 s.top()의 cnt(s.top() == input 보다 작았던 수들이 이루는 쌍의 수)를 이용한다
    - s.top() < input
      - s.top()의 오른쪽 마지막이 input이므로 s.top()의 쌍의 수를 그만 세야한다 s.top()을 input으로 교체한다
  - pop을 모두하고 나서 스택에 기존에 쌓여있던 원소(input보다 큰 것이 input과 쌍을 이루므로) answer에 1추가한다

### 8. 6549 - **히스토그램에서 가장 큰 직사각형**

[6549번: 히스토그램에서 가장 큰 직사각형](http://boj.kr/6549)

- 배열에서 자신의 앞에 자기보다 작은 것과 자신 사이에 큰 게 몇 개 있었는지 구하는게 목적
- 솔루션
  - 스택을 <막대 높이, 최초 등장 위치>로 관리한다
  - s.top() ≥ input일 때 pop시키면서 최대 사각형 높이를 갱신한다
  - index를 이용해서 너비를 구할 수 있다, 높이는 입력
  - 자기보다 작은것이 나오기 이전까지 pop시키면서 스택에 쌓여있던 input보다 큰 원소들의 넓이를 구한다
    - s.top().first \* (i - s.top().second);
    - 그리고 input보다 큰 것들이 pop되는 것이므로 자기 앞에 자기보다 큰 게 몇 개 있었는지에 따라 최초 등장 위치가 바뀌므로 start(최초 등장 위치, 초기값은 index) = s.top().second로 갱신한다
  - 그리고 스택에 <input, start>를 쌓는다
  - 마지막 몇 원소들이 s.top() < input이라 계속 쌓여있을 수 있으므로, 이것들 또한 넓비에 반영해줘야하니 잔여물 처리가 필요하다
    - 오름차순으로 들어오는 입력을 생각해보면됨

## 4. 큐

### 1. 10845 - 큐

[10845번: 큐](http://boj.kr/10845)

- 큐에 가능한 연산들 push, pop, size, empty, front, back을 구현하는 문제
- 큐에 back이 있단 것을 처음 알았음.. ⇒ 시간복잡도 O(1)

### 2. 18258 - 큐 2

[18258번: 큐 2](http://boj.kr/18258)

- 10845번 - 큐 문제에서 명령의 수가 많아진 버전
- 큐 컨테이너의 메서들의 시간복잡도를 잘 아는게 중요

### 3. 2164 - 카드2

[2164번: 카드2](http://boj.kr/2164)

- 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다. ⇒ FIFO
- 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다. ⇒ 제일 위의 원소를 바로 참조 ⇒ 큐를 사용

## 5. 덱

### 1. 1021 - 회전하는 큐

[1021번: 회전하는 큐](http://boj.kr/1021)

- 첫 번째 원소를 꺼낸다
- 왼쪽으로 한 칸 이동 시킨다 ⇒ pop_front() + push_back()
- 오른쪽으로 한 칸 이동 시킨다 ⇒ pop_back() + push_front()
- 이에 가장 적합한 자료구조는 덱이다
- 시간복잡도가 높았다면 일일이 이동시키는 것은 불가능
- 찾고자하는 원소가 중앙값 이전이라면 앞에서 뽑는게 이득, 이후라면 뒤에서 뽑는게 이득

### 2. 10866 - 덱

[10866번: 덱](http://boj.kr/10866)

- 덱에서 가능한 연산들 push_front, push_back, pop_front, pop_back, size, empty, front, back을 구현하는 문제
- 참고로 덱은 배열처럼 랜덤엑세스 가능

### 3. 5430 - AC

[5430번: AC](http://boj.kr/5430)

- R이 들어올 때마다 매번 reverse하면 O(N)이기 때문에 시간초과가 난다
- R이 들어올 때마다 뒤집었는지 아닌지를 나타내는 플래그 변수를 변수를 두어 뒤집힌 상태인지 아닌지 판단한다
- 매번 앞 원소를 삭제해야하기 때문에 뒤집힌 상태에서 앞 원소를 제거하는 것은 원 배열의 맨 뒤 원소를 제거하는 것과 같다
  - 맨 앞이나 맨 뒤 원소가 제거된다 ⇒ 가장 적합한 자료구조는 덱

### 4. 11003 - 최솟값 찾기

[11003번: 최솟값 찾기](http://boj.kr/11003)

- 슬라이딩 윈도우하면서 구간 내에서 최대나 최소 찾는 문제에 덱이 활용될 수 있음(이동될 때마다 원소가 x개 추가 / 감소됨)
- 구간에서 제외되는 수를 찾기 위해 덱 내에서 원소를 인덱스와 쌍으로 관리
- 오름차순을 유지하기 위해서 인풋이 새로들어올 때 인풋보다 큰 원소들을 덱 내에서 제거한다(최솟값만 알면되기 때문에 갖고있을 필요가 없다)

  ```cpp
  while (!dq.empty() && dq.back().second >= a) dq.pop_back();
  dq.push_back({i, a});
  ```

- 슬라이딩 윈도우할 때마다 구간에서 제외되는 원소 삭제

## 6. 스택의 활용(올바른 괄호쌍)

### 1. 4949 - 균형잡힌 세상

[4949번: 균형잡힌 세상](http://boj.kr/4949)

- 여는 괄호가 들어올 때마다 스택에 쌓고 닫는 괄호가 나올 때마다 스택에서 pop 시킨다
- 여기에는 괄호가 두 종류가 등장한다 “(”, “[”
- 모든 문자열을 읽고난 후 스택이 비지 않았다면 올바른 괄호 문자열이 아니다
- 스택이 이용되는 이유는 가장 왼쪽의 여는 괄호의 쌍이 가장 오른쪽에 나오는 닫는 괄호의 쌍이기 때문이다
- 쌍으로 정의된 두 특정 문자의 쌍을 찾을 때 스택을 사용할 수 있다

### 2. 3986 - 좋은 단어

[3986번: 좋은 단어](http://boj.kr/3986)

- 단어 위로 아치형 곡선을 그어 같은 글자끼리(A는 A끼리, B는 B끼리) 쌍을 짓기로 하였다. 만약 선끼리 교차하지 않으면서 각 글자를 정확히 한 개의 다른 위치에 있는 같은 글자와 짝 지을수 있다 ⇒ 괄호쌍을 다르게 표현한 것이다
- 문자가 괄호로 대체된 것이다
- 스택의 top과 비교하고 같으면 pop시키고 다르면 push한다
- 문자열을 모두 읽고난 후 스택이 비어있지 않다면 좋은단어가 아님

### 3. 9012 - 괄호

[9012번: 괄호](http://boj.kr/9012)

- 여는 괄호가 들어올 때마다 스택에 쌓고 닫는 괄호가 나올 때마다 스택에서 pop 시킨다

### 4. 10799 - 쇠막대기

[10799번: 쇠막대기](http://boj.kr/10799)

- 올바른 괄호쌍을 찾을 때마다 스택에 쌓여있는 여는 괄호 개수(스택의 원소의 수)개의 막대기가 잘린다

### 5. 2504 - 괄호의 값

[2504 - 골화의 값](http://boj.kr/2504)

- ‘(’ 가 들어오면 2를 곱하고 ‘[’ 가 들어오면 3을 곱한다 제일 기본케이스는 길이 2인 괄호쌍이므로 그 때는 누적곱을 끝내야하므로 누적합에 더하고, 누적곱에 나누기 연산을하여 해당 괄호쌍의 누적값을 제거한다
