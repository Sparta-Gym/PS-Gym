# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/11286" rel="nofollow">11286 - 절댓값 힙</a>](#11286---절댓값-힙)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 코멘트](#2-코멘트)
  - [<a href="https://www.acmicpc.net/problem/1715" rel="nofollow">1715 - 카드 정렬하기</a>](#1715---카드-정렬하기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 코멘트](#2-코멘트-1)
  - [<a href="https://www.acmicpc.net/problem/1927" rel="nofollow">1927 - 최소 힙</a>](#1927---최소-힙)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 코멘트](#2-코멘트-2)
  - [<a href="https://www.acmicpc.net/problem/2075" rel="nofollow">2075 - N번째 큰 수</a>](#2075---n번째-큰-수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 코멘트](#2-코멘트-3)
  - [<a href="https://www.acmicpc.net/problem/11279" rel="nofollow">11279 - 최대 힙</a>](#11279---최대-힙)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 코멘트](#2-코멘트-4)
  - [<a href="https://www.acmicpc.net/problem/13975" rel="nofollow">13975 - 파일 합치기 3</a>](#13975---파일-합치기-3)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 코멘트](#2-코멘트-5)
  - [<a href="https://www.acmicpc.net/problem/1655" rel="nofollow">1655 - 가운데를 말해요</a>](#1655---가운데를-말해요)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 코멘트](#2-코멘트-6)
  - [<a href="https://www.acmicpc.net/problem/1781" rel="nofollow">1781 - 컵라면</a>](#1781---컵라면)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 코멘트](#2-코멘트-7)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 11월 11일 금요일 09시 15분 17초 KST -->

<!--te-->

## [11286 - 절댓값 힙](https://www.acmicpc.net/problem/11286)

### 1. 해결 핵심 아이디어

- 이 문제의 경우 절댓값이 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다. 절댓값이 가장 작은 값이 여러개일 때는, 가장 작은 수를 출력하고, 그 값을 배열에서 제거한다는 조건 때문에 비교 함수를 직접 짜야하는데, priority_queue를 사용해서 해결해보자
- 기존에 알고있던 custom 비교 함수는 보통 함수 형태로 전달했었는데, priority_queue는 컨테이너이다 보니 sort와는 다르게 비교 클래스를 전달해야한다(함수의 비교 → 비교함수, 컨테이너의 비교 → 비교 클래스)

  ```cpp
  class cmp{
   public:
    bool operator() (int a, int b){
     if(abs(a) != abs(b)) return abs(a) > abs(b);
     return a > 0 && b < 0;
    }
  };
  ```

- 비교 함수던 비교 클래스던 정렬이 끝났을 때 a와 b의 위치가 어떻게 되야하는지 생각해보면 된다 a가 앞 원소, b가 뒤 원소니까 만약 내림 차순 정렬한다고 했을 때 정렬이 끝나면 a는 앞 원소, b는 뒤 원소이므로 a가 b보다 뒤에 있어야되므로 return문에 a를 앞 원소, b를 뒤 원소로 가정하고 정렬이 끝나고 만족되어야하는 관계를 작성해주면된다
- 항상 cmp(a,a) = false를 만족해야한다, 아니면 런타임에러남

### 2. 코멘트

- 비교 함수와 비교 클래스 헷갈리기 쉬우니

## [1715 - 카드 정렬하기](https://www.acmicpc.net/problem/1715)

### 1. 해결 핵심 아이디어

- 허프만 코딩(압축에 쓰이는 알고리즘)에서 이 문제와 똑같이 카드 묶음 중 제일 작은 거와 그 다음 작은거 두 개를 묶어서 새로운 묶음으로 만들고, 또 같은 작업이 반복되서 나온 최종적인 작업의 횟수가 제일 작음이 증명돼있다(그리디)
  - greedy에서 봤던 task scheduling problem
- 이 사실만 알고 있다면, 그냥 끝나는 문제임
- 최소를 반복적으로 꺼내야하므로 heap을 사용하기 매우 좋은 상황

### 2. 코멘트

- 우선순위 큐는 특별하게 응용되는 분야가 있다기 보다 우선 순위 큐가 제공하는 최대값 최소값 빨리 찾기를 요구하는 문제에서 쓰면 된다
- 그리디랑 자주 묶일 가능성 매우 높음

## [1927 - 최소 힙](https://www.acmicpc.net/problem/1927)

### 1. 해결 핵심 아이디어

- 최소힙 구현하는 문제

### 2. 코멘트

- warm up용 문제

## [2075 - N번째 큰 수](https://www.acmicpc.net/problem/2075)

### 1. 해결 핵심 아이디어

- 메모리 제한이 12MB이고 n의 상한이 1500이라 최대로 데이터가 들어와도 1500 \* 1500 \* 4Byte = 9MB이기에 제한에 안 걸릴 줄 알았는데 걸린다
- sizeof로 pq사이즈를 뽑아보니 원래는 크기 5일때 기대값으로 20이 나와야하는데 32가 나온다
- 배열을 써서 내림차순으로 정렬을 한 다음 n-1번째 위치하는 원소를 뽑아주는 방식을 취한다면 메모리 제한에 걸리지 않는다, 배열은 n \* n \* 4B 크기를 갖기 때문이다
- 그래서 메모리 줄일 방법이 생각이 안나서 정답코드를 참고하였다
- n번째로 큰 값이 배열에서 어디에 위치할지 모르고, 우선순위 큐에는 최대 n개의 원소가 담겨야 n번째 큰 값을 찾을 수 있다
- 입력 받으면서 우선 순위 큐에 넣되, 사이즈가 n을 넘어간다면 pop시켜서 사이즈 n을 계속 유지시켜준다
- 결과적으로 우선순위큐에는 입력 받으면서 n번째 큰 수보다 작은 수들은 다 pop되었으므로 top이 n번째로 작은 수가 된다

### 2. 코멘트

- 컨테이너 사용 시 메모리 계산방법에 대해 바킹독님 블로그에 질문 남겨두었음 - [질문 링크](https://blog.encrypted.gg/1015#comment13980070)
- 이 문제 실버였네? 자존심 상한다

## [11279 - 최대 힙](https://www.acmicpc.net/problem/11279)

### 1. 해결 핵심 아이디어

- 최대힙으로 알맞은 쿼리처리해주면 되는 문제

### 2. 코멘트

- STL warm up용 문제

## [13975 - 파일 합치기 3](https://www.acmicpc.net/problem/13975)

### 1. 해결 핵심 아이디어

- 1715번 카드 정렬하기 문제와 동일하게 허프만 코딩 방법으로 해결하면 된다

### 2. 코멘트

- 간단하니 패스

## [1655 - 가운데를 말해요](https://www.acmicpc.net/problem/1655)

### 1. 해결 핵심 아이디어

### 2. 코멘트

## [1781 - 컵라면](https://www.acmicpc.net/problem/1781)

### 1. 해결 핵심 아이디어

### 2. 코멘트
