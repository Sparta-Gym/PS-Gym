# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/1431" rel="nofollow">1431 - 시리얼 번호</a>](#1431---시리얼-번호)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 코멘트](#2-코멘트)
  - [<a href="https://www.acmicpc.net/problem/11652" rel="nofollow">11652 - 카드</a>](#11652---카드)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 코멘트](#2-코멘트-1)
  - [<a href="https://www.acmicpc.net/problem/5648" rel="nofollow">5648 - 역원소 정렬</a>](#5648---역원소-정렬)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 코멘트](#2-코멘트-2)
  - [<a href="https://www.acmicpc.net/problem/1181" rel="nofollow">1181 - 단어 정렬</a>](#1181---단어-정렬)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 코멘트](#2-코멘트-3)
  - [<a href="https://www.acmicpc.net/problem/2910" rel="nofollow">2910 - 빈도 정렬</a>](#2910---빈도-정렬)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 코멘트](#2-코멘트-4)
  - [<a href="https://www.acmicpc.net/problem/10814" rel="nofollow">10814 - 나이순 정렬</a>](#10814---나이순-정렬)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 코멘트](#2-코멘트-5)
  - [<a href="https://www.acmicpc.net/problem/11656" rel="nofollow">11656 - 접미사 배열</a>](#11656---접미사-배열)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 코멘트](#2-코멘트-6)
  - [<a href="https://www.acmicpc.net/problem/10825" rel="nofollow">10825 - 국영수</a>](#10825---국영수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 코멘트](#2-코멘트-7)
  - [<a href="https://www.acmicpc.net/problem/7795" rel="nofollow">7795 - 먹을 것인가 먹힐 것인가</a>](#7795---먹을-것인가-먹힐-것인가)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
    - [2. 코멘트](#2-코멘트-8)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 11월  3일 목요일 13시 12분 58초 KST -->

<!--te-->

## [1431 - 시리얼 번호](https://www.acmicpc.net/problem/1431)

### 1. 해결 핵심 아이디어

- 정렬 기준이 여러개인 문제

### 2. 코멘트

- 비교함수를 짤 때 각 조건에 맞게 true, false를 해주는데 이게 생각보다 매우 헷갈림
- 두 개 단어 a와 b를 비교할 때 길이가 같으면 두 단어에 포함된 숫자의 합으로 우선순위를 정한다고 했는데, 여기서 a의 합을 sum[0], b의 합을 sum[1]이라해놓고 if(sum[0] <= sum[1]) return a < b;라고 했는데, 기껏 합을 구해놓고 사전순 정렬을 하고있어서 처음에 제대로 안 나왔는데, 합이 같을 경우만 사전 순 정렬이므로, 그냥 합이 다를 때 합이 큰 것이 true가 되게 해주면 알아서 정렬이된다 즉, return if(sum[0] != sum[1]) return sum[0] < sum[1]해주면 되는데, 어차피 a가 더 커도 false가 되기때문에 a가 뒤로 가기때문에 상관없다

## [11652 - 카드](https://www.acmicpc.net/problem/11652)

### 1. 해결 핵심 아이디어

- 정렬을 응용해서 빈도 수를 해결하는 문제
- 문제의 입력 범위를 보면 long long 형의 최대 범위로 빈도수 배열로 문제를 풀려면 메모리제한을 아득히 뛰어넘는다
- 그렇다고 2중 for문으로 같은 카드가 몇개 있는지 세려고하면 카드의 수가 십만이기에 $10^12$ 이므로 시간제한을 못 맞춘다
- 이럴 때 정렬을 이용해볼 수 있는데, 정렬을 하면 우선순위가 같은 원소끼리 인접하기 때문이다
- 빈도 수를 구할 때 최대 입력 크기만큼 빈도수 배열을 선언하지 않고도 정렬을 이용하는 방법이 있다

### 2. 코멘트

- 정렬하고 커서로 몇개 있는지 세고 다음 수로 넘어가고 이런 방식으로 배열 끝까지 확인하고 그 중 가장 많이 가지고 있는 정수 출력

## [5648 - 역원소 정렬](https://www.acmicpc.net/problem/5648)

### 1. 해결 핵심 아이디어

- 입력받은 숫자들을 뒤집어서 정렬하는 문제
- 문자열로 입력받아 reverse하는 쉬운 길도 있었지만 구현해보고자 직접 구현했음

### 2. 코멘트

- 입력 최대가 1조이기 때문에 long long 타입을 사용해야함

## [1181 - 단어 정렬](https://www.acmicpc.net/problem/1181)

### 1. 해결 핵심 아이디어

- 중복 제거를 위해 set과 비교 기준 구조체를 넣어줘도 되지만 정렬을 한 후 같은 원소끼리는 인접하다는 특징때문에 출력할 때만 이 특징을 활용해서 출력해주면 문제를 풀 수 있다

### 2. 코멘트

- 벡터 자체를 중복제거하는 방법도 있지만 정렬의 특성 상 할 필요가 굳이 없음

## [2910 - 빈도 정렬](https://www.acmicpc.net/problem/2910)

### 1. 해결 핵심 아이디어

- 빈도순으로 정렬하되, 빈도가 같으면 들어온 순서대로 정렬하는 문제
- 들어온 순서를 유지하기 위해 stable_sort를 사용할 수 있다
- 빈도순으로 내림차순으로 stable_sort해주면 정답

### 2. 코멘트

- 입력 수의 최대 크기가 10억이라 빈도수로 해결하려하면 메모리 초과가 난다

## [10814 - 나이순 정렬](https://www.acmicpc.net/problem/10814)

### 1. 해결 핵심 아이디어

- 0x0E Sorting I에 이미 이 문제가 있음

### 2. 코멘트

- 0x0E Sorting I에 이미 이 문제가 있음

## [11656 - 접미사 배열](https://www.acmicpc.net/problem/11656)

### 1. 해결 핵심 아이디어

- stl substr 함수로 접미사 생성하고 사전순 정렬이니 별다른 비교없이 정렬해주면 끝

### 2. 코멘트

- [substr 사용법](https://modoocode.com/235)

## [10825 - 국영수](https://www.acmicpc.net/problem/10825)

### 1. 해결 핵심 아이디어

- 정직하게 비교 기준에 따라 비교함수 써줘서 해결
- 정답 코드를 보니 내림차순해야하는 원소에 \* -1을 해서 오름차순 정렬이 되게 했고, 비교 순서도 왼쪽에서 오른쪽으로 가기때문에 그에 맞게 순서를 넣어줘서 특별한 비교함수 없이 default 사전순 정렬로만 해결했네

### 2. 코멘트

- 튜플의 i번째 원소만 가져오려면 get<i>(tuple_name)해주는 방법도 있었는데 까먹었다가 정답코드보고 기억남

## [7795 - 먹을 것인가 먹힐 것인가](https://www.acmicpc.net/problem/7795)

### 1. 해결 핵심 아이디어

- A를 정렬하고, B 돌면서 B의 원소 b가 A에서 언제 마지막 등장했는지 last index를 구한 뒤, A 크기 - li = b 원소보다 큰 쌍의 수가 나온다
- 정답코드에서는 A와 B를 합쳐서 하나의 (숫자, A의 원소일 때 0, B의 원소일 때 1)를 pair 배열로 둔다음 정렬하면, 어떤 수 x가 A에도 속하고 B에도 속한다면, x가 A에 속한 경우가 먼저 나오게된다 현재까지 나온 x의 수를 cnt라 할 때 B에 속해있다면 cnt를 증가시키고, A에 속해있다면 cnt를 정답에 누적해서 더한다

### 2. 코멘트

- last index를 구할 때 upper_bound를 쓸 수 있음을 인지하고 있었지만, 쓰지않고 구현력땜시 곧이 곧대로 구현해봤음
