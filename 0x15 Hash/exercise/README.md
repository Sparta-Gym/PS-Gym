# Learning About

<!--ts-->

- [Learning About](#learning-about)
  - [<a href="https://www.acmicpc.net/problem/7785" rel="nofollow">7785 - 회사에 있는 사람</a>](#7785---회사에-있는-사람)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어)
    - [2. 코멘트](#2-코멘트)
  - [<a href="https://www.acmicpc.net/problem/1620" rel="nofollow">1620 - 나는야 포켓몬 마스터 이다솜</a>](#1620---나는야-포켓몬-마스터-이다솜)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-1)
    - [2. 코멘트](#2-코멘트-1)
  - [<a href="https://www.acmicpc.net/problem/13414" rel="nofollow">13414 - 수강신청</a>](#13414---수강신청)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-2)
    - [2. 코멘트](#2-코멘트-2)
  - [<a href="https://www.acmicpc.net/problem/17219" rel="nofollow">17219 - 비밀번호 찾기</a>](#17219---비밀번호-찾기)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-3)
    - [2. 코멘트](#2-코멘트-3)
  - [<a href="https://www.acmicpc.net/problem/9375" rel="nofollow">9375 - 패션왕 신해빈</a>](#9375---패션왕-신해빈)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-4)
    - [2. 코멘트](#2-코멘트-4)
  - [<a href="https://www.acmicpc.net/problem/16165" rel="nofollow">16165 - 걸그룹 마스터 준석이</a>](#16165---걸그룹-마스터-준석이)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-5)
    - [2. 코멘트](#2-코멘트-5)
  - [<a href="https://www.acmicpc.net/problem/11478" rel="nofollow">11478 - 서로 다른 부분 문자열의 개수</a>](#11478---서로-다른-부분-문자열의-개수)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-6)
    - [2. 코멘트](#2-코멘트-6)
  - [<a href="https://www.acmicpc.net/problem/19583" rel="nofollow">19583 - 싸이버개강총회</a>](#19583---싸이버개강총회)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-7)
    - [2. 코멘트](#2-코멘트-7)
  - [<a href="https://www.acmicpc.net/problem/20166" rel="nofollow">20166 - 문자열 지옥에 빠진 호석</a>](#20166---문자열-지옥에-빠진-호석)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-8)
    - [2. 코멘트](#2-코멘트-8)
  - [<a href="https://www.acmicpc.net/problem/1351" rel="nofollow">1351 - 무한 수열</a>](#1351---무한-수열)
    - [1. 해결 핵심 아이디어](#1-해결-핵심-아이디어-9)
    - [2. 코멘트](#2-코멘트-9)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 11월  3일 목요일 13시 23분 24초 KST -->

<!--te-->

## [7785 - 회사에 있는 사람](https://www.acmicpc.net/problem/7785)

### 1. 해결 핵심 아이디어

- 원소의 존재여부를 확인하는 문제 ⇒ 검색이 필요
- 이분 탐색 풀이법
  - 생각치도 못했는데 이런 방법도 있을 수 있겠구나
  - enter와 leave리스트 각각을 이분 탐색하여 enter와 leave횟수를 센 뒤, enter > leave이면 남아있는 것, 아니면 퇴근한 것으로 판단할 수 있다
    - upper_bound, lower_bound의 차로 몇 개있는지 확인하는 방법
  - enter와 leave를 하나의 리스트에 두고 enter은 +1, leave는 -1 이렇게 정의해서 양수면 남아있는 것, 아니면 퇴근한 것으로 판단할 수도 있겠다
    - pair<name, 1 or -1>이렇게 저장해서 이분탐색하는 방법
- 투 포인터 풀이법
  - 이분탐색이랑 비슷하게 각 사람마다 enter와 leave에 대한 포인터를 따로둬서 몇 번 전진했는지에 따라 양수이면 남아있는 것 아니면 퇴근 이런 식으로 접근할 수도 있겠다
- 해시 풀이법
  - unordered_set을 정의한다
  - enter일 때 insert, leave일 때 erase하면 끝
  - 다만 사전순의 역순으로 이름을 출력해줘야하기에 정렬이 필요한데, unordered_set은 정렬이 기본적으로 안되는 자료 구조이기 때문에 벡터로 옮겨서 정렬해줘야한다

### 2. 코멘트

- 간단해서 패스

## [1620 - 나는야 포켓몬 마스터 이다솜](https://www.acmicpc.net/problem/1620)

### 1. 해결 핵심 아이디어

- 번호가 주어졌을 때 이름을 답하는 문제는 배열을 써서 해결 가능
- 이름이 주어졌을 때 번호를 답하는 문제는 이름을 key로 번호를 value로하는 unordered_map을 만들어두면 해결 가능, 이분 탐색으로도 해결 가능
- 배열에서 값 가져오는 것보다 unordered_map에서 값 가져오는 것이 더 느리다, 배열을 쓸 수 있는 상황이라면 배열을 쓰자

### 2. 코멘트

- 간단해서 패스

## [13414 - 수강신청](https://www.acmicpc.net/problem/13414)

### 1. 해결 핵심 아이디어

- <학번, 신청 순서>쌍으로 저장하고, unordered_map의 특성에따라 키가 있어도 덮어씌워준다
- 근데 처음에 insert로 넣어줬더니 덮어씌워지는게 아니라 같은 값이 들어오면 넣지않고 폐기한다
- map[학번] = 순서로 하니 그제서야 덮어씌워졌다
- 문제였던 점은 insert는 새로운 원소의 삽입이고, assign방식은 없으면 넣고 있으면 덮어씌워주는 것이었음

### 2. 코멘트

- unordered_map에서 insert와 assign의 차이를 알고가자

## [17219 - 비밀번호 찾기](https://www.acmicpc.net/problem/17219)

### 1. 해결 핵심 아이디어

- 키에 대한 값 조회가 필요한 문제로 set대신 map활용

### 2. 코멘트

- STL 사용법 warm up 문제였음

## [9375 - 패션왕 신해빈](https://www.acmicpc.net/problem/9375)

### 1. 해결 핵심 아이디어

- 부족한 수학 밑천이 드러난 문제
- 확률과 통계배울 때 곱사건의 경우의 수 구하는 문제에서 옷의 종류들이 있을 때 총 가지수를 구하는 문제를 풀어본 적이 있을 것이다
- 그 문제의 확장버전으로 특정 종류의 옷을 안 입는 경우도 가능하기에 각 옷의 종류에 +1을 해주고 곱사건을 구한다
- 모든 경우의 수에서 모든 옷을 안 입는경우 즉 알몸인 경우를 빼줘야하고 알몸인 경우는 모든 옷이 선택되지 않은 경우 단 한 가지만 존재한다ㄴ

### 2. 코멘트

- 조합 문제에 대한 공부가 더 필요하다..

## [16165 - 걸그룹 마스터 준석이](https://www.acmicpc.net/problem/16165)

### 1. 해결 핵심 아이디어

- 팀이름을 주면 멤버들을 다 출력해줘야해서 <team, [members]>쌍으로 관리하는 해시하나, 멤버이름을 주면 팀이름을 출력해줘야해서 <name, team>쌍으로 관리하는 해시하나 총 두 개를 두고 퀴즈 종류에 알맞게 출력해주었음
- 이렇게 한 이유는 하나만 둬도 굳이 상관은 없으나 그러면 O(N)의 탐색과정이 필요하게되어 해시를 안 쓰는 것과 마찬가지임

### 2. 코멘트

- 퀴즈질의를 받을 때 정렬해줬는데 그냥 입력받고, 끝나면 팀 바이 팀으로 정렬해주는게 더 효율적이다

## [11478 - 서로 다른 부분 문자열의 개수](https://www.acmicpc.net/problem/11478)

### 1. 해결 핵심 아이디어

- 모든 부분 문자열을 substr로 만들어주고, 그것이 만들어지면 unordered_set에 중복이 안되게 저장해서 unique한 부분 문자열의 수를 구해주었음

### 2. 코멘트

- 간단해서 코멘트 없음

## [19583 - 싸이버개강총회](https://www.acmicpc.net/problem/19583)

### 1. 해결 핵심 아이디어

- <이름, {입장, 퇴장}>쌍으로 해시를 구성했고, 채팅기록을 읽으면서 00:00 ~ S 사이에 있는 채팅이 발견되면 입장 여부를 true로 변경, E ~ Q사이에 있으면 퇴장 여부를 true로 변경해주었다

### 2. 코멘트

- 입력을 얼마나 받는지 안 나와있어서 당황했는데 EOF까지 입력받으면 된다하더라
- EOF는 맥북 기준으로 ctrl + D로 입력할 수 있다
- EOF까지 입력 받는 방법

  ```cpp

  while (!cin.eof()) {
    /* 입력 받고 처리 */
  }

  ```

  [참고](https://poalim.tistory.com/37#:~:text=C%2B%2B%20%EC%97%90%EC%84%9C%EB%8A%94%20cin%20%EA%B0%9D%EC%B2%B4%EC%99%80,%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C%20%EC%B2%98%EB%A6%AC%ED%95%B4%20%EC%A3%BC%EC%96%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4.&text=%EC%9C%84%EC%99%80%20%EA%B0%99%EC%9D%B4%20%EC%9E%85%EB%A0%A5%20%EB%B0%9B%EC%9C%BC%EB%A9%B4%20eof,%EC%8B%9C%20%EB%B0%98%EB%B3%B5%EB%AC%B8%EC%9D%B4%20%EC%A2%85%EB%A3%8C%EB%90%9C%EB%8B%A4.)

## [20166 - 문자열 지옥에 빠진 호석](https://www.acmicpc.net/problem/20166)

### 1. 해결 핵심 아이디어

- 이 문제는 그래프 탐색을 해야한다는 것은 쉽게 파악할 수 있었는데 같은 정점을 여러번 방문가능하기 때문에 기존에 알고있던 그래프 탐색알고리즘인 bfs, dfs를 이용하는게 맞는지 의문이 들었다, 현재까지 배운바로는 두 알고리즘 모두 모든 정점을 방문할 때 사용하는 알고리즘이고 모든 노드를 정확히 한 번씩만 방문가능한 것으로 알고있었기 때문이다
  - 교과서에서 dfs, bfs의 정의에 정확히 한 번씩만 방문이라는 문구가 들어있는지 확인해야겠다
- 해시를 <path, 경우의 수> 쌍으로 저장하고 노드를 방문할 때마다 생기는 경우의 수를 카운팅한다
- 문자열의 길이가 5를 넘어가면 종료시킨다
- 길이 1 ~ 5인 가능한 모든 문자열을 그래프 탐색을 통해 만들어놓고 k개의 입력에 대해 해당하는 경우의 수를 출력해주면된다

### 2. 코멘트

- 이 문제 자체는 어렵지 않았는데 너무 그래프 탐색 알고리즘 정의에 얽매여서 다른 탐색 방법이 있을까 고민해봤는데 dfs를 사용하더라
- char 하나를 string으로 만드는 방법으로 char + ""을 시도했는데 결과가 빈 문자열이더라

## [1351 - 무한 수열](https://www.acmicpc.net/problem/1351)

### 1. 해결 핵심 아이디어

- 이 문제는 보자마자 문제에서 점화식을 주기때문에 다이나믹 프로그래밍이란 것을 캐치했다
- N과 P, Q의 상한이 매우커서 곧이곧대로 모두 계산하면 절대 못 푼다
- 그리고 P나 Q가 2이고 N이 1조일 때, 배열로하면 최대 5천억개의 공간이 필요하지만 관찰을 통해 모든 수가 아닌 N의 약수 중 일부만 필요하다는 사실을 알아냈고 일부를 저장하기 위해 해시를 사용하였다
- 해시는 <i, dp[i]>로 구성하였다
- dp는 bottom-up으로 구현하는 것보다 top-down으로 하는 방식이 편해서 재귀로 구현하였다

### 2. 코멘트

- 캐치를 잘 해냈다(뿌듯)
